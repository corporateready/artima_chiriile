"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_rudderstack_analytics-js_dist_npm_modern_esm_index_mjs"],{

/***/ "(app-pages-browser)/./node_modules/@rudderstack/analytics-js/dist/npm/modern/esm/index.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@rudderstack/analytics-js/dist/npm/modern/esm/index.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RudderAnalytics: function() { return /* binding */ RudderAnalytics; }\n/* harmony export */ });\nfunction _isPlaceholder(a){return a!=null&&typeof a==='object'&&a['@@functional/placeholder']===true;}\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */function _curry1(fn){return function f1(a){if(arguments.length===0||_isPlaceholder(a)){return f1;}else {return fn.apply(this,arguments);}};}\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */function _curry2(fn){return function f2(a,b){switch(arguments.length){case 0:return f2;case 1:return _isPlaceholder(a)?f2:_curry1(function(_b){return fn(a,_b);});default:return _isPlaceholder(a)&&_isPlaceholder(b)?f2:_isPlaceholder(a)?_curry1(function(_a){return fn(_a,b);}):_isPlaceholder(b)?_curry1(function(_b){return fn(a,_b);}):fn(a,b);}};}\n\n/**\n * Optimized internal three-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */function _curry3(fn){return function f3(a,b,c){switch(arguments.length){case 0:return f3;case 1:return _isPlaceholder(a)?f3:_curry2(function(_b,_c){return fn(a,_b,_c);});case 2:return _isPlaceholder(a)&&_isPlaceholder(b)?f3:_isPlaceholder(a)?_curry2(function(_a,_c){return fn(_a,b,_c);}):_isPlaceholder(b)?_curry2(function(_b,_c){return fn(a,_b,_c);}):_curry1(function(_c){return fn(a,b,_c);});default:return _isPlaceholder(a)&&_isPlaceholder(b)&&_isPlaceholder(c)?f3:_isPlaceholder(a)&&_isPlaceholder(b)?_curry2(function(_a,_b){return fn(_a,_b,c);}):_isPlaceholder(a)&&_isPlaceholder(c)?_curry2(function(_a,_c){return fn(_a,b,_c);}):_isPlaceholder(b)&&_isPlaceholder(c)?_curry2(function(_b,_c){return fn(a,_b,_c);}):_isPlaceholder(a)?_curry1(function(_a){return fn(_a,b,c);}):_isPlaceholder(b)?_curry1(function(_b){return fn(a,_b,c);}):_isPlaceholder(c)?_curry1(function(_c){return fn(a,b,_c);}):fn(a,b,c);}};}\n\nfunction _has(prop,obj){return Object.prototype.hasOwnProperty.call(obj,prop);}\n\n/**\n * Gives a single-word string description of the (native) type of a value,\n * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not\n * attempt to distinguish user Object types any further, reporting them all as\n * 'Object'.\n *\n * @func\n * @memberOf R\n * @since v0.8.0\n * @category Type\n * @sig * -> String\n * @param {*} val The value to test\n * @return {String}\n * @example\n *\n *      R.type({}); //=> \"Object\"\n *      R.type(new Map); //=> \"Map\"\n *      R.type(new Set); //=> \"Set\"\n *      R.type(1); //=> \"Number\"\n *      R.type(false); //=> \"Boolean\"\n *      R.type('s'); //=> \"String\"\n *      R.type(null); //=> \"Null\"\n *      R.type([]); //=> \"Array\"\n *      R.type(/[A-z]/); //=> \"RegExp\"\n *      R.type(() => {}); //=> \"Function\"\n *      R.type(async () => {}); //=> \"AsyncFunction\"\n *      R.type(undefined); //=> \"Undefined\"\n *      R.type(BigInt(123)); //=> \"BigInt\"\n */var type=/*#__PURE__*/_curry1(function type(val){return val===null?'Null':val===undefined?'Undefined':Object.prototype.toString.call(val).slice(8,-1);});\n\nfunction _isObject(x){return Object.prototype.toString.call(x)==='[object Object]';}\n\n/**\n * Determine if the passed argument is an integer.\n *\n * @private\n * @param {*} n\n * @category Type\n * @return {Boolean}\n */const _isInteger = Number.isInteger||function _isInteger(n){return n<<0===n;};\n\nfunction _nth(offset,list){var idx=offset<0?list.length+offset:offset;return list[idx];}\n\nfunction _cloneRegExp(pattern){return new RegExp(pattern.source,pattern.flags?pattern.flags:(pattern.global?'g':'')+(pattern.ignoreCase?'i':'')+(pattern.multiline?'m':'')+(pattern.sticky?'y':'')+(pattern.unicode?'u':'')+(pattern.dotAll?'s':''));}\n\n/**\n * Copies an object.\n *\n * @private\n * @param {*} value The value to be copied\n * @param {Boolean} deep Whether or not to perform deep cloning.\n * @return {*} The copied value.\n */function _clone(value,deep,map){map||(map=new _ObjectMap());// this avoids the slower switch with a quick if decision removing some milliseconds in each run.\nif(_isPrimitive(value)){return value;}var copy=function copy(copiedValue){// Check for circular and same references on the object graph and return its corresponding clone.\nvar cachedCopy=map.get(value);if(cachedCopy){return cachedCopy;}map.set(value,copiedValue);for(var key in value){if(Object.prototype.hasOwnProperty.call(value,key)){copiedValue[key]=_clone(value[key],true,map);}}return copiedValue;};switch(type(value)){case 'Object':return copy(Object.create(Object.getPrototypeOf(value)));case 'Array':return copy(Array(value.length));case 'Date':return new Date(value.valueOf());case 'RegExp':return _cloneRegExp(value);case 'Int8Array':case 'Uint8Array':case 'Uint8ClampedArray':case 'Int16Array':case 'Uint16Array':case 'Int32Array':case 'Uint32Array':case 'Float32Array':case 'Float64Array':case 'BigInt64Array':case 'BigUint64Array':return value.slice();default:return value;}}function _isPrimitive(param){var type=typeof param;return param==null||type!='object'&&type!='function';}var _ObjectMap=/*#__PURE__*/function(){function _ObjectMap(){this.map={};this.length=0;}_ObjectMap.prototype.set=function(key,value){var hashedKey=this.hash(key);var bucket=this.map[hashedKey];if(!bucket){this.map[hashedKey]=bucket=[];}bucket.push([key,value]);this.length+=1;};_ObjectMap.prototype.hash=function(key){var hashedKey=[];for(var value in key){hashedKey.push(Object.prototype.toString.call(key[value]));}return hashedKey.join();};_ObjectMap.prototype.get=function(key){/**\n     * depending on the number of objects to be cloned is faster to just iterate over the items in the map just because the hash function is so costly,\n     * on my tests this number is 180, anything above that using the hash function is faster.\n     */if(this.length<=180){for(var p in this.map){var bucket=this.map[p];for(var i=0;i<bucket.length;i+=1){var element=bucket[i];if(element[0]===key){return element[1];}}}return;}var hashedKey=this.hash(key);var bucket=this.map[hashedKey];if(!bucket){return;}for(var i=0;i<bucket.length;i+=1){var element=bucket[i];if(element[0]===key){return element[1];}}};return _ObjectMap;}();\n\n/**\n * Creates a deep copy of the source that can be used in place of the source\n * object without retaining any references to it.\n * The source object may contain (nested) `Array`s and `Object`s,\n * `Number`s, `String`s, `Boolean`s and `Date`s.\n * `Function`s are assigned by reference rather than copied.\n *\n * Dispatches to a `clone` method if present.\n *\n * Note that if the source object has multiple nodes that share a reference,\n * the returned object will have the same structure, but the references will\n * be pointed to the location within the cloned value.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig {*} -> {*}\n * @param {*} value The object or array to clone\n * @return {*} A deeply cloned copy of `val`\n * @example\n *\n *      const objects = [{}, {}, {}];\n *      const objectsClone = R.clone(objects);\n *      objects === objectsClone; //=> false\n *      objects[0] === objectsClone[0]; //=> false\n */var clone=/*#__PURE__*/_curry1(function clone(value){return value!=null&&typeof value.clone==='function'?value.clone():_clone(value);});\n\nfunction _path(pathAr,obj){var val=obj;for(var i=0;i<pathAr.length;i+=1){if(val==null){return undefined;}var p=pathAr[i];if(_isInteger(p)){val=_nth(p,val);}else {val=val[p];}}return val;}\n\n/**\n * Creates a new object with the own properties of the two provided objects. If\n * a key exists in both objects, the provided function is applied to the key\n * and the values associated with the key in each object, with the result being\n * used as the value associated with the key in the returned object.\n *\n * @func\n * @memberOf R\n * @since v0.19.0\n * @category Object\n * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}\n * @param {Function} fn\n * @param {Object} l\n * @param {Object} r\n * @return {Object}\n * @see R.mergeDeepWithKey, R.mergeWith\n * @example\n *\n *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r\n *      R.mergeWithKey(concatValues,\n *                     { a: true, thing: 'foo', values: [10, 20] },\n *                     { b: true, thing: 'bar', values: [15, 35] });\n *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }\n * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }\n */var mergeWithKey=/*#__PURE__*/_curry3(function mergeWithKey(fn,l,r){var result={};var k;l=l||{};r=r||{};for(k in l){if(_has(k,l)){result[k]=_has(k,r)?fn(k,l[k],r[k]):l[k];}}for(k in r){if(_has(k,r)&&!_has(k,result)){result[k]=r[k];}}return result;});\n\n/**\n * Creates a new object with the own properties of the two provided objects.\n * If a key exists in both objects:\n * - and both associated values are also objects then the values will be\n *   recursively merged.\n * - otherwise the provided function is applied to the key and associated values\n *   using the resulting value as the new value associated with the key.\n * If a key only exists in one object, the value will be associated with the key\n * of the resulting object.\n *\n * @func\n * @memberOf R\n * @since v0.24.0\n * @category Object\n * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}\n * @param {Function} fn\n * @param {Object} lObj\n * @param {Object} rObj\n * @return {Object}\n * @see R.mergeWithKey, R.mergeDeepWith\n * @example\n *\n *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r\n *      R.mergeDeepWithKey(concatValues,\n *                         { a: true, c: { thing: 'foo', values: [10, 20] }},\n *                         { b: true, c: { thing: 'bar', values: [15, 35] }});\n *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}\n */var mergeDeepWithKey=/*#__PURE__*/_curry3(function mergeDeepWithKey(fn,lObj,rObj){return mergeWithKey(function(k,lVal,rVal){if(_isObject(lVal)&&_isObject(rVal)){return mergeDeepWithKey(fn,lVal,rVal);}else {return fn(k,lVal,rVal);}},lObj,rObj);});\n\n/**\n * Creates a new object with the own properties of the two provided objects.\n * If a key exists in both objects:\n * - and both associated values are also objects then the values will be\n *   recursively merged.\n * - otherwise the provided function is applied to associated values using the\n *   resulting value as the new value associated with the key.\n * If a key only exists in one object, the value will be associated with the key\n * of the resulting object.\n *\n * @func\n * @memberOf R\n * @since v0.24.0\n * @category Object\n * @sig ((a, a) -> a) -> {a} -> {a} -> {a}\n * @param {Function} fn\n * @param {Object} lObj\n * @param {Object} rObj\n * @return {Object}\n * @see R.mergeWith, R.mergeDeepWithKey\n * @example\n *\n *      R.mergeDeepWith(R.concat,\n *                      { a: true, c: { values: [10, 20] }},\n *                      { b: true, c: { values: [15, 35] }});\n *      //=> { a: true, b: true, c: { values: [10, 20, 15, 35] }}\n */var mergeDeepWith=/*#__PURE__*/_curry3(function mergeDeepWith(fn,lObj,rObj){return mergeDeepWithKey(function(k,lVal,rVal){return fn(lVal,rVal);},lObj,rObj);});\n\n/**\n * Retrieves the value at a given path. The nodes of the path can be arbitrary strings or non-negative integers.\n * For anything else, the value is unspecified. Integer paths are meant to index arrays, strings are meant for objects.\n *\n * @func\n * @memberOf R\n * @since v0.2.0\n * @category Object\n * @typedefn Idx = String | Int | Symbol\n * @sig [Idx] -> {a} -> a | Undefined\n * @sig Idx = String | NonNegativeInt\n * @param {Array} path The path to use.\n * @param {Object} obj The object or array to retrieve the nested property from.\n * @return {*} The data at `path`.\n * @see R.prop, R.nth, R.assocPath, R.dissocPath\n * @example\n *\n *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2\n *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined\n *      R.path(['a', 'b', 0], {a: {b: [1, 2, 3]}}); //=> 1\n *      R.path(['a', 'b', -2], {a: {b: [1, 2, 3]}}); //=> 2\n *      R.path([2], {'2': 2}); //=> 2\n *      R.path([-2], {'-2': 'a'}); //=> undefined\n */var path=/*#__PURE__*/_curry2(_path);\n\n/**\n * Returns a partial copy of an object containing only the keys that satisfy\n * the supplied predicate.\n *\n * @func\n * @memberOf R\n * @since v0.8.0\n * @category Object\n * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}\n * @param {Function} pred A predicate to determine whether or not a key\n *        should be included on the output object.\n * @param {Object} obj The object to copy from\n * @return {Object} A new object with only properties that satisfy `pred`\n *         on it.\n * @see R.pick, R.filter\n * @example\n *\n *      const isUpperCase = (val, key) => key.toUpperCase() === key;\n *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}\n */var pickBy=/*#__PURE__*/_curry2(function pickBy(test,obj){var result={};for(var prop in obj){if(test(obj[prop],prop,obj)){result[prop]=obj[prop];}}return result;});\n\n/**\n * A function to check given value is a function\n * @param value input value\n * @returns boolean\n */const isFunction=value=>typeof value==='function'&&Boolean(value.constructor&&value.call&&value.apply);/**\n * A function to check given value is a string\n * @param value input value\n * @returns boolean\n */const isString=value=>typeof value==='string';/**\n * A function to check given value is null or not\n * @param value input value\n * @returns boolean\n */const isNull=value=>value===null;/**\n * A function to check given value is undefined\n * @param value input value\n * @returns boolean\n */const isUndefined=value=>typeof value==='undefined';/**\n * A function to check given value is null or undefined\n * @param value input value\n * @returns boolean\n */const isNullOrUndefined=value=>isNull(value)||isUndefined(value);/**\n * Checks if the input is a BigInt\n * @param value input value\n * @returns True if the input is a BigInt\n */const isBigInt=value=>typeof value==='bigint';/**\n * A function to check given value is defined\n * @param value input value\n * @returns boolean\n */const isDefined=value=>!isUndefined(value);/**\n * A function to check given value is defined and not null\n * @param value input value\n * @returns boolean\n */const isDefinedAndNotNull=value=>!isNullOrUndefined(value);/**\n * A function to check given value is defined and not null\n * @param value input value\n * @returns boolean\n */const isDefinedNotNullAndNotEmptyString=value=>isDefinedAndNotNull(value)&&value!=='';/**\n * Determines if the input is of type error\n * @param value input value\n * @returns true if the input is of type error else false\n */const isTypeOfError=value=>{switch(Object.prototype.toString.call(value)){case '[object Error]':case '[object Exception]':case '[object DOMException]':return true;default:return value instanceof Error;}};/**\n * A function to check given value is a boolean\n * @param value input value\n * @returns boolean\n */const isBoolean=value=>typeof value==='boolean';\n\nconst getValueByPath=(obj,keyPath)=>{const pathParts=keyPath.split('.');return path(pathParts,obj);};const hasValueByPath=(obj,path)=>Boolean(getValueByPath(obj,path));const isObject=value=>typeof value==='object';/**\n * Checks if the input is an object literal or built-in object type and not null\n * @param value Input value\n * @returns true if the input is an object and not null\n */const isObjectAndNotNull=value=>!isNull(value)&&isObject(value)&&!Array.isArray(value);/**\n * Checks if the input is an object literal and not null\n * @param value Input value\n * @returns true if the input is an object and not null\n */const isObjectLiteralAndNotNull=value=>!isNull(value)&&Object.prototype.toString.call(value)==='[object Object]';/**\n * Merges two arrays deeply, right-to-left\n * In the case of conflicts, the right array's values replace the left array's values in the\n * same index position\n * @param leftValue - The left array\n * @param rightValue - The right array\n * @returns The merged array\n */const mergeDeepRightObjectArrays=(leftValue,rightValue)=>{if(!Array.isArray(leftValue)||!Array.isArray(rightValue)){return clone(rightValue);}const mergedArray=clone(leftValue);rightValue.forEach((value,index)=>{mergedArray[index]=Array.isArray(value)||isObjectAndNotNull(value)?// eslint-disable-next-line @typescript-eslint/no-use-before-define\nmergeDeepRight(mergedArray[index],value):value;});return mergedArray;};/**\n * Merges two objects deeply, right-to-left.\n * In the case of conflicts, the right object's values take precedence.\n * For arrays, the right array's values replace the left array's values in the\n * same index position keeping the remaining left array's values in the resultant array.\n * @param leftObject - The left object\n * @param rightObject - The right object\n * @returns The merged object\n */const mergeDeepRight=(leftObject,rightObject)=>mergeDeepWith(mergeDeepRightObjectArrays,leftObject,rightObject);/**\n Checks if the input is a non-empty object literal type and not undefined or null\n * @param value input any\n * @returns boolean\n */const isNonEmptyObject=value=>isObjectLiteralAndNotNull(value)&&Object.keys(value).length>0;/**\n * A utility to recursively remove undefined values from an object\n * @param obj input object\n * @returns a new object\n */const removeUndefinedValues=obj=>{const result=pickBy(isDefined,obj);Object.keys(result).forEach(key=>{const value=result[key];if(isObjectLiteralAndNotNull(value)){result[key]=removeUndefinedValues(value);}});return result;};/**\n * A utility to recursively remove undefined and null values from an object\n * @param obj input object\n * @returns a new object\n */const removeUndefinedAndNullValues=obj=>{const result=pickBy(isDefinedAndNotNull,obj);Object.keys(result).forEach(key=>{const value=result[key];if(isObjectLiteralAndNotNull(value)){result[key]=removeUndefinedAndNullValues(value);}});return result;};/**\n * Normalizes an object by removing undefined and null values.\n * @param val - The value to normalize\n * @returns The normalized object, or undefined if input is not a non-empty object\n * @example\n * getNormalizedObjectValue({ a: 1, b: null, c: undefined }) // returns { a: 1 }\n * getNormalizedObjectValue({}) // returns undefined\n * getNormalizedObjectValue(null) // returns undefined\n */const getNormalizedObjectValue=val=>{if(!isNonEmptyObject(val)){return undefined;}return removeUndefinedAndNullValues(val);};/**\n * Normalizes a value to a boolean, with support for a default value\n * @param val Input value\n * @param defVal Default value\n * @returns Returns the input value if it is a boolean, otherwise returns the default value\n * @example\n * getNormalizedBooleanValue(true, false) // returns true\n */const getNormalizedBooleanValue=(val,defVal)=>typeof val==='boolean'?val:defVal;const deepFreeze=obj=>{Object.getOwnPropertyNames(obj).forEach(function(prop){if(obj[prop]&&typeof obj[prop]==='object'){deepFreeze(obj[prop]);}});return Object.freeze(obj);};\n\nconst trim=value=>value.replace(/^\\s+|\\s+$/gm,'');const removeLeadingPeriod=value=>value.replace(/^\\.+/,'');/**\n * A function to convert values to string\n * @param val input value\n * @returns stringified value\n */const tryStringify=val=>{let retVal=val;if(!isString(val)&&!isNullOrUndefined(val)){try{retVal=JSON.stringify(val);}catch(e){retVal=null;}}return retVal;};// The following text encoding and decoding is done before base64 encoding to prevent\n/**\n * Converts a bytes array to base64 encoded string\n * @param bytes bytes array to be converted to base64\n * @returns base64 encoded string\n */const bytesToBase64=bytes=>{const binString=Array.from(bytes,x=>String.fromCodePoint(x)).join('');return globalThis.btoa(binString);};/**\n * Encodes a string to base64 even with unicode characters\n * @param value input string\n * @returns base64 encoded string\n */const toBase64=value=>bytesToBase64(new TextEncoder().encode(value));\n\n//   if yes make them null instead of omitting in overloaded cases\n/*\n * Normalise the overloaded arguments of the page call facade\n */const pageArgumentsToCallOptions=(category,name,properties,options,callback)=>{const payload={category:category,name:name,properties:properties,options:options,callback:undefined};if(isFunction(callback)){payload.callback=callback;}if(isFunction(options)){payload.category=category;payload.name=name;payload.properties=properties;payload.options=undefined;payload.callback=options;}if(isFunction(properties)){payload.category=category;payload.name=name;payload.properties=undefined;payload.options=undefined;payload.callback=properties;}if(isFunction(name)){payload.category=category;payload.name=undefined;payload.properties=undefined;payload.options=undefined;payload.callback=name;}if(isFunction(category)){payload.category=undefined;payload.name=undefined;payload.properties=undefined;payload.options=undefined;payload.callback=category;}if(isObjectLiteralAndNotNull(category)){payload.name=undefined;payload.category=undefined;payload.properties=category;if(!isFunction(name)){payload.options=name;}else {payload.options=undefined;}}else if(isObjectLiteralAndNotNull(name)){payload.name=undefined;payload.properties=name;if(!isFunction(properties)){payload.options=properties;}else {payload.options=undefined;}}// if the category argument alone is provided b/w category and name,\n// use it as name and set category to undefined\nif(isString(category)&&!isString(name)){payload.category=undefined;payload.name=category;}// Rest of the code is just to clean up undefined values\n// and set some proper defaults\n// Also, to clone the incoming object type arguments\nif(!isDefined(payload.category)){payload.category=undefined;}if(!isDefined(payload.name)){payload.name=undefined;}payload.properties=payload.properties?clone(payload.properties):{};if(isDefined(payload.options)){payload.options=clone(payload.options);}else {payload.options=undefined;}const nameForProperties=isString(payload.name)?payload.name:payload.properties.name;const categoryForProperties=isString(payload.category)?payload.category:payload.properties.category;// add name and category to properties\npayload.properties=mergeDeepRight(isObjectLiteralAndNotNull(payload.properties)?payload.properties:{},{...(nameForProperties&&{name:nameForProperties}),...(categoryForProperties&&{category:categoryForProperties})});return payload;};/*\n * Normalise the overloaded arguments of the track call facade\n */const trackArgumentsToCallOptions=(event,properties,options,callback)=>{const payload={name:event,properties:properties,options:options,callback:undefined};if(isFunction(callback)){payload.callback=callback;}if(isFunction(options)){payload.properties=properties;payload.options=undefined;payload.callback=options;}if(isFunction(properties)){payload.properties=undefined;payload.options=undefined;payload.callback=properties;}// Rest of the code is just to clean up undefined values\n// and set some proper defaults\n// Also, to clone the incoming object type arguments\npayload.properties=isDefinedAndNotNull(payload.properties)?clone(payload.properties):{};if(isDefined(payload.options)){payload.options=clone(payload.options);}else {payload.options=undefined;}return payload;};/*\n * Normalise the overloaded arguments of the identify call facade\n */const identifyArgumentsToCallOptions=(userId,traits,options,callback)=>{const payload={userId:userId,traits:traits,options:options,callback:undefined};if(isFunction(callback)){payload.callback=callback;}if(isFunction(options)){payload.userId=userId;payload.traits=traits;payload.options=undefined;payload.callback=options;}if(isFunction(traits)){payload.userId=userId;payload.traits=undefined;payload.options=undefined;payload.callback=traits;}if(isObjectLiteralAndNotNull(userId)||isNull(userId)){// Explicitly set null to prevent resetting the existing value\n// in the Analytics class\npayload.userId=null;payload.traits=userId;if(!isFunction(traits)){payload.options=traits;}else {payload.options=undefined;}}// Rest of the code is just to clean up undefined values\n// and set some proper defaults\n// Also, to clone the incoming object type arguments\npayload.userId=tryStringify(payload.userId);if(isObjectLiteralAndNotNull(payload.traits)){payload.traits=clone(payload.traits);}else {payload.traits=undefined;}if(isDefined(payload.options)){payload.options=clone(payload.options);}else {payload.options=undefined;}return payload;};/*\n * Normalise the overloaded arguments of the alias call facade\n */const aliasArgumentsToCallOptions=(to,from,options,callback)=>{const payload={to,from:from,options:options,callback:undefined};if(isFunction(callback)){payload.callback=callback;}if(isFunction(options)){payload.to=to;payload.from=from;payload.options=undefined;payload.callback=options;}if(isFunction(from)){payload.to=to;payload.from=undefined;payload.options=undefined;payload.callback=from;}else if(isObjectLiteralAndNotNull(from)||isNull(from)){payload.to=to;payload.from=undefined;payload.options=from;}// Rest of the code is just to clean up undefined values\n// and set some proper defaults\n// Also, to clone the incoming object type arguments\nif(isDefined(payload.to)){payload.to=tryStringify(payload.to);}if(isDefined(payload.from)){payload.from=tryStringify(payload.from);}else {payload.from=undefined;}if(isDefined(payload.options)){payload.options=clone(payload.options);}else {payload.options=undefined;}return payload;};/*\n * Normalise the overloaded arguments of the group call facade\n */const groupArgumentsToCallOptions=(groupId,traits,options,callback)=>{const payload={groupId:groupId,traits:traits,options:options,callback:undefined};if(isFunction(callback)){payload.callback=callback;}if(isFunction(options)){payload.groupId=groupId;payload.traits=traits;payload.options=undefined;payload.callback=options;}if(isFunction(traits)){payload.groupId=groupId;payload.traits=undefined;payload.options=undefined;payload.callback=traits;}if(isObjectLiteralAndNotNull(groupId)||isNull(groupId)){// Explicitly set null to prevent resetting the existing value\n// in the Analytics class\npayload.groupId=null;payload.traits=groupId;if(!isFunction(traits)){payload.options=traits;}else {payload.options=undefined;}}// Rest of the code is just to clean up undefined values\n// and set some proper defaults\n// Also, to clone the incoming object type arguments\npayload.groupId=tryStringify(payload.groupId);if(isObjectLiteralAndNotNull(payload.traits)){payload.traits=clone(payload.traits);}else {payload.traits=undefined;}if(isDefined(payload.options)){payload.options=clone(payload.options);}else {payload.options=undefined;}return payload;};\n\n/**\n * Represents the options parameter for anonymousId\n *//**\n * Represents the beacon queue options parameter in loadOptions type\n *//**\n * Represents the queue options parameter in loadOptions type\n *//**\n * Represents the destinations queue options parameter in loadOptions type\n */let PageLifecycleEvents=/*#__PURE__*/function(PageLifecycleEvents){PageLifecycleEvents[\"UNLOADED\"]=\"Page Unloaded\";return PageLifecycleEvents;}({});/**\n * Represents the source configuration override options for destinations\n *//**\n * Represents the options parameter in the load API\n */\n\nconst API_SUFFIX='API';const CAPABILITIES_MANAGER='CapabilitiesManager';const CONFIG_MANAGER='ConfigManager';const EVENT_MANAGER='EventManager';const PLUGINS_MANAGER='PluginsManager';const USER_SESSION_MANAGER='UserSessionManager';const ERROR_HANDLER='ErrorHandler';const PLUGIN_ENGINE='PluginEngine';const STORE_MANAGER='StoreManager';const READY_API=`Ready${API_SUFFIX}`;const LOAD_API=`Load${API_SUFFIX}`;const HTTP_CLIENT='HttpClient';const RSA='RudderStackAnalytics';const ANALYTICS_CORE='AnalyticsCore';\n\nfunction random(len){return crypto.getRandomValues(new Uint8Array(len));}\n\nvar SIZE=4096,HEX$1=[],IDX$1=0,BUFFER$1;for(;IDX$1<256;IDX$1++){HEX$1[IDX$1]=(IDX$1+256).toString(16).substring(1);}function v4$1(){if(!BUFFER$1||IDX$1+16>SIZE){BUFFER$1=random(SIZE);IDX$1=0;}var i=0,tmp,out='';for(;i<16;i++){tmp=BUFFER$1[IDX$1+i];if(i==6)out+=HEX$1[tmp&15|64];else if(i==8)out+=HEX$1[tmp&63|128];else out+=HEX$1[tmp];if(i&1&&i>1&&i<11)out+='-';}IDX$1+=16;return out;}\n\nvar IDX=256,HEX=[],BUFFER;while(IDX--)HEX[IDX]=(IDX+256).toString(16).substring(1);function v4(){var i=0,num,out='';if(!BUFFER||IDX+16>256){BUFFER=Array(i=256);while(i--)BUFFER[i]=256*Math.random()|0;i=IDX=0;}for(;i<16;i++){num=BUFFER[IDX+i];if(i==6)out+=HEX[num&15|64];else if(i==8)out+=HEX[num&63|128];else out+=HEX[num];if(i&1&&i>1&&i<11)out+='-';}IDX++;return out;}\n\nconst hasCrypto$1=()=>!isNullOrUndefined(globalThis.crypto)&&isFunction(globalThis.crypto.getRandomValues);\n\nconst generateUUID=()=>{if(hasCrypto$1()){return v4$1();}return v4();};\n\n/**\n * Determines if the SDK is running inside a chrome extension\n * @returns boolean\n */const isSDKRunningInChromeExtension=()=>!!window.chrome?.runtime?.id;const isIE11=()=>isString(globalThis.navigator.userAgent)&&/Trident.*rv:11\\./.test(globalThis.navigator.userAgent);\n\n/**\n * Registers events to detect page leave scenarios\n * @param callback Callback function\n * @param avoidBfCacheOptimization When `true`, forcefully subscribes to beforeunload event, compromising on the bfcache optimization\n */const onPageLeave=(callback,avoidBfCacheOptimization=false)=>{// To ensure the callback is only called once even if more than one events\n// are fired at once.\nlet pageLeft=false;let isAccessible=false;function handleOnLeave(){if(pageLeft){return;}pageLeft=true;callback(isAccessible);// Reset pageLeft on the next tick\n// to ensure callback executes for other listeners\n// when closing an inactive browser tab.\nsetTimeout(()=>{pageLeft=false;},0);}// Catches the unloading of the page (e.g., closing the tab or navigating away).\n// Includes user actions like clicking a link, entering a new URL,\n// refreshing the page, or closing the browser tab\n// Note that 'pagehide' is not supported in IE.\n// Registering this event conditionally for IE11 also because\n// it affects bfcache optimization on modern browsers otherwise.\n// However, if optimization is disabled, force subscribe the event\nif(avoidBfCacheOptimization||isIE11()){globalThis.addEventListener('beforeunload',()=>{isAccessible=false;handleOnLeave();});}// This is important for iOS Safari browser as it does not\n// fire the regular pagehide and visibilitychange events\n// when user goes to tablist view and closes the tab.\nglobalThis.addEventListener('blur',()=>{isAccessible=true;handleOnLeave();});globalThis.addEventListener('focus',()=>{pageLeft=false;});// Catches the page being hidden, including scenarios like closing the tab.\ndocument.addEventListener('pagehide',()=>{isAccessible=document.visibilityState==='hidden';handleOnLeave();});// Catches visibility changes, such as switching tabs or minimizing the browser.\ndocument.addEventListener('visibilitychange',()=>{isAccessible=true;if(document.visibilityState==='hidden'){handleOnLeave();}else {pageLeft=false;}});};\n\nconst getFormattedTimestamp=date=>date.toISOString();/**\n * To get the current timestamp in ISO string format\n * @returns ISO formatted timestamp string\n */const getCurrentTimeFormatted=()=>getFormattedTimestamp(new Date());\n\nconst LOG_CONTEXT_SEPARATOR=':: ';const SCRIPT_ALREADY_EXISTS_ERROR=id=>`A script with the id \"${id}\" is already loaded. Skipping the loading of this script to prevent conflicts`;const SCRIPT_LOAD_ERROR=(id,url,ev)=>`Unable to load (${isString(ev)?ev:ev.type}) the script with the id \"${id}\" from URL \"${url}\"`;const SCRIPT_LOAD_TIMEOUT_ERROR=(id,url,timeout)=>`A timeout of ${timeout} ms occurred while trying to load the script with id \"${id}\" from URL \"${url}\"`;const CIRCULAR_REFERENCE_WARNING=(context,key)=>`${context}${LOG_CONTEXT_SEPARATOR}A circular reference has been detected in the object and the property \"${key}\" has been dropped from the output.`;const JSON_STRINGIFY_WARNING=`Failed to convert the value to a JSON string.`;const COOKIE_DATA_ENCODING_ERROR=`Failed to encode the cookie data.`;const STORAGE_UNAVAILABILITY_ERROR_PREFIX=(context,storageType)=>`${context}${LOG_CONTEXT_SEPARATOR}The \"${storageType}\" storage type is `;\n\nconst JSON_STRINGIFY='JSONStringify';const BIG_INT_PLACEHOLDER='[BigInt]';const CIRCULAR_REFERENCE_PLACEHOLDER='[Circular Reference]';const getCircularReplacer=(excludeNull,excludeKeys,logger)=>{const ancestors=[];// Here we do not want to use arrow function to use \"this\" in function context\n// eslint-disable-next-line func-names\nreturn function(key,value){if(excludeKeys?.includes(key)){return undefined;}if(excludeNull&&isNullOrUndefined(value)){return undefined;}if(typeof value!=='object'||isNull(value)){return value;}// `this` is the object that value is contained in, i.e., its direct parent.\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore-next-line\nwhile(ancestors.length>0&&ancestors[ancestors.length-1]!==this){ancestors.pop();}if(ancestors.includes(value)){logger?.warn(CIRCULAR_REFERENCE_WARNING(JSON_STRINGIFY,key));return CIRCULAR_REFERENCE_PLACEHOLDER;}ancestors.push(value);return value;};};/**\n * Utility method for JSON stringify object excluding null values & circular references\n *\n * @param {*} value input\n * @param {boolean} excludeNull if it should exclude nul or not\n * @param {function} logger optional logger methods for warning\n * @returns string\n */const stringifyWithoutCircular=(value,excludeNull,excludeKeys,logger)=>{try{return JSON.stringify(value,getCircularReplacer(excludeNull,excludeKeys,logger));}catch(err){logger?.warn(JSON_STRINGIFY_WARNING,err);return null;}};const getReplacer=logger=>{const ancestors=[];// Array to track ancestor objects\n// Using a regular function to use `this` for the parent context\nreturn function replacer(key,value){if(isBigInt(value)){return BIG_INT_PLACEHOLDER;// Replace BigInt values\n}// `this` is the object that value is contained in, i.e., its direct parent.\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore-next-line\nwhile(ancestors.length>0&&ancestors[ancestors.length-1]!==this){ancestors.pop();// Remove ancestors that are no longer part of the chain\n}// Check for circular references (if the value is already in the ancestors)\nif(ancestors.includes(value)){return CIRCULAR_REFERENCE_PLACEHOLDER;}// Add current value to ancestors\nancestors.push(value);return value;};};const traverseWithThis=(obj,replacer)=>{// Create a new result object or array\nconst result=Array.isArray(obj)?[]:{};// Traverse object properties or array elements\n// eslint-disable-next-line no-restricted-syntax\nfor(const key in obj){if(Object.hasOwnProperty.call(obj,key)){const value=obj[key];// Recursively apply the replacer and traversal\nconst sanitizedValue=replacer.call(obj,key,value);// If the value is an object or array, continue traversal\nif(isObjectLiteralAndNotNull(sanitizedValue)||Array.isArray(sanitizedValue)){result[key]=traverseWithThis(sanitizedValue,replacer);}else {result[key]=sanitizedValue;}}}return result;};/**\n * Recursively traverses an object similar to JSON.stringify,\n * sanitizing BigInts and circular references\n * @param value Input object\n * @param logger Logger instance\n * @returns Sanitized value\n */const getSanitizedValue=(value,logger)=>{const replacer=getReplacer();// This is needed for registering the first ancestor\nconst newValue=replacer.call(value,'',value);if(isObjectLiteralAndNotNull(value)||Array.isArray(value)){return traverseWithThis(value,replacer);}return newValue;};\n\nconst MANUAL_ERROR_IDENTIFIER='[SDK DISPATCHED ERROR]';const getStacktrace=err=>{const{stack,stacktrace,'opera#sourceloc':operaSourceloc}=err;const stackString=stack??stacktrace??operaSourceloc;if(!!stackString&&typeof stackString==='string'){return stackString;}return undefined;};/**\n * Get mutated error with issue prepended to error message\n * @param err Original error\n * @param issue Issue to prepend to error message\n * @returns Instance of Error with message prepended with issue\n */const getMutatedError=(err,issue)=>{if(!isTypeOfError(err)){return new Error(`${issue}: ${stringifyWithoutCircular(err)}`);}try{// Preserve the specific error type (TypeError, ReferenceError, etc.)\nconst ErrorConstructor=err.constructor;const newError=new ErrorConstructor(`${issue}: ${err.message}`);// Preserve stack trace\nconst stack=getStacktrace(err);if(stack){newError.stack=stack;}// Preserve any other enumerable properties\nObject.getOwnPropertyNames(err).forEach(key=>{if(key!=='message'&&key!=='stack'&&key!=='name'){try{newError[key]=err[key];}catch{// Ignore if property is not writable\n}}});return newError;}catch{return new Error(`${issue}: ${stringifyWithoutCircular(err)}`);}};const dispatchErrorEvent=error=>{if(isTypeOfError(error)){const errStack=getStacktrace(error);if(errStack){const{stack,stacktrace,'opera#sourceloc':operaSourceloc}=error;switch(errStack){case stack:// eslint-disable-next-line no-param-reassign\nerror.stack=`${stack}\\n${MANUAL_ERROR_IDENTIFIER}`;break;case stacktrace:// eslint-disable-next-line no-param-reassign\nerror.stacktrace=`${stacktrace}\\n${MANUAL_ERROR_IDENTIFIER}`;break;case operaSourceloc:default:// eslint-disable-next-line no-param-reassign\nerror['opera#sourceloc']=`${operaSourceloc}\\n${MANUAL_ERROR_IDENTIFIER}`;break;}}}globalThis.dispatchEvent(new ErrorEvent('error',{error,bubbles:true,cancelable:true,composed:true}));};\n\nconst APP_NAME='RudderLabs JavaScript SDK';const APP_VERSION='3.27.0';const APP_NAMESPACE='com.rudderlabs.javascript';const MODULE_TYPE='npm';const ADBLOCK_PAGE_CATEGORY='RudderJS-Initiated';const ADBLOCK_PAGE_NAME='ad-block page request';const ADBLOCK_PAGE_PATH='/ad-blocked';const GLOBAL_PRELOAD_BUFFER='preloadedEventsBuffer';const CONSENT_TRACK_EVENT_NAME='Consent Management Interaction';\n\nconst QUERY_PARAM_TRAIT_PREFIX='ajs_trait_';const QUERY_PARAM_PROPERTY_PREFIX='ajs_prop_';const QUERY_PARAM_ANONYMOUS_ID_KEY='ajs_aid';const QUERY_PARAM_USER_ID_KEY='ajs_uid';const QUERY_PARAM_TRACK_EVENT_NAME_KEY='ajs_event';\n\nconst DEFAULT_XHR_TIMEOUT_MS=10*1000;// 10 seconds\nconst DEFAULT_COOKIE_MAX_AGE_MS=31536000*1000;// 1 year\nconst DEFAULT_SESSION_CUT_OFF_DURATION_MS=12*60*60*1000;// 12 hours\nconst DEFAULT_SESSION_TIMEOUT_MS=30*60*1000;// 30 minutes\nconst MIN_SESSION_TIMEOUT_MS=10*1000;// 10 seconds\nconst DEFAULT_DATA_PLANE_EVENTS_BUFFER_TIMEOUT_MS=10*1000;// 10 seconds\nconst DEBOUNCED_TIMEOUT_MS=250;// 250 milliseconds\n\n/**\n * Create globally accessible RudderStackGlobals object\n */const createExposedGlobals=(analyticsInstanceId='app')=>{if(!globalThis.RudderStackGlobals){globalThis.RudderStackGlobals={};}if(!globalThis.RudderStackGlobals[analyticsInstanceId]){globalThis.RudderStackGlobals[analyticsInstanceId]={};}};/**\n * Add move values to globally accessible RudderStackGlobals object per analytics instance\n */const setExposedGlobal=(keyName,value,analyticsInstanceId='app')=>{createExposedGlobals(analyticsInstanceId);globalThis.RudderStackGlobals[analyticsInstanceId][keyName]=value;};/**\n * Get values from globally accessible RudderStackGlobals object by analytics instance\n */const getExposedGlobal=(keyName,analyticsInstanceId='app')=>{createExposedGlobals(analyticsInstanceId);return globalThis.RudderStackGlobals[analyticsInstanceId][keyName];};function debounce(func,thisArg,delay=DEBOUNCED_TIMEOUT_MS){let timeoutId;return (...args)=>{globalThis.clearTimeout(timeoutId);timeoutId=globalThis.setTimeout(()=>{func.apply(thisArg,args);},delay);};}\n\n/**\n * Parse query string params into object values for keys that start with a defined prefix\n */const getEventDataFromQueryString=(params,dataTypeNamePrefix)=>{const data={};params.forEach((value,key)=>{if(key.startsWith(dataTypeNamePrefix)){// remove prefix from key name\nconst dataKey=key.substring(dataTypeNamePrefix.length);// add new key value pair in generated object\ndata[dataKey]=params.get(key);}});return data;};/**\n * Parse query string into preload buffer events & push into existing array before any other events\n */const retrieveEventsFromQueryString=(argumentsArray=[])=>{// Mapping for trait and properties values based on key prefix\nconst eventArgumentToQueryParamMap={trait:QUERY_PARAM_TRAIT_PREFIX,properties:QUERY_PARAM_PROPERTY_PREFIX};const queryObject=new URLSearchParams(globalThis.location.search);// Add track events with name and properties\nif(queryObject.get(QUERY_PARAM_TRACK_EVENT_NAME_KEY)){argumentsArray.unshift(['track',queryObject.get(QUERY_PARAM_TRACK_EVENT_NAME_KEY),getEventDataFromQueryString(queryObject,eventArgumentToQueryParamMap.properties)]);}// Send identify event\nconst userId=queryObject.get(QUERY_PARAM_USER_ID_KEY);const userTraits=getEventDataFromQueryString(queryObject,eventArgumentToQueryParamMap.trait);if(userId||isNonEmptyObject(userTraits)){// In identify API, user ID is optional\nconst identifyApiArgs=[...(userId?[userId]:[]),userTraits];argumentsArray.unshift(['identify',...identifyApiArgs]);}// Set anonymousID\nif(queryObject.get(QUERY_PARAM_ANONYMOUS_ID_KEY)){argumentsArray.unshift(['setAnonymousId',queryObject.get(QUERY_PARAM_ANONYMOUS_ID_KEY)]);}};/**\n * Retrieve an existing buffered load method call and remove from the existing array\n */const getPreloadedLoadEvent=preloadedEventsArray=>{const loadMethodName='load';let loadEvent=[];/**\n   * Iterate the buffered API calls until we find load call and process it separately\n   */let i=0;while(i<preloadedEventsArray.length){if(preloadedEventsArray[i]&&preloadedEventsArray[i][0]===loadMethodName){loadEvent=clone(preloadedEventsArray[i]);preloadedEventsArray.splice(i,1);break;}i+=1;}return loadEvent;};/**\n * Promote consent events to the top of the preloaded events array\n * @param preloadedEventsArray Preloaded events array\n * @returns None\n */const promotePreloadedConsentEventsToTop=preloadedEventsArray=>{const consentMethodName='consent';const consentEvents=preloadedEventsArray.filter(bufferedEvent=>bufferedEvent[0]===consentMethodName);const nonConsentEvents=preloadedEventsArray.filter(bufferedEvent=>bufferedEvent[0]!==consentMethodName);// Remove all elements and add consent events first followed by non consent events\n// eslint-disable-next-line unicorn/no-useless-spread\npreloadedEventsArray.splice(0,preloadedEventsArray.length,...consentEvents,...nonConsentEvents);};/**\n * Retrieve any existing events that were triggered before SDK load and enqueue in buffer\n */const retrievePreloadBufferEvents=instance=>{const preloadedEventsArray=getExposedGlobal(GLOBAL_PRELOAD_BUFFER)||[];// Get events that are pre-populated via query string params\nretrieveEventsFromQueryString(preloadedEventsArray);// Enqueue the non load events in the buffer of the global rudder analytics singleton\nif(preloadedEventsArray.length>0){instance.enqueuePreloadBufferEvents(preloadedEventsArray);setExposedGlobal(GLOBAL_PRELOAD_BUFFER,[]);}};const consumePreloadBufferedEvent=(event,analyticsInstance)=>{const methodName=event.shift();let callOptions;if(isFunction(analyticsInstance[methodName])){switch(methodName){case 'page':callOptions=pageArgumentsToCallOptions(...event);break;case 'track':callOptions=trackArgumentsToCallOptions(...event);break;case 'identify':callOptions=identifyArgumentsToCallOptions(...event);break;case 'alias':callOptions=aliasArgumentsToCallOptions(...event);break;case 'group':callOptions=groupArgumentsToCallOptions(...event);break;default:analyticsInstance[methodName](...event);break;}if(callOptions){analyticsInstance[methodName](callOptions);}}};\n\nconst DEFAULT_EXT_SRC_LOAD_TIMEOUT_MS=10*1000;// 10 seconds\n\nconst EXTERNAL_SOURCE_LOAD_ORIGIN='RS_JS_SDK';\n\n/**\n * Create the DOM element to load a script marked as RS SDK originated\n *\n * @param {*} url The URL of the script to be loaded\n * @param {*} id ID for the script tag\n * @param {*} async Whether to load the script in async mode. Defaults to `true` [optional]\n * @param {*} onload callback to invoke onload [optional]\n * @param {*} onerror callback to invoke onerror [optional]\n * @param {*} extraAttributes key/value pair with html attributes to add in html tag [optional]\n *\n * @returns HTMLScriptElement\n */const createScriptElement=(url,id,async=true,onload=null,onerror=null,extraAttributes={})=>{const scriptElement=document.createElement('script');scriptElement.type='text/javascript';scriptElement.onload=onload;scriptElement.onerror=onerror;scriptElement.src=url;scriptElement.id=id;scriptElement.async=async;Object.keys(extraAttributes).forEach(attributeName=>{scriptElement.setAttribute(attributeName,extraAttributes[attributeName]);});scriptElement.setAttribute('data-loader',EXTERNAL_SOURCE_LOAD_ORIGIN);return scriptElement;};/**\n * Add script DOM element to DOM\n *\n * @param {*} newScriptElement the script element to add\n *\n * @returns\n */const insertScript=newScriptElement=>{// First try to add it to the head\nconst headElements=document.getElementsByTagName('head');if(headElements.length>0){headElements[0]?.insertBefore(newScriptElement,headElements[0]?.firstChild);return;}// Else wise add it before the first script tag\nconst scriptElements=document.getElementsByTagName('script');if(scriptElements.length>0&&scriptElements[0]?.parentNode){scriptElements[0]?.parentNode.insertBefore(newScriptElement,scriptElements[0]);return;}// Create a new head element and add the script as fallback\nconst headElement=document.createElement('head');headElement.appendChild(newScriptElement);const htmlElement=document.getElementsByTagName('html')[0];htmlElement?.insertBefore(headElement,htmlElement.firstChild);};/**\n * Loads external js file as a script html tag\n *\n * @param {*} url The URL of the script to be loaded\n * @param {*} id ID for the script tag\n * @param {*} timeout loading timeout\n * @param {*} async Whether to load the script in async mode. Defaults to `true` [optional]\n * @param {*} extraAttributes key/value pair with html attributes to add in html tag [optional]\n *\n * @returns\n */const jsFileLoader=(url,id,timeout,async=true,extraAttributes)=>new Promise((resolve,reject)=>{const scriptExists=document.getElementById(id);if(scriptExists){reject(new Error(SCRIPT_ALREADY_EXISTS_ERROR(id)));}try{let timeoutID;const onload=()=>{globalThis.clearTimeout(timeoutID);resolve(id);};const onerror=ev=>{globalThis.clearTimeout(timeoutID);reject(new Error(SCRIPT_LOAD_ERROR(id,url,ev)));};// Create the DOM element to load the script and add it to the DOM\ninsertScript(createScriptElement(url,id,async,onload,onerror,extraAttributes));// Reject on timeout\ntimeoutID=globalThis.setTimeout(()=>{reject(new Error(SCRIPT_LOAD_TIMEOUT_ERROR(id,url,timeout)));},timeout);}catch(err){reject(getMutatedError(err,SCRIPT_LOAD_ERROR(id,url,'unknown')));}});\n\n/**\n * Service to load external resources/files\n */class ExternalSrcLoader{constructor(logger,timeout=DEFAULT_EXT_SRC_LOAD_TIMEOUT_MS){this.logger=logger;this.timeout=timeout;}/**\n   * Load external resource of type javascript\n   */loadJSFile(config){const{url,id,timeout,async,callback,extraAttributes}=config;const isFireAndForget=!isFunction(callback);jsFileLoader(url,id,timeout||this.timeout,async,extraAttributes).then(id=>{if(!isFireAndForget){callback(id);}}).catch(err=>{if(!isFireAndForget){callback(id,err);}});}}\n\nvar i=Symbol.for(\"preact-signals\");function t(){if(!(s>1)){var i,t=false;while(void 0!==h){var r=h;h=void 0;f++;while(void 0!==r){var o=r.o;r.o=void 0;r.f&=-3;if(!(8&r.f)&&c(r))try{r.c();}catch(r){if(!t){i=r;t=true;}}r=o;}}f=0;s--;if(t)throw i;}else s--;}function r(i){if(s>0)return i();s++;try{return i();}finally{t();}}var o=void 0;function n(i){var t=o;o=void 0;try{return i();}finally{o=t;}}var h=void 0,s=0,f=0,v=0;function e(i){if(void 0!==o){var t=i.n;if(void 0===t||t.t!==o){t={i:0,S:i,p:o.s,n:void 0,t:o,e:void 0,x:void 0,r:t};if(void 0!==o.s)o.s.n=t;o.s=t;i.n=t;if(32&o.f)i.S(t);return t;}else if(-1===t.i){t.i=0;if(void 0!==t.n){t.n.p=t.p;if(void 0!==t.p)t.p.n=t.n;t.p=o.s;t.n=void 0;o.s.n=t;o.s=t;}return t;}}}function u(i,t){this.v=i;this.i=0;this.n=void 0;this.t=void 0;this.W=null==t?void 0:t.watched;this.Z=null==t?void 0:t.unwatched;this.name=null==t?void 0:t.name;}u.prototype.brand=i;u.prototype.h=function(){return  true;};u.prototype.S=function(i){var t=this,r=this.t;if(r!==i&&void 0===i.e){i.x=r;this.t=i;if(void 0!==r)r.e=i;else n(function(){var i;null==(i=t.W)||i.call(t);});}};u.prototype.U=function(i){var t=this;if(void 0!==this.t){var r=i.e,o=i.x;if(void 0!==r){r.x=o;i.e=void 0;}if(void 0!==o){o.e=r;i.x=void 0;}if(i===this.t){this.t=o;if(void 0===o)n(function(){var i;null==(i=t.Z)||i.call(t);});}}};u.prototype.subscribe=function(i){var t=this;return E(function(){var r=t.value,n=o;o=void 0;try{i(r);}finally{o=n;}},{name:\"sub\"});};u.prototype.valueOf=function(){return this.value;};u.prototype.toString=function(){return this.value+\"\";};u.prototype.toJSON=function(){return this.value;};u.prototype.peek=function(){var i=o;o=void 0;try{return this.value;}finally{o=i;}};Object.defineProperty(u.prototype,\"value\",{get:function(){var i=e(this);if(void 0!==i)i.i=this.i;return this.v;},set:function(i){if(i!==this.v){if(f>100)throw new Error(\"Cycle detected\");this.v=i;this.i++;v++;s++;try{for(var r=this.t;void 0!==r;r=r.x)r.t.N();}finally{t();}}}});function d(i,t){return new u(i,t);}function c(i){for(var t=i.s;void 0!==t;t=t.n)if(t.S.i!==t.i||!t.S.h()||t.S.i!==t.i)return  true;return  false;}function a(i){for(var t=i.s;void 0!==t;t=t.n){var r=t.S.n;if(void 0!==r)t.r=r;t.S.n=t;t.i=-1;if(void 0===t.n){i.s=t;break;}}}function l(i){var t=i.s,r=void 0;while(void 0!==t){var o=t.p;if(-1===t.i){t.S.U(t);if(void 0!==o)o.n=t.n;if(void 0!==t.n)t.n.p=o;}else r=t;t.S.n=t.r;if(void 0!==t.r)t.r=void 0;t=o;}i.s=r;}function y(i,t){u.call(this,void 0);this.x=i;this.s=void 0;this.g=v-1;this.f=4;this.W=null==t?void 0:t.watched;this.Z=null==t?void 0:t.unwatched;this.name=null==t?void 0:t.name;}y.prototype=new u();y.prototype.h=function(){this.f&=-3;if(1&this.f)return  false;if(32==(36&this.f))return  true;this.f&=-5;if(this.g===v)return  true;this.g=v;this.f|=1;if(this.i>0&&!c(this)){this.f&=-2;return  true;}var i=o;try{a(this);o=this;var t=this.x();if(16&this.f||this.v!==t||0===this.i){this.v=t;this.f&=-17;this.i++;}}catch(i){this.v=i;this.f|=16;this.i++;}o=i;l(this);this.f&=-2;return  true;};y.prototype.S=function(i){if(void 0===this.t){this.f|=36;for(var t=this.s;void 0!==t;t=t.n)t.S.S(t);}u.prototype.S.call(this,i);};y.prototype.U=function(i){if(void 0!==this.t){u.prototype.U.call(this,i);if(void 0===this.t){this.f&=-33;for(var t=this.s;void 0!==t;t=t.n)t.S.U(t);}}};y.prototype.N=function(){if(!(2&this.f)){this.f|=6;for(var i=this.t;void 0!==i;i=i.x)i.t.N();}};Object.defineProperty(y.prototype,\"value\",{get:function(){if(1&this.f)throw new Error(\"Cycle detected\");var i=e(this);this.h();if(void 0!==i)i.i=this.i;if(16&this.f)throw this.v;return this.v;}});function _(i){var r=i.u;i.u=void 0;if(\"function\"==typeof r){s++;var n=o;o=void 0;try{r();}catch(t){i.f&=-2;i.f|=8;b(i);throw t;}finally{o=n;t();}}}function b(i){for(var t=i.s;void 0!==t;t=t.n)t.S.U(t);i.x=void 0;i.s=void 0;_(i);}function g(i){if(o!==this)throw new Error(\"Out-of-order effect\");l(this);o=i;this.f&=-2;if(8&this.f)b(this);t();}function p(i,t){this.x=i;this.u=void 0;this.s=void 0;this.o=void 0;this.f=32;this.name=null==t?void 0:t.name;}p.prototype.c=function(){var i=this.S();try{if(8&this.f)return;if(void 0===this.x)return;var t=this.x();if(\"function\"==typeof t)this.u=t;}finally{i();}};p.prototype.S=function(){if(1&this.f)throw new Error(\"Cycle detected\");this.f|=1;this.f&=-9;_(this);a(this);s++;var i=o;o=this;return g.bind(this,i);};p.prototype.N=function(){if(!(2&this.f)){this.f|=2;this.o=h;h=this;}};p.prototype.d=function(){this.f|=8;if(!(1&this.f))b(this);};p.prototype.dispose=function(){this.d();};function E(i,t){var r=new p(i,t);try{r.c();}catch(i){r.d();throw i;}var o=r.d.bind(r);o[Symbol.dispose]=o;return o;}\n\n/**\n * A buffer queue to serve as a store for any type of data\n */class BufferQueue{constructor(){this.items=[];}enqueue(item){this.items.push(item);}dequeue(){if(this.items.length===0){return null;}return this.items.shift();}isEmpty(){return this.items.length===0;}size(){return this.items.length;}clear(){this.items=[];}}\n\nconst LOG_LEVEL_MAP={LOG:0,INFO:1,DEBUG:2,WARN:3,ERROR:4,NONE:5};const DEFAULT_LOG_LEVEL='LOG';const POST_LOAD_LOG_LEVEL='ERROR';const LOG_MSG_PREFIX='RS SDK';const LOG_MSG_PREFIX_STYLE='font-weight: bold; background: black; color: white;';const LOG_MSG_STYLE='font-weight: normal;';/**\n * Service to log messages/data to output provider, default is console\n */class Logger{constructor(minLogLevel=DEFAULT_LOG_LEVEL,scope='',logProvider=console){this.minLogLevel=LOG_LEVEL_MAP[minLogLevel];this.scope=scope;this.logProvider=logProvider;}log(...data){this.outputLog('LOG',data);}info(...data){this.outputLog('INFO',data);}debug(...data){this.outputLog('DEBUG',data);}warn(...data){this.outputLog('WARN',data);}error(...data){this.outputLog('ERROR',data);}outputLog(logMethod,data){if(this.minLogLevel<=LOG_LEVEL_MAP[logMethod]){this.logProvider[logMethod.toLowerCase()]?.(...this.formatLogData(data));}}setScope(scopeVal){this.scope=scopeVal||this.scope;}// TODO: should we allow to change the level via global variable on run time\n//  to assist on the fly debugging?\nsetMinLogLevel(logLevel){this.minLogLevel=LOG_LEVEL_MAP[logLevel];if(isUndefined(this.minLogLevel)){this.minLogLevel=LOG_LEVEL_MAP[DEFAULT_LOG_LEVEL];}}/**\n   * Formats the console message using `scope` and styles\n   */formatLogData(data){if(Array.isArray(data)&&data.length>0){// prefix SDK identifier\nlet msg=`%c ${LOG_MSG_PREFIX}`;// format the log message using `scope`\nif(this.scope){msg=`${msg} - ${this.scope}`;}// trim whitespaces for original message\nconst originalMsg=isString(data[0])?data[0].trim():'';// prepare the final message\nmsg=`${msg} %c ${originalMsg}`;const styledLogArgs=[msg,LOG_MSG_PREFIX_STYLE,// add style for the prefix\nLOG_MSG_STYLE// reset the style for the actual message\n];// add first it if it was not a string msg\nif(!isString(data[0])){styledLogArgs.push(data[0]);}// append rest of the original arguments\nstyledLogArgs.push(...data.slice(1));return styledLogArgs;}return data;}}const defaultLogger=new Logger();\n\nlet ErrorType=/*#__PURE__*/function(ErrorType){ErrorType[\"HANDLEDEXCEPTION\"]=\"handledException\";ErrorType[\"UNHANDLEDEXCEPTION\"]=\"unhandledException\";ErrorType[\"UNHANDLEDREJECTION\"]=\"unhandledPromiseRejection\";return ErrorType;}({});\n\n// default is v3\nconst SUPPORTED_STORAGE_TYPES=['localStorage','memoryStorage','cookieStorage','sessionStorage','none'];const DEFAULT_STORAGE_TYPE='cookieStorage';\n\nconst SOURCE_CONFIG_RESOLUTION_ERROR=`Unable to process/parse source configuration response`;const SOURCE_DISABLED_ERROR=`The source is disabled. Please enable the source in the dashboard to send events.`;const XHR_PAYLOAD_PREP_ERROR=`Failed to prepare data for the request.`;const PLUGIN_EXT_POINT_MISSING_ERROR=`Failed to invoke plugin because the extension point name is missing.`;const PLUGIN_EXT_POINT_INVALID_ERROR=`Failed to invoke plugin because the extension point name is invalid.`;const SOURCE_CONFIG_OPTION_ERROR=context=>`${context}${LOG_CONTEXT_SEPARATOR}The \"getSourceConfig\" load API option must be a function that returns valid source configuration data.`;const COMPONENT_BASE_URL_ERROR=(context,component,url)=>`${context}${LOG_CONTEXT_SEPARATOR}The base URL \"${url}\" for ${component} is not valid.`;// ERROR\nconst UNSUPPORTED_CONSENT_MANAGER_ERROR=(context,selectedConsentManager,consentManagersToPluginNameMap)=>`${context}${LOG_CONTEXT_SEPARATOR}The consent manager \"${selectedConsentManager}\" is not supported. Please choose one of the following supported consent managers: \"${Object.keys(consentManagersToPluginNameMap)}\".`;const NON_ERROR_WARNING=(context,errStr)=>`${context}${LOG_CONTEXT_SEPARATOR}Ignoring a non-error: ${errStr}.`;const BREADCRUMB_ERROR=`Failed to log breadcrumb`;const HANDLE_ERROR_FAILURE=context=>`${context}${LOG_CONTEXT_SEPARATOR}Failed to handle the error.`;const PLUGIN_NAME_MISSING_ERROR=context=>`${context}${LOG_CONTEXT_SEPARATOR}Plugin name is missing.`;const PLUGIN_ALREADY_EXISTS_ERROR=(context,pluginName)=>`${context}${LOG_CONTEXT_SEPARATOR}Plugin \"${pluginName}\" already exists.`;const PLUGIN_NOT_FOUND_ERROR=(context,pluginName)=>`${context}${LOG_CONTEXT_SEPARATOR}Plugin \"${pluginName}\" not found.`;const PLUGIN_ENGINE_BUG_ERROR=(context,pluginName)=>`${context}${LOG_CONTEXT_SEPARATOR}Plugin \"${pluginName}\" not found in plugins but found in byName. This indicates a bug in the plugin engine. Please report this issue to the development team.`;const PLUGIN_DEPS_ERROR=(context,pluginName,notExistDeps)=>`${context}${LOG_CONTEXT_SEPARATOR}Plugin \"${pluginName}\" could not be loaded because some of its dependencies \"${notExistDeps}\" do not exist.`;const PLUGIN_INVOCATION_ERROR=(context,extPoint,pluginName)=>`${context}${LOG_CONTEXT_SEPARATOR}Failed to invoke the \"${extPoint}\" extension point of plugin \"${pluginName}\".`;const SOURCE_CONFIG_FETCH_ERROR='Failed to fetch the source config';const WRITE_KEY_VALIDATION_ERROR=(context,writeKey)=>`${context}${LOG_CONTEXT_SEPARATOR}The write key \"${writeKey}\" is invalid. It must be a non-empty string. Please check that the write key is correct and try again.`;const DATA_PLANE_URL_VALIDATION_ERROR=(context,dataPlaneUrl)=>`${context}${LOG_CONTEXT_SEPARATOR}The data plane URL \"${dataPlaneUrl}\" is invalid. It must be a valid URL string. Please check that the data plane URL is correct and try again.`;const INVALID_CALLBACK_FN_ERROR=context=>`${context}${LOG_CONTEXT_SEPARATOR}The provided callback parameter is not a function.`;const XHR_DELIVERY_ERROR=(prefix,status,statusText,url,response)=>`${prefix} with status ${status} (${statusText}) for URL: ${url}. Response: ${response.trim()}`;const XHR_REQUEST_ERROR=(prefix,e,url)=>`${prefix} due to timeout or no connection (${e?e.type:''}) at the client side for URL: ${url}`;const XHR_SEND_ERROR=(prefix,url)=>`${prefix} for URL: ${url}`;const STORE_DATA_SAVE_ERROR=key=>`Failed to save the value for \"${key}\" to storage`;const STORE_DATA_FETCH_ERROR=key=>`Failed to retrieve or parse data for \"${key}\" from storage`;const DATA_SERVER_REQUEST_FAIL_ERROR=status=>`The server responded with status ${status} while setting the cookies. As a fallback, the cookies will be set client side.`;const FAILED_SETTING_COOKIE_FROM_SERVER_ERROR=key=>`The server failed to set the ${key} cookie. As a fallback, the cookies will be set client side.`;const FAILED_SETTING_COOKIE_FROM_SERVER_GLOBAL_ERROR=`Failed to set/remove cookies via server. As a fallback, the cookies will be managed client side.`;// WARNING\nconst STORAGE_TYPE_VALIDATION_WARNING=(context,storageType,defaultStorageType)=>`${context}${LOG_CONTEXT_SEPARATOR}The storage type \"${storageType}\" is not supported. Please choose one of the following supported types: \"${SUPPORTED_STORAGE_TYPES}\". The default type \"${defaultStorageType}\" will be used instead.`;const UNSUPPORTED_STORAGE_ENCRYPTION_VERSION_WARNING=(context,selectedStorageEncryptionVersion,storageEncryptionVersionsToPluginNameMap,defaultVersion)=>`${context}${LOG_CONTEXT_SEPARATOR}The storage encryption version \"${selectedStorageEncryptionVersion}\" is not supported. Please choose one of the following supported versions: \"${Object.keys(storageEncryptionVersionsToPluginNameMap)}\". The default version \"${defaultVersion}\" will be used instead.`;const STORAGE_DATA_MIGRATION_OVERRIDE_WARNING=(context,storageEncryptionVersion,defaultVersion)=>`${context}${LOG_CONTEXT_SEPARATOR}The storage data migration has been disabled because the configured storage encryption version (${storageEncryptionVersion}) is not the latest (${defaultVersion}). To enable storage data migration, please update the storage encryption version to the latest version.`;const SERVER_SIDE_COOKIE_FEATURE_OVERRIDE_WARNING=(context,providedCookieDomain,currentCookieDomain)=>`${context}${LOG_CONTEXT_SEPARATOR}The provided cookie domain (${providedCookieDomain}) does not match the current webpage's domain (${currentCookieDomain}). Hence, the cookies will be set client-side.`;const RESERVED_KEYWORD_WARNING=(context,property,parentKeyPath,reservedElements)=>`${context}${LOG_CONTEXT_SEPARATOR}The \"${property}\" property defined under \"${parentKeyPath}\" is a reserved keyword. Please choose a different property name to avoid conflicts with reserved keywords (${reservedElements}).`;const INVALID_CONTEXT_OBJECT_WARNING=logContext=>`${logContext}${LOG_CONTEXT_SEPARATOR}Please make sure that the \"context\" property in the event API's \"options\" argument is a valid object literal with key-value pairs.`;const UNSUPPORTED_BEACON_API_WARNING=context=>`${context}${LOG_CONTEXT_SEPARATOR}The Beacon API is not supported by your browser. The events will be sent using XHR instead.`;const TIMEOUT_NOT_NUMBER_WARNING=(context,timeout,defaultValue)=>`${context}${LOG_CONTEXT_SEPARATOR}The session timeout value \"${timeout}\" is not a number. The default timeout of ${defaultValue} ms will be used instead.`;const CUT_OFF_DURATION_NOT_NUMBER_WARNING=(context,cutOffDuration,defaultValue)=>`${context}${LOG_CONTEXT_SEPARATOR}The session cut off duration value \"${cutOffDuration}\" is not a number. The default cut off duration of ${defaultValue} ms will be used instead.`;const CUT_OFF_DURATION_LESS_THAN_TIMEOUT_WARNING=(context,cutOffDuration,timeout)=>`${context}${LOG_CONTEXT_SEPARATOR}The session cut off duration value \"${cutOffDuration}\" ms is less than the session timeout value \"${timeout}\" ms. The cut off functionality will be disabled.`;const TIMEOUT_ZERO_WARNING=context=>`${context}${LOG_CONTEXT_SEPARATOR}The session timeout value is 0, which disables the automatic session tracking feature. If you want to enable session tracking, please provide a positive integer value for the timeout.`;const TIMEOUT_NOT_RECOMMENDED_WARNING=(context,timeout,minTimeout)=>`${context}${LOG_CONTEXT_SEPARATOR}The session timeout value ${timeout} ms is less than the recommended minimum of ${minTimeout} ms. Please consider increasing the timeout value to ensure optimal performance and reliability.`;const INVALID_SESSION_ID_WARNING=(context,sessionId,minSessionIdLength)=>`${context}${LOG_CONTEXT_SEPARATOR}The provided session ID (${sessionId}) is either invalid, not a positive integer, or not at least \"${minSessionIdLength}\" digits long. A new session ID will be auto-generated instead.`;const STORAGE_QUOTA_EXCEEDED_WARNING=context=>`${context}${LOG_CONTEXT_SEPARATOR}The storage is either full or unavailable, so the data will not be persisted. Switching to in-memory storage.`;const STORAGE_UNAVAILABLE_WARNING=(context,entry,selectedStorageType,finalStorageType)=>`${context}${LOG_CONTEXT_SEPARATOR}The storage type \"${selectedStorageType}\" is not available for entry \"${entry}\". The SDK will initialize the entry with \"${finalStorageType}\" storage type instead.`;const CALLBACK_INVOKE_ERROR=context=>`${context}${LOG_CONTEXT_SEPARATOR}The callback threw an exception`;const INVALID_CONFIG_URL_WARNING=(context,configUrl)=>`${context}${LOG_CONTEXT_SEPARATOR}The provided source config URL \"${configUrl}\" is invalid. Using the default source config URL instead.`;const POLYFILL_SCRIPT_LOAD_ERROR=(scriptId,url)=>`Failed to load the polyfill script with ID \"${scriptId}\" from URL ${url}.`;const UNSUPPORTED_PRE_CONSENT_STORAGE_STRATEGY=(context,selectedStrategy,defaultStrategy)=>`${context}${LOG_CONTEXT_SEPARATOR}The pre-consent storage strategy \"${selectedStrategy}\" is not supported. Please choose one of the following supported strategies: \"none, session, anonymousId\". The default strategy \"${defaultStrategy}\" will be used instead.`;const UNSUPPORTED_PRE_CONSENT_EVENTS_DELIVERY_TYPE=(context,selectedDeliveryType,defaultDeliveryType)=>`${context}${LOG_CONTEXT_SEPARATOR}The pre-consent events delivery type \"${selectedDeliveryType}\" is not supported. Please choose one of the following supported types: \"immediate, buffer\". The default type \"${defaultDeliveryType}\" will be used instead.`;const DEPRECATED_PLUGIN_WARNING=(context,pluginName)=>`${context}${LOG_CONTEXT_SEPARATOR}${pluginName} plugin is deprecated. Please exclude it from the load API options.`;const generateMisconfiguredPluginsWarning=(context,configurationStatus,missingPlugins,shouldAddMissingPlugins)=>{const isSinglePlugin=missingPlugins.length===1;const pluginsString=isSinglePlugin?` '${missingPlugins[0]}' plugin was`:` ['${missingPlugins.join(\"', '\")}'] plugins were`;const baseWarning=`${context}${LOG_CONTEXT_SEPARATOR}${configurationStatus}, but${pluginsString} not configured to load.`;if(shouldAddMissingPlugins){return `${baseWarning} So, ${isSinglePlugin?'the plugin':'those plugins'} will be loaded automatically.`;}return `${baseWarning} Ignore if this was intentional. Otherwise, consider adding ${isSinglePlugin?'it':'them'} to the 'plugins' load API option.`;};const INVALID_POLYFILL_URL_WARNING=(context,customPolyfillUrl)=>`${context}${LOG_CONTEXT_SEPARATOR}The provided polyfill URL \"${customPolyfillUrl}\" is invalid. The default polyfill URL will be used instead.`;const PAGE_UNLOAD_ON_BEACON_DISABLED_WARNING=context=>`${context}${LOG_CONTEXT_SEPARATOR}Page Unloaded event can only be tracked when the Beacon transport is active. Please enable \"useBeacon\" load API option.`;const UNKNOWN_PLUGINS_WARNING=(context,unknownPlugins)=>`${context}${LOG_CONTEXT_SEPARATOR}Ignoring unknown plugins: ${unknownPlugins.join(', ')}.`;const CUSTOM_INTEGRATION_CANNOT_BE_ADDED_ERROR=(context,destinationId)=>`${context}${LOG_CONTEXT_SEPARATOR}Cannot add custom integration for destination ID \"${destinationId}\" after the SDK is loaded.`;\n\nconst DEFAULT_INTEGRATIONS_CONFIG={All:true};\n\nconst CDN_INT_DIR='js-integrations';const CDN_PLUGINS_DIR='plugins';const URL_PATTERN=new RegExp('^(https?:\\\\/\\\\/)'+// protocol\n'('+'((([a-zA-Z\\\\d]([a-zA-Z\\\\d-]*[a-zA-Z\\\\d])*)\\\\.)+[a-zA-Z]{2,}|'+// domain name\n'localhost|'+// localhost\n'((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9]?)\\\\.){3}'+// OR IP (v4) address first 3 octets\n'(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9]?))'+// last octet of IP address\n')'+'(\\\\:\\\\d+)?'+// port\n'(\\\\/[-a-zA-Z\\\\d%_.~+]*)*'+// path\n'(\\\\?[;&a-zA-Z\\\\d%_.~+=-]*)?'+// query string\n'(\\\\#[-a-zA-Z\\\\d_]*)?$')// fragment locator\n;\n\nconst BUILD_TYPE='modern';const SDK_CDN_BASE_URL='https://cdn.rudderlabs.com';const CDN_ARCH_VERSION_DIR='v3';const DEFAULT_INTEGRATION_SDKS_URL=`${SDK_CDN_BASE_URL}/${CDN_ARCH_VERSION_DIR}/${BUILD_TYPE}/${CDN_INT_DIR}`;const DEFAULT_PLUGINS_URL=`${SDK_CDN_BASE_URL}/${CDN_ARCH_VERSION_DIR}/${BUILD_TYPE}/${CDN_PLUGINS_DIR}`;const DEFAULT_CONFIG_BE_URL='https://api.rudderstack.com';\n\nconst DEFAULT_STORAGE_ENCRYPTION_VERSION='v3';const DEFAULT_DATA_PLANE_EVENTS_TRANSPORT='xhr';const ConsentManagersToPluginNameMap={iubenda:'IubendaConsentManager',oneTrust:'OneTrustConsentManager',ketch:'KetchConsentManager',custom:'CustomConsentManager'};const StorageEncryptionVersionsToPluginNameMap={[DEFAULT_STORAGE_ENCRYPTION_VERSION]:'StorageEncryption',legacy:'StorageEncryptionLegacy'};const DataPlaneEventsTransportToPluginNameMap={[DEFAULT_DATA_PLANE_EVENTS_TRANSPORT]:'XhrQueue',beacon:'BeaconQueue'};const DEFAULT_DATA_SERVICE_ENDPOINT='rsaRequest';const METRICS_SERVICE_ENDPOINT='rsaMetrics';const CUSTOM_DEVICE_MODE_DESTINATION_DISPLAY_NAME='Custom Device Mode';\n\nconst defaultLoadOptions={configUrl:DEFAULT_CONFIG_BE_URL,loadIntegration:true,sessions:{autoTrack:true,timeout:DEFAULT_SESSION_TIMEOUT_MS,cutOff:{enabled:false}},sameSiteCookie:'Lax',polyfillIfRequired:true,integrations:DEFAULT_INTEGRATIONS_CONFIG,useBeacon:false,beaconQueueOptions:{},destinationsQueueOptions:{},queueOptions:{},lockIntegrationsVersion:true,lockPluginsVersion:true,uaChTrackLevel:'none',plugins:[],useGlobalIntegrationsConfigInEvents:false,bufferDataPlaneEventsUntilReady:false,dataPlaneEventsBufferTimeout:DEFAULT_DATA_PLANE_EVENTS_BUFFER_TIMEOUT_MS,storage:{encryption:{version:DEFAULT_STORAGE_ENCRYPTION_VERSION},migrate:true,cookie:{}},sendAdblockPage:false,sameDomainCookiesOnly:false,secureCookie:false,sendAdblockPageOptions:{},useServerSideCookies:false};const loadOptionsState=d(clone(defaultLoadOptions));\n\nconst DEFAULT_USER_SESSION_VALUES=deepFreeze({userId:'',userTraits:{},anonymousId:'',groupId:'',groupTraits:{},initialReferrer:'',initialReferringDomain:'',sessionInfo:{},authToken:null});const DEFAULT_RESET_OPTIONS=deepFreeze({entries:{userId:true,userTraits:true,groupId:true,groupTraits:true,sessionInfo:true,authToken:true,// These are not reset by default\nanonymousId:false,initialReferrer:false,initialReferringDomain:false}});const SERVER_SIDE_COOKIES_DEBOUNCE_TIME=10;// milliseconds\n\nconst sessionState={userId:d(DEFAULT_USER_SESSION_VALUES.userId),userTraits:d(DEFAULT_USER_SESSION_VALUES.userTraits),anonymousId:d(DEFAULT_USER_SESSION_VALUES.anonymousId),groupId:d(DEFAULT_USER_SESSION_VALUES.groupId),groupTraits:d(DEFAULT_USER_SESSION_VALUES.groupTraits),initialReferrer:d(DEFAULT_USER_SESSION_VALUES.initialReferrer),initialReferringDomain:d(DEFAULT_USER_SESSION_VALUES.initialReferringDomain),sessionInfo:d(DEFAULT_USER_SESSION_VALUES.sessionInfo),authToken:d(DEFAULT_USER_SESSION_VALUES.authToken)};\n\nconst capabilitiesState={isOnline:d(true),storage:{isLocalStorageAvailable:d(false),isCookieStorageAvailable:d(false),isSessionStorageAvailable:d(false)},isBeaconAvailable:d(false),isLegacyDOM:d(false),isUaCHAvailable:d(false),isCryptoAvailable:d(false),isIE11:d(false),isAdBlockerDetectionInProgress:d(false),isAdBlocked:d(undefined),cspBlockedURLs:d([])};\n\nconst reportingState={isErrorReportingEnabled:d(false),isMetricsReportingEnabled:d(false),breadcrumbs:d([])};\n\nconst sourceConfigState=d(undefined);\n\nconst lifecycleState={activeDataplaneUrl:d(undefined),integrationsCDNPath:d(DEFAULT_INTEGRATION_SDKS_URL),pluginsCDNPath:d(DEFAULT_PLUGINS_URL),sourceConfigUrl:d(undefined),status:d(undefined),initialized:d(false),logLevel:d(POST_LOAD_LOG_LEVEL),loaded:d(false),readyCallbacks:d([]),writeKey:d(undefined),dataPlaneUrl:d(undefined),safeAnalyticsInstance:d(undefined)};\n\nconst consentsState={enabled:d(false),initialized:d(false),data:d({}),activeConsentManagerPluginName:d(undefined),preConsent:d({enabled:false}),postConsent:d({}),resolutionStrategy:d('and'),provider:d(undefined),metadata:d(undefined)};\n\nconst metricsState={retries:d(0),dropped:d(0),sent:d(0),queued:d(0),triggered:d(0),metricsServiceUrl:d(undefined)};\n\nconst contextState={app:d({name:APP_NAME,namespace:APP_NAMESPACE,version:APP_VERSION,installType:MODULE_TYPE}),traits:d(null),library:d({name:APP_NAME,version:APP_VERSION,snippetVersion:globalThis.RudderSnippetVersion}),userAgent:d(null),device:d(null),network:d(null),os:d({name:'',version:''}),locale:d(null),screen:d({density:0,width:0,height:0,innerWidth:0,innerHeight:0}),'ua-ch':d(undefined),timezone:d(undefined)};\n\nconst nativeDestinationsState={configuredDestinations:d([]),activeDestinations:d([]),loadOnlyIntegrations:d({}),failedDestinations:d([]),loadIntegration:d(true),initializedDestinations:d([]),clientDestinationsReady:d(false),integrationsConfig:d({})};\n\nconst eventBufferState={toBeProcessedArray:d([]),readyCallbacksArray:d([])};\n\nconst pluginsState={ready:d(false),loadedPlugins:d([]),failedPlugins:d([]),pluginsToLoadFromConfig:d([]),activePlugins:d([]),totalPluginsToLoad:d(0)};\n\nconst storageState={encryptionPluginName:d(undefined),migrate:d(false),type:d(undefined),cookie:d(undefined),entries:d({}),trulyAnonymousTracking:d(false)};\n\nconst serverSideCookiesState={isEnabledServerSideCookies:d(false),dataServiceUrl:d(undefined)};\n\nconst dataPlaneEventsState={eventsQueuePluginName:d(undefined),deliveryEnabled:d(true)// Delivery should always happen\n};\n\nconst autoTrackState={enabled:d(false),pageLifecycle:{enabled:d(false),pageViewId:d(undefined),pageLoadedTimestamp:d(undefined)}};\n\nconst defaultStateValues={capabilities:capabilitiesState,consents:consentsState,context:contextState,eventBuffer:eventBufferState,lifecycle:lifecycleState,loadOptions:loadOptionsState,metrics:metricsState,nativeDestinations:nativeDestinationsState,plugins:pluginsState,reporting:reportingState,session:sessionState,source:sourceConfigState,storage:storageState,serverCookies:serverSideCookiesState,dataPlaneEvents:dataPlaneEventsState,autoTrack:autoTrackState};const state={...clone(defaultStateValues)};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar errorStackParser$1 = {exports: {}};\n\nvar stackframe$1 = {exports: {}};\n\nvar stackframe=stackframe$1.exports;var hasRequiredStackframe;function requireStackframe(){if(hasRequiredStackframe)return stackframe$1.exports;hasRequiredStackframe=1;(function(module,exports$1){(function(root,factory){/* istanbul ignore next */{module.exports=factory();}})(stackframe,function(){function _isNumber(n){return !isNaN(parseFloat(n))&&isFinite(n);}function _capitalize(str){return str.charAt(0).toUpperCase()+str.substring(1);}function _getter(p){return function(){return this[p];};}var booleanProps=['isConstructor','isEval','isNative','isToplevel'];var numericProps=['columnNumber','lineNumber'];var stringProps=['fileName','functionName','source'];var arrayProps=['args'];var objectProps=['evalOrigin'];var props=booleanProps.concat(numericProps,stringProps,arrayProps,objectProps);function StackFrame(obj){if(!obj)return;for(var i=0;i<props.length;i++){if(obj[props[i]]!==undefined){this['set'+_capitalize(props[i])](obj[props[i]]);}}}StackFrame.prototype={getArgs:function(){return this.args;},setArgs:function(v){if(Object.prototype.toString.call(v)!=='[object Array]'){throw new TypeError('Args must be an Array');}this.args=v;},getEvalOrigin:function(){return this.evalOrigin;},setEvalOrigin:function(v){if(v instanceof StackFrame){this.evalOrigin=v;}else if(v instanceof Object){this.evalOrigin=new StackFrame(v);}else {throw new TypeError('Eval Origin must be an Object or StackFrame');}},toString:function(){var fileName=this.getFileName()||'';var lineNumber=this.getLineNumber()||'';var columnNumber=this.getColumnNumber()||'';var functionName=this.getFunctionName()||'';if(this.getIsEval()){if(fileName){return '[eval] ('+fileName+':'+lineNumber+':'+columnNumber+')';}return '[eval]:'+lineNumber+':'+columnNumber;}if(functionName){return functionName+' ('+fileName+':'+lineNumber+':'+columnNumber+')';}return fileName+':'+lineNumber+':'+columnNumber;}};StackFrame.fromString=function StackFrame$$fromString(str){var argsStartIndex=str.indexOf('(');var argsEndIndex=str.lastIndexOf(')');var functionName=str.substring(0,argsStartIndex);var args=str.substring(argsStartIndex+1,argsEndIndex).split(',');var locationString=str.substring(argsEndIndex+1);if(locationString.indexOf('@')===0){var parts=/@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString,'');var fileName=parts[1];var lineNumber=parts[2];var columnNumber=parts[3];}return new StackFrame({functionName:functionName,args:args||undefined,fileName:fileName,lineNumber:lineNumber||undefined,columnNumber:columnNumber||undefined});};for(var i=0;i<booleanProps.length;i++){StackFrame.prototype['get'+_capitalize(booleanProps[i])]=_getter(booleanProps[i]);StackFrame.prototype['set'+_capitalize(booleanProps[i])]=function(p){return function(v){this[p]=Boolean(v);};}(booleanProps[i]);}for(var j=0;j<numericProps.length;j++){StackFrame.prototype['get'+_capitalize(numericProps[j])]=_getter(numericProps[j]);StackFrame.prototype['set'+_capitalize(numericProps[j])]=function(p){return function(v){if(!_isNumber(v)){throw new TypeError(p+' must be a Number');}this[p]=Number(v);};}(numericProps[j]);}for(var k=0;k<stringProps.length;k++){StackFrame.prototype['get'+_capitalize(stringProps[k])]=_getter(stringProps[k]);StackFrame.prototype['set'+_capitalize(stringProps[k])]=function(p){return function(v){this[p]=String(v);};}(stringProps[k]);}return StackFrame;});})(stackframe$1);return stackframe$1.exports;}\n\nvar errorStackParser=errorStackParser$1.exports;var hasRequiredErrorStackParser;function requireErrorStackParser(){if(hasRequiredErrorStackParser)return errorStackParser$1.exports;hasRequiredErrorStackParser=1;(function(module,exports$1){(function(root,factory){/* istanbul ignore next */{module.exports=factory(requireStackframe());}})(errorStackParser,function ErrorStackParser(StackFrame){var FIREFOX_SAFARI_STACK_REGEXP=/(^|@)\\S+:\\d+/;var CHROME_IE_STACK_REGEXP=/^\\s*at .*(\\S+:\\d+|\\(native\\))/m;var SAFARI_NATIVE_CODE_REGEXP=/^(eval@)?(\\[native code])?$/;return {/**\n\t\t         * Given an Error object, extract the most information from it.\n\t\t         *\n\t\t         * @param {Error} error object\n\t\t         * @return {Array} of StackFrames\n\t\t         */parse:function ErrorStackParser$$parse(error){if(typeof error.stacktrace!=='undefined'||typeof error['opera#sourceloc']!=='undefined'){return this.parseOpera(error);}else if(error.stack&&error.stack.match(CHROME_IE_STACK_REGEXP)){return this.parseV8OrIE(error);}else if(error.stack){return this.parseFFOrSafari(error);}else {throw new Error('Cannot parse given Error object');}},// Separate line and column numbers from a string of the form: (URI:Line:Column)\nextractLocation:function ErrorStackParser$$extractLocation(urlLike){// Fail-fast but return locations like \"(native)\"\nif(urlLike.indexOf(':')===-1){return [urlLike];}var regExp=/(.+?)(?::(\\d+))?(?::(\\d+))?$/;var parts=regExp.exec(urlLike.replace(/[()]/g,''));return [parts[1],parts[2]||undefined,parts[3]||undefined];},parseV8OrIE:function ErrorStackParser$$parseV8OrIE(error){var filtered=error.stack.split('\\n').filter(function(line){return !!line.match(CHROME_IE_STACK_REGEXP);},this);return filtered.map(function(line){if(line.indexOf('(eval ')>-1){// Throw away eval information until we implement stacktrace.js/stackframe#8\nline=line.replace(/eval code/g,'eval').replace(/(\\(eval at [^()]*)|(,.*$)/g,'');}var sanitizedLine=line.replace(/^\\s+/,'').replace(/\\(eval code/g,'(').replace(/^.*?\\s+/,'');// capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n// case it has spaces in it, as the string is split on \\s+ later on\nvar location=sanitizedLine.match(/ (\\(.+\\)$)/);// remove the parenthesized location from the line, if it was matched\nsanitizedLine=location?sanitizedLine.replace(location[0],''):sanitizedLine;// if a location was matched, pass it to extractLocation() otherwise pass all sanitizedLine\n// because this line doesn't have function name\nvar locationParts=this.extractLocation(location?location[1]:sanitizedLine);var functionName=location&&sanitizedLine||undefined;var fileName=['eval','<anonymous>'].indexOf(locationParts[0])>-1?undefined:locationParts[0];return new StackFrame({functionName:functionName,fileName:fileName,lineNumber:locationParts[1],columnNumber:locationParts[2],source:line});},this);},parseFFOrSafari:function ErrorStackParser$$parseFFOrSafari(error){var filtered=error.stack.split('\\n').filter(function(line){return !line.match(SAFARI_NATIVE_CODE_REGEXP);},this);return filtered.map(function(line){// Throw away eval information until we implement stacktrace.js/stackframe#8\nif(line.indexOf(' > eval')>-1){line=line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,':$1');}if(line.indexOf('@')===-1&&line.indexOf(':')===-1){// Safari eval frames only have function names and nothing else\nreturn new StackFrame({functionName:line});}else {var functionNameRegex=/((.*\".+\"[^@]*)?[^@]*)(?:@)/;var matches=line.match(functionNameRegex);var functionName=matches&&matches[1]?matches[1]:undefined;var locationParts=this.extractLocation(line.replace(functionNameRegex,''));return new StackFrame({functionName:functionName,fileName:locationParts[0],lineNumber:locationParts[1],columnNumber:locationParts[2],source:line});}},this);},parseOpera:function ErrorStackParser$$parseOpera(e){if(!e.stacktrace||e.message.indexOf('\\n')>-1&&e.message.split('\\n').length>e.stacktrace.split('\\n').length){return this.parseOpera9(e);}else if(!e.stack){return this.parseOpera10(e);}else {return this.parseOpera11(e);}},parseOpera9:function ErrorStackParser$$parseOpera9(e){var lineRE=/Line (\\d+).*script (?:in )?(\\S+)/i;var lines=e.message.split('\\n');var result=[];for(var i=2,len=lines.length;i<len;i+=2){var match=lineRE.exec(lines[i]);if(match){result.push(new StackFrame({fileName:match[2],lineNumber:match[1],source:lines[i]}));}}return result;},parseOpera10:function ErrorStackParser$$parseOpera10(e){var lineRE=/Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;var lines=e.stacktrace.split('\\n');var result=[];for(var i=0,len=lines.length;i<len;i+=2){var match=lineRE.exec(lines[i]);if(match){result.push(new StackFrame({functionName:match[3]||undefined,fileName:match[2],lineNumber:match[1],source:lines[i]}));}}return result;},// Opera 10.65+ Error.stack very similar to FF/Safari\nparseOpera11:function ErrorStackParser$$parseOpera11(error){var filtered=error.stack.split('\\n').filter(function(line){return !!line.match(FIREFOX_SAFARI_STACK_REGEXP)&&!line.match(/^Error created at/);},this);return filtered.map(function(line){var tokens=line.split('@');var locationParts=this.extractLocation(tokens.pop());var functionCall=tokens.shift()||'';var functionName=functionCall.replace(/<anonymous function(: (\\w+))?>/,'$2').replace(/\\([^)]*\\)/g,'')||undefined;var argsRaw;if(functionCall.match(/\\(([^)]*)\\)/)){argsRaw=functionCall.replace(/^[^(]+\\(([^)]*)\\)$/,'$1');}var args=argsRaw===undefined||argsRaw==='[arguments not available]'?undefined:argsRaw.split(',');return new StackFrame({functionName:functionName,args:args,fileName:locationParts[0],lineNumber:locationParts[1],columnNumber:locationParts[2],source:line});},this);}};});})(errorStackParser$1);return errorStackParser$1.exports;}\n\nvar errorStackParserExports = requireErrorStackParser();\nconst ErrorStackParser = /*@__PURE__*/getDefaultExportFromCjs(errorStackParserExports);\n\nconst GLOBAL_CODE='global code';const normalizeFunctionName=name=>{if(isDefined(name)){return /^global code$/i.test(name)?GLOBAL_CODE:name;}return name;};/**\n * Takes a stacktrace.js style stackframe (https://github.com/stacktracejs/stackframe)\n * and returns a Bugsnag compatible stackframe (https://docs.bugsnag.com/api/error-reporting/#json-payload)\n * @param frame\n * @returns\n */const formatStackframe=frame=>{const f={file:frame.fileName,method:normalizeFunctionName(frame.functionName),lineNumber:frame.lineNumber,columnNumber:frame.columnNumber};// Some instances result in no file:\n// - non-error exception thrown from global code in FF\n// This adds one.\nif(f.lineNumber&&f.lineNumber>-1&&!f.file&&!f.method){f.file=GLOBAL_CODE;}return f;};const ensureString=str=>isString(str)?str:'';function createException(errorClass,errorMessage,msgPrefix,stacktrace){return {errorClass:ensureString(errorClass),message:`${msgPrefix}${ensureString(errorMessage)}`,type:'browserjs',stacktrace:stacktrace.reduce((accum,frame)=>{const f=formatStackframe(frame);// don't include a stackframe if none of its properties are defined\ntry{if(JSON.stringify(f)==='{}')return accum;return accum.concat(f);}catch{return accum;}},[])};}const normalizeError=(maybeError,logger)=>{let error;if(isTypeOfError(maybeError)&&isString(getStacktrace(maybeError))){error=maybeError;}else {logger.warn(NON_ERROR_WARNING(ERROR_HANDLER,stringifyWithoutCircular(maybeError)));error=undefined;}return error;};const createBugsnagException=(error,msgPrefix)=>{try{const stacktrace=ErrorStackParser.parse(error);return createException(error.name,error.message,msgPrefix,stacktrace);}catch{return createException(error.name,error.message,msgPrefix,[]);}};\n\n/**\n * Utility to parse XHR JSON response\n */const responseTextToJson=(responseText,onError)=>{try{return JSON.parse(responseText||'');}catch(err){const error=getMutatedError(err,'Failed to parse response data');onError(error);}return undefined;};\n\nconst FAILED_REQUEST_ERR_MSG_PREFIX='The request failed';const PLUGINS_LOAD_FAILURE_MESSAGES=[/Failed to fetch dynamically imported module: .*/];const INTEGRATIONS_LOAD_FAILURE_MESSAGES=[/Unable to load \\(.*\\) the script with the id .*/,/A timeout of \\d+ ms occurred while trying to load the script with id .*/];const ERROR_MESSAGES_TO_BE_FILTERED=[new RegExp(`${FAILED_REQUEST_ERR_MSG_PREFIX}.*`),/A script with the id .* is already loaded\\./];const SCRIPT_LOAD_FAILURE_MESSAGES=[...PLUGINS_LOAD_FAILURE_MESSAGES,...INTEGRATIONS_LOAD_FAILURE_MESSAGES];\n\nconst DEFAULT_XHR_REQUEST_OPTIONS={headers:{Accept:'application/json','Content-Type':'application/json;charset=UTF-8'},method:'GET'};/**\n * Utility to create request configuration based on default options\n */const createXhrRequestOptions=(url,options,basicAuthHeader)=>{const requestOptions=mergeDeepRight(DEFAULT_XHR_REQUEST_OPTIONS,options||{});if(basicAuthHeader){requestOptions.headers=mergeDeepRight(requestOptions.headers,{Authorization:basicAuthHeader});}requestOptions.url=url;return requestOptions;};/**\n * Utility implementation of XHR, fetch cannot be used as it requires explicit\n * origin allowed values and not wildcard for CORS requests with credentials and\n * this is not supported by our sourceConfig API\n */const xhrRequest=(options,timeout=DEFAULT_XHR_TIMEOUT_MS,logger)=>new Promise((resolve,reject)=>{let payload;if(options.sendRawData===true){payload=options.data;}else {payload=stringifyWithoutCircular(options.data,false,[],logger);if(isNull(payload)){reject({error:new Error(XHR_PAYLOAD_PREP_ERROR),undefined,options});// return and don't process further if the payload could not be stringified\nreturn;}}const xhr=new XMLHttpRequest();// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst xhrReject=e=>{reject({error:new Error(XHR_DELIVERY_ERROR(FAILED_REQUEST_ERR_MSG_PREFIX,xhr.status,xhr.statusText,options.url,xhr.responseText)),xhr,options});};const xhrError=e=>{reject({error:new Error(XHR_REQUEST_ERROR(FAILED_REQUEST_ERR_MSG_PREFIX,e,options.url)),xhr,options,...(e?.type==='timeout'?{timedOut:true}:{})});};xhr.ontimeout=xhrError;xhr.onerror=xhrError;xhr.onload=()=>{if(xhr.status>=200&&xhr.status<400){resolve({response:xhr.responseText,xhr,options});}else {xhrReject();}};xhr.open(options.method,options.url,true);if(options.withCredentials===true){xhr.withCredentials=true;}// The timeout property may be set only in the time interval between a call to the open method\n// and the first call to the send method in legacy browsers\nxhr.timeout=timeout;Object.keys(options.headers).forEach(headerName=>{if(options.headers[headerName]){xhr.setRequestHeader(headerName,options.headers[headerName]);}});try{xhr.send(payload);}catch(err){reject({error:getMutatedError(err,XHR_SEND_ERROR(FAILED_REQUEST_ERR_MSG_PREFIX,options.url)),xhr,options});}});\n\n/**\n * Service to handle data communication with APIs\n */class HttpClient{constructor(logger){this.logger=logger;this.onError=this.onError.bind(this);}init(errorHandler){this.errorHandler=errorHandler;}/**\n   * Implement requests in a blocking way\n   */async getData(config){const{url,options,timeout,isRawResponse}=config;try{const data=await xhrRequest(createXhrRequestOptions(url,options,this.basicAuthHeader),timeout,this.logger);return {data:isRawResponse?data.response:responseTextToJson(data.response,this.onError),details:data};}catch(reason){return {data:undefined,details:reason};}}/**\n   * Implement requests in a non-blocking way\n   */getAsyncData(config){const{callback,url,options,timeout,isRawResponse}=config;const isFireAndForget=!isFunction(callback);xhrRequest(createXhrRequestOptions(url,options,this.basicAuthHeader),timeout,this.logger).then(data=>{if(!isFireAndForget){callback(isRawResponse?data.response:responseTextToJson(data.response,this.onError),data);}}).catch(data=>{if(!isFireAndForget){callback(undefined,data);}});}/**\n   * Handle errors\n   */onError(error,groupingHash){this.errorHandler?.onError({error,context:HTTP_CLIENT,groupingHash});}/**\n   * Set basic authentication header (eg writekey)\n   */setAuthHeader(value,noBtoa=false){const authVal=noBtoa?value:toBase64(`${value}:`);this.basicAuthHeader=`Basic ${authVal}`;}/**\n   * Clear basic authentication header\n   */resetAuthHeader(){this.basicAuthHeader=undefined;}}const defaultHttpClient=new HttpClient(defaultLogger);\n\nconst METRICS_PAYLOAD_VERSION='1';\n\n// Errors from the below scripts are NOT allowed to reach Bugsnag\nconst SDK_FILE_NAME_PREFIXES=()=>['rsa'// Prefix for all the SDK scripts including plugins and module federated chunks\n];const DEV_HOSTS=['www.test-host.com','localhost','127.0.0.1','[::1]'];// List of keys to exclude from the metadata\n// Potential PII or sensitive data\nconst APP_STATE_EXCLUDE_KEYS=['userId','userTraits','groupId','groupTraits','anonymousId','config','integration',// integration instance objects\n'eventBuffer',// pre-load event buffer (may contain PII)\n'traits','authToken'];const NOTIFIER_NAME='RudderStack JavaScript SDK';const SDK_GITHUB_URL='git+https://github.com/rudderlabs/rudder-sdk-js.git';const SOURCE_NAME='js';const DEFAULT_ERROR_CATEGORY='sdk';\n\nconst detectAdBlockers=httpClient=>{state.capabilities.isAdBlockerDetectionInProgress.value=true;try{// Apparently, '?view=ad' is a query param that is blocked by majority of adblockers\n// Use source config URL here as it is very unlikely to be blocked by adblockers\n// Only the extra query param should make it vulnerable to adblockers\n// This will work even if the users proxies it.\n// The edge case where this doesn't work is when HEAD method is not allowed by the server (user's)\nconst baseUrl=new URL(state.lifecycle.sourceConfigUrl.value);const url=`${baseUrl.origin}${baseUrl.pathname}?view=ad`;httpClient.getAsyncData({url,options:{// We actually don't need the response from the request, so we are using HEAD\nmethod:'HEAD',headers:{'Content-Type':undefined}},isRawResponse:true,callback:(result,details)=>{state.capabilities.isAdBlockerDetectionInProgress.value=false;// not ad blocked if the request is successful or it is not internally redirected on the client side\n// Often adblockers instead of blocking the request, they redirect it to an internal URL\nstate.capabilities.isAdBlocked.value=details?.error!==undefined||details?.xhr?.responseURL!==url;}});}catch(err){// Reset the flag to prevent blocking future detection attempts\nstate.capabilities.isAdBlockerDetectionInProgress.value=false;// Re-throw the error to be handled by the caller\nthrow err;}};\n\nconst getErrInstance=(err,errorType)=>{switch(errorType){case ErrorType.UNHANDLEDEXCEPTION:{const{error}=err;return error||err;}case ErrorType.UNHANDLEDREJECTION:{return err.reason;}case ErrorType.HANDLEDEXCEPTION:default:return err;}};const createNewBreadcrumb=message=>({type:'manual',name:message,timestamp:new Date(),metaData:{}});/**\n * A function to get the Bugsnag release stage for the current environment\n * @param getHostName Optional function to get the hostname (primarily for testing)\n * @returns 'development' if the host is empty (for file:// protocol etc.) or a dev host (localhost, 127.0.0.1, etc.), otherwise ''production'' (it'll be replaced with the actual release stage during the build)\n */const getReleaseStage=(getHostName=()=>window.location.hostname)=>{const host=getHostName();return !host||host&&DEV_HOSTS.includes(host)?'development':'production';};const getAppStateForMetadata=state=>{const stateStr=stringifyWithoutCircular(state,false,APP_STATE_EXCLUDE_KEYS);return stateStr!==null?JSON.parse(stateStr):{};};const getURLWithoutQueryString=()=>{const url=globalThis.location.href.split('?');return url[0];};const getUserDetails=(source,session,lifecycle,autoTrack)=>({id:`${source.value?.id??lifecycle.writeKey.value}..${session.sessionInfo.value.id??'NA'}..${autoTrack.pageLifecycle.pageViewId.value??'NA'}`,name:source.value?.name??'NA'});const getDeviceDetails=(locale,userAgent)=>({locale:locale.value??'NA',userAgent:userAgent.value??'NA',time:new Date()});const getBugsnagErrorEvent=(exception,errorState,state,groupingHash)=>{const{context,lifecycle,session,source,reporting,autoTrack}=state;const{app,locale,userAgent,timezone,screen,library}=context;return {payloadVersion:'5',notifier:{name:NOTIFIER_NAME,version:app.value.version,url:SDK_GITHUB_URL},events:[{exceptions:[clone(exception)],severity:errorState.severity,unhandled:errorState.unhandled,severityReason:errorState.severityReason,app:{version:app.value.version,releaseStage:getReleaseStage(),type:app.value.installType},device:getDeviceDetails(locale,userAgent),request:{url:getURLWithoutQueryString(),clientIp:'[NOT COLLECTED]'},breadcrumbs:clone(reporting.breadcrumbs.value),context:exception.message,groupingHash,metaData:{app:{snippetVersion:library.value.snippetVersion},device:{...screen.value,timezone:timezone.value},// Add rest of the state groups as metadata\n// so that they show up as separate tabs in the dashboard\n...getAppStateForMetadata(state)},user:getUserDetails(source,session,lifecycle,autoTrack)}]};};/**\n * A function to check if adblockers are active. The promise's resolve function\n * is invoked with true if adblockers are not detected and false otherwise.\n * @param {ApplicationState} state The application state\n * @param {IHttpClient} httpClient The HTTP client instance\n * @param {Function} resolve The promise's resolve function\n */const checkIfAdBlockersAreActive=(state,httpClient,resolve)=>{// Initiate ad blocker detection if not done previously and not already in progress.\nif(isUndefined(state.capabilities.isAdBlocked.value)){if(state.capabilities.isAdBlockerDetectionInProgress.value===false){detectAdBlockers(httpClient);}// Wait for the detection to complete.\nconst detectionDisposer=E(()=>{if(isDefined(state.capabilities.isAdBlocked.value)){// If ad blocker is not detected, notify.\nresolve(state.capabilities.isAdBlocked.value===false);// Cleanup the effect.\ndetectionDisposer();}});}else {// If ad blocker is not detected, notify.\nresolve(state.capabilities.isAdBlocked.value===false);}};/**\n * A function to determine whether the error should be promoted to notify or not.\n * For plugin and integration errors from RS CDN, if it is due to CSP blocked URLs or AdBlockers,\n * it will not be promoted to notify.\n * If it is due to other reasons, it will be promoted to notify.\n * @param {Error} exception The error object\n * @param {ApplicationState} state The application state\n * @param {IHttpClient} httpClient The HTTP client instance\n * @returns A promise that resolves to a boolean indicating whether the error should be promoted to notify or not\n */const checkIfAllowedToBeNotified=(exception,state,httpClient)=>{const errMsg=exception.message;return new Promise(resolve=>{// Filter out script load failures that are not from the RS CDN.\nif(SCRIPT_LOAD_FAILURE_MESSAGES.some(regex=>regex.test(errMsg))){const extractedURL=/https?:\\/\\/[^\\s\"'(),;<>[\\]{}]+/.exec(errMsg)?.[0];if(isString(extractedURL)){if(extractedURL.startsWith(SDK_CDN_BASE_URL)){// Filter out errors that are from CSP blocked URLs.\nif(state.capabilities.cspBlockedURLs.value.includes(extractedURL)){resolve(false);}else {// Filter out errors if adblockers are detected.\ncheckIfAdBlockersAreActive(state,httpClient,resolve);}}else {// Filter out errors that are not from the RS CDN.\nresolve(false);}}else {// Allow the error to be notified if no URL could be extracted from the error message\nresolve(true);}}else {resolve(!ERROR_MESSAGES_TO_BE_FILTERED.some(e=>e.test(errMsg)));}});};/**\n * A function to determine if the error is from Rudder SDK\n * @param {Error} exception\n * @returns\n */const isSDKError=exception=>{const errorOrigin=exception.stacktrace[0]?.file;if(!errorOrigin||typeof errorOrigin!=='string'){return false;}const srcFileName=errorOrigin.substring(errorOrigin.lastIndexOf('/')+1);const paths=errorOrigin.split('/');// extract the parent folder name from the error origin file path\n// Ex: parentFolderName will be 'sample' for url: https://example.com/sample/file.min.js\nconst parentFolderName=paths[paths.length-2];return parentFolderName===CDN_INT_DIR||SDK_FILE_NAME_PREFIXES().some(prefix=>srcFileName.startsWith(prefix)&&srcFileName.endsWith('.js'));};const getErrorDeliveryPayload=(payload,state,category)=>{const data={version:METRICS_PAYLOAD_VERSION,message_id:generateUUID(),source:{name:SOURCE_NAME,sdk_version:state.context.app.value.version,write_key:state.lifecycle.writeKey.value,install_type:state.context.app.value.installType,category:category??DEFAULT_ERROR_CATEGORY},errors:payload};return stringifyWithoutCircular(data);};/**\n * A function to get the grouping hash value to be used for the error event.\n * If the grouping hash is an error instance, the normalized error message is used as the grouping hash.\n * If the grouping hash is an empty string or not specified, the default grouping hash is used.\n * If the grouping hash is a string, it is used as is.\n * @param curErrGroupingHash The grouping hash value part of the error event\n * @param defaultGroupingHash The default grouping hash value. It is the error message.\n * @param logger The logger instance\n * @returns The final grouping hash value to be used for the error event\n */const getErrorGroupingHash=(curErrGroupingHash,defaultGroupingHash,logger)=>{let normalizedGroupingHash;if(!isDefined(curErrGroupingHash)){normalizedGroupingHash=defaultGroupingHash;}else if(isString(curErrGroupingHash)){normalizedGroupingHash=curErrGroupingHash;}else {const normalizedErrorInstance=normalizeError(curErrGroupingHash,logger);if(isDefined(normalizedErrorInstance)){normalizedGroupingHash=normalizedErrorInstance.message;}else {normalizedGroupingHash=defaultGroupingHash;}}return normalizedGroupingHash;};\n\n/**\n * A service to handle errors\n */class ErrorHandler{initialized=false;// If no logger is passed errors will be thrown as unhandled error\nconstructor(httpClient,logger){this.httpClient=httpClient;this.logger=logger;}/**\n   * Initializes the error handler by attaching global error listeners.\n   * This method should be called once after construction.\n   */init(){if(this.initialized){return;}this.attachErrorListeners();this.initialized=true;}/**\n   * Attach error listeners to the global window object\n   */attachErrorListeners(){globalThis.addEventListener('error',event=>{this.onError({error:event,context:ERROR_HANDLER,errorType:ErrorType.UNHANDLEDEXCEPTION});});globalThis.addEventListener('unhandledrejection',event=>{this.onError({error:event,context:ERROR_HANDLER,errorType:ErrorType.UNHANDLEDREJECTION});});// Listen to CSP violations and add the blocked URL to the state\n// if those URLs are from RS CDN.\ndocument.addEventListener('securitypolicyviolation',event=>{const blockedURL=isString(event.blockedURI)?event.blockedURI:'';if(event.disposition==='enforce'&&blockedURL.startsWith(SDK_CDN_BASE_URL)&&!state.capabilities.cspBlockedURLs.value.includes(blockedURL)){state.capabilities.cspBlockedURLs.value=[...state.capabilities.cspBlockedURLs.value,blockedURL];}});}/**\n   * Handle errors\n   * @param errorInfo - The error information\n   * @param errorInfo.error - The error to handle\n   * @param errorInfo.context - The context of where the error occurred\n   * @param errorInfo.customMessage - The custom message of the error\n   * @param errorInfo.errorType - The type of the error (handled or unhandled)\n   * @param errorInfo.groupingHash - The grouping hash of the error\n   * @param errorInfo.category - The category of the error (sdk or integrations)\n   */async onError(errorInfo){try{const{error,context,customMessage,groupingHash,category}=errorInfo;const errorType=errorInfo.errorType??ErrorType.HANDLEDEXCEPTION;const errInstance=getErrInstance(error,errorType);const normalizedError=normalizeError(errInstance,this.logger);if(isUndefined(normalizedError)){return;}const customMsgVal=customMessage?`${customMessage} - `:'';const errorMsgPrefix=`${context}${LOG_CONTEXT_SEPARATOR}${customMsgVal}`;const bsException=createBugsnagException(normalizedError,errorMsgPrefix);const stacktrace=getStacktrace(normalizedError);const isSdkDispatched=stacktrace.includes(MANUAL_ERROR_IDENTIFIER);// Filter errors that are not originated in the SDK.\n// In case of NPM installations, the unhandled errors from the SDK cannot be identified\n// and will NOT be reported unless they occur in plugins or integrations.\nif(!isSdkDispatched&&!isSDKError(bsException)&&errorType!==ErrorType.HANDLEDEXCEPTION){return;}if(state.reporting.isErrorReportingEnabled.value){const isAllowed=await checkIfAllowedToBeNotified(bsException,state,this.httpClient);if(isAllowed){const errorState={severity:'error',unhandled:errorType!==ErrorType.HANDLEDEXCEPTION,severityReason:{type:errorType}};// This will allow custom grouping of errors.\n// In case of NPM installations, the default grouping by surrounding code\n// does not make sense as each user application is different and will create a lot of noise in the alerts.\n// References:\n// https://docs.bugsnag.com/platforms/javascript/customizing-error-reports/#groupinghash\n// https://docs.bugsnag.com/product/error-grouping/#user_defined\nconst normalizedGroupingHash=getErrorGroupingHash(groupingHash,bsException.message,this.logger);// Get the final payload to be sent to the metrics service\nconst bugsnagPayload=getBugsnagErrorEvent(bsException,errorState,state,normalizedGroupingHash);// send it to metrics service\nthis.httpClient.getAsyncData({url:state.metrics.metricsServiceUrl.value,options:{method:'POST',data:getErrorDeliveryPayload(bugsnagPayload,state,category),sendRawData:true},isRawResponse:true});}}// Log handled errors and errors dispatched by the SDK\nif(errorType===ErrorType.HANDLEDEXCEPTION||isSdkDispatched){this.logger.error(bsException.message);}}catch(err){// If an error occurs while handling an error, log it\nthis.logger.error(HANDLE_ERROR_FAILURE(ERROR_HANDLER),err);}}/**\n   * Add breadcrumbs to add insight of a user's journey before an error\n   * occurred and send to external error monitoring service via a plugin\n   *\n   * @param {string} breadcrumb breadcrumbs message\n   */leaveBreadcrumb(breadcrumb){try{state.reporting.breadcrumbs.value=[...state.reporting.breadcrumbs.value,createNewBreadcrumb(breadcrumb)];}catch(err){this.onError({error:err,context:ERROR_HANDLER,customMessage:BREADCRUMB_ERROR,groupingHash:BREADCRUMB_ERROR});}}}// Note: Remember to call defaultErrorHandler.init() before using it\nconst defaultErrorHandler=new ErrorHandler(defaultHttpClient,defaultLogger);\n\n//  to next or return the value if it is the last one instead of an array per\n//  plugin that is the normal invoke\n// TODO: add invoke method for extension point that we know only one plugin can be used. add invokeMultiple and invokeSingle methods\nclass PluginEngine{plugins=[];byName={};cache={};config={throws:true};constructor(logger,options={}){this.config={throws:true,...options};this.logger=logger;}register(plugin,state){if(!plugin.name){const errorMessage=PLUGIN_NAME_MISSING_ERROR(PLUGIN_ENGINE);if(this.config.throws){throw new Error(errorMessage);}else {this.logger.error(errorMessage,plugin);return;}}if(this.byName[plugin.name]){const errorMessage=PLUGIN_ALREADY_EXISTS_ERROR(PLUGIN_ENGINE,plugin.name);if(this.config.throws){throw new Error(errorMessage);}else {this.logger.error(errorMessage);return;}}this.cache={};this.plugins=this.plugins.slice();let pos=this.plugins.length;this.plugins.forEach((pluginItem,index)=>{if(pluginItem.deps?.includes(plugin.name)){pos=Math.min(pos,index);}});this.plugins.splice(pos,0,plugin);this.byName[plugin.name]=plugin;if(isFunction(plugin.initialize)){plugin.initialize(state);}}unregister(name){const plugin=this.byName[name];if(!plugin){const errorMessage=PLUGIN_NOT_FOUND_ERROR(PLUGIN_ENGINE,name);if(this.config.throws){throw new Error(errorMessage);}else {this.logger.error(errorMessage);return;}}const index=this.plugins.indexOf(plugin);if(index===-1){const errorMessage=PLUGIN_ENGINE_BUG_ERROR(PLUGIN_ENGINE,name);if(this.config.throws){throw new Error(errorMessage);}else {this.logger.error(errorMessage);return;}}this.cache={};delete this.byName[name];this.plugins=this.plugins.slice();this.plugins.splice(index,1);}getPlugin(name){return this.byName[name];}getPlugins(extPoint){const lifeCycleName=extPoint??'.';if(!this.cache[lifeCycleName]){this.cache[lifeCycleName]=this.plugins.filter(plugin=>{if(plugin.deps?.some(dependency=>!this.byName[dependency])){// If deps not exist, then not load it.\nconst notExistDeps=plugin.deps.filter(dependency=>!this.byName[dependency]);this.logger.error(PLUGIN_DEPS_ERROR(PLUGIN_ENGINE,plugin.name,notExistDeps));return false;}return lifeCycleName==='.'?true:hasValueByPath(plugin,lifeCycleName);});}return this.cache[lifeCycleName];}// This method allows to process this.plugins so that it could\n// do some unified pre-process before application starts.\nprocessRawPlugins(callback){callback(this.plugins);this.cache={};}invoke(extPoint,allowMultiple=true,...args){let extensionPointName=extPoint;if(!extensionPointName){throw new Error(PLUGIN_EXT_POINT_MISSING_ERROR);}const noCall=extensionPointName.startsWith('!');const throws=this.config.throws??extensionPointName.endsWith('!');// eslint-disable-next-line unicorn/better-regex\nextensionPointName=extensionPointName.replace(/(^!|!$)/g,'');if(!extensionPointName){throw new Error(PLUGIN_EXT_POINT_INVALID_ERROR);}const extensionPointNameParts=extensionPointName.split('.');extensionPointNameParts.pop();const pluginMethodPath=extensionPointNameParts.join('.');const pluginsToInvoke=allowMultiple?this.getPlugins(extensionPointName):[this.getPlugins(extensionPointName)[0]];return pluginsToInvoke.map(plugin=>{const method=getValueByPath(plugin,extensionPointName);if(!isFunction(method)||noCall){return method;}try{return method.apply(getValueByPath(plugin,pluginMethodPath),args);}catch(err){// When a plugin failed, doesn't break the app\nif(throws){throw err;}else {this.logger.error(PLUGIN_INVOCATION_ERROR(PLUGIN_ENGINE,extensionPointName,plugin.name),err);}}return null;});}invokeSingle(extPoint,...args){return this.invoke(extPoint,false,...args)[0];}invokeMultiple(extPoint,...args){return this.invoke(extPoint,true,...args);}}const defaultPluginEngine=new PluginEngine(defaultLogger,{throws:true});\n\n/**\n * A function to filter and return non cloud mode destinations\n * A destination is considered non cloud mode if it is not a cloud mode destination or if it is a hybrid mode destination\n * @param destination\n *\n * @returns boolean\n */const isNonCloudDestination=destination=>Boolean(destination.config.connectionMode!=='cloud'||destination.config.useNativeSDKToSend===true||// this is the older flag for hybrid mode destinations\ndestination.config.useNativeSDK===true);const isHybridModeDestination=destination=>Boolean(destination.config.connectionMode==='hybrid'||destination.config.useNativeSDKToSend===true);/**\n * A function to filter and return non cloud mode destinations\n * @param destinations\n *\n * @returns destinations\n */const getNonCloudDestinations=destinations=>destinations.filter(isNonCloudDestination);/**\n * A function to get the user friendly id for a destination\n * Replaces all spaces with hyphens and appends the id to the display name\n * @param displayName The display name of the destination\n * @param id The id of the destination\n *\n * @returns the user friendly id\n */const getDestinationUserFriendlyId=(displayName,id)=>`${displayName.replaceAll(' ','-')}___${id}`;\n\n/**\n * List of plugin names that are loaded as dynamic imports in modern builds\n */const pluginNamesList=['BeaconQueue','CustomConsentManager','DeviceModeDestinations','DeviceModeTransformation','ExternalAnonymousId','GoogleLinker','IubendaConsentManager','KetchConsentManager','NativeDestinationQueue','OneTrustConsentManager','StorageEncryption','StorageEncryptionLegacy','StorageMigrator','XhrQueue'];const deprecatedPluginsList=['Bugsnag','ErrorReporting'];\n\nconst remotesMap = {\n'rudderAnalyticsRemotePlugins':{url:()=>Promise.resolve(window.RudderStackGlobals && window.RudderStackGlobals.app && window.RudderStackGlobals.app.pluginsCDNPath ? `${window.RudderStackGlobals.app.pluginsCDNPath}/rsa-plugins.js` : `https://cdn.rudderlabs.com/v3/modern/plugins//rsa-plugins.js`),format:'esm',from:'vite'}\n};\n                \n                function merge(obj1, obj2) {\n                  const mergedObj = Object.assign(obj1, obj2);\n                  for (const key of Object.keys(mergedObj)) {\n                    if (typeof mergedObj[key] === 'object' && typeof obj2[key] === 'object') {\n                      mergedObj[key] = merge(mergedObj[key], obj2[key]);\n                    }\n                  }\n                  return mergedObj;\n                }\n\n                const wrapShareModule = remoteFrom => {\n                  return merge({\n                    \n                  }, (globalThis.__federation_shared__ || {})['default'] || {});\n                };\n\n                async function __federation_method_ensure(remoteId) {\n                    const remote = remotesMap[remoteId];\n                    if (!remote.inited) {\n                        if (['esm', 'systemjs'].includes(remote.format)) {\n                            // loading js with import(...)\n                            return new Promise((resolve, reject) => {\n                                const getUrl = typeof remote.url === 'function' ? remote.url : () => Promise.resolve(remote.url);\n                                getUrl().then(url => {\n                                    import(/* webpackIgnore: true */ /* @vite-ignore */ url).then(lib => {\n                                        if (!remote.inited) {\n                                            const shareScope = wrapShareModule();\n                                            lib.init(shareScope);\n                                            remote.lib = lib;\n                                            remote.lib.init(shareScope);\n                                            remote.inited = true;\n                                        }\n                                        resolve(remote.lib);\n                                    }).catch(reject);\n                                });\n                            })\n                        }\n                    } else {\n                        return remote.lib;\n                    }\n                }\n\n                function __federation_method_wrapDefault(module, need) {\n                    if (!module?.default && need) {\n                        let obj = Object.create(null);\n                        obj.default = module;\n                        obj.__esModule = true;\n                        return obj;\n                    }\n                    return module;\n                }\n\n                function __federation_method_getRemote(remoteName, componentName) {\n                    return __federation_method_ensure(remoteName).then((remote) => remote.get(componentName).then(factory => factory()));\n                }\n\n/**\n * Get the lazy loaded dynamic import for a plugin name\n */const getFederatedModuleImport=pluginName=>{switch(pluginName){case 'BeaconQueue':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./BeaconQueue\").then(module=>__federation_method_wrapDefault(module, true));case 'CustomConsentManager':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./CustomConsentManager\").then(module=>__federation_method_wrapDefault(module, true));case 'DeviceModeDestinations':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./DeviceModeDestinations\").then(module=>__federation_method_wrapDefault(module, true));case 'DeviceModeTransformation':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./DeviceModeTransformation\").then(module=>__federation_method_wrapDefault(module, true));case 'ExternalAnonymousId':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./ExternalAnonymousId\").then(module=>__federation_method_wrapDefault(module, true));case 'GoogleLinker':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./GoogleLinker\").then(module=>__federation_method_wrapDefault(module, true));case 'KetchConsentManager':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./KetchConsentManager\").then(module=>__federation_method_wrapDefault(module, true));case 'IubendaConsentManager':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./IubendaConsentManager\").then(module=>__federation_method_wrapDefault(module, true));case 'NativeDestinationQueue':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./NativeDestinationQueue\").then(module=>__federation_method_wrapDefault(module, true));case 'OneTrustConsentManager':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./OneTrustConsentManager\").then(module=>__federation_method_wrapDefault(module, true));case 'StorageEncryption':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./StorageEncryption\").then(module=>__federation_method_wrapDefault(module, true));case 'StorageEncryptionLegacy':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./StorageEncryptionLegacy\").then(module=>__federation_method_wrapDefault(module, true));case 'StorageMigrator':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./StorageMigrator\").then(module=>__federation_method_wrapDefault(module, true));case 'XhrQueue':return ()=>__federation_method_getRemote(\"rudderAnalyticsRemotePlugins\" , \"./XhrQueue\").then(module=>__federation_method_wrapDefault(module, true));default:return undefined;}};/**\n * Map of active plugin names to their dynamic import\n */const federatedModulesBuildPluginImports=activePluginNames=>{const remotePlugins={};activePluginNames.forEach(pluginName=>{if(pluginNamesList.includes(pluginName)){const lazyLoadImport=getFederatedModuleImport(pluginName);if(lazyLoadImport){remotePlugins[pluginName]=lazyLoadImport;}}});return remotePlugins;};\n\n/**\n * Map of mandatory plugin names and direct imports\n */const getMandatoryPluginsMap=()=>({});/**\n * Map of optional plugin names and direct imports for legacy builds\n */const getOptionalPluginsMap=()=>{{return {};}};/**\n * Map of optional plugin names and dynamic imports for modern builds\n */const getRemotePluginsMap=activePluginNames=>{return federatedModulesBuildPluginImports?.(activePluginNames)||{};};const pluginsInventory={...getMandatoryPluginsMap(),...getOptionalPluginsMap()};const remotePluginsInventory=activePluginNames=>({...getRemotePluginsMap(activePluginNames)});\n\n// TODO: add retry mechanism for getting remote plugins\n// TODO: add timeout error mechanism for marking remote plugins that failed to load as failed in state\nclass PluginsManager{constructor(engine,errorHandler,logger){this.engine=engine;this.errorHandler=errorHandler;this.logger=logger;this.onError=this.onError.bind(this);}/**\n   * Orchestrate the plugin loading and registering\n   */init(){state.lifecycle.status.value='pluginsLoading';// Expose pluginsCDNPath to global object, so it can be used in the promise that determines\n// remote plugin cdn path to support proxied plugin remotes\n{setExposedGlobal('pluginsCDNPath',state.lifecycle.pluginsCDNPath.value);}this.setActivePlugins();this.registerLocalPlugins();this.registerRemotePlugins();this.attachEffects();}/**\n   * Update state based on plugin loaded status\n   */// eslint-disable-next-line class-methods-use-this\nattachEffects(){E(()=>{const isAllPluginsReady=state.plugins.activePlugins.value.length===0||state.plugins.loadedPlugins.value.length+state.plugins.failedPlugins.value.length===state.plugins.totalPluginsToLoad.value;if(isAllPluginsReady){r(()=>{state.plugins.ready.value=true;// TODO: decide what to do if a plugin fails to load for any reason.\n//  Should we stop here or should we progress?\nstate.lifecycle.status.value='pluginsReady';});}});}/**\n   * Determine the list of plugins that should be loaded based on sourceConfig & load options\n   */// eslint-disable-next-line class-methods-use-this\ngetPluginsToLoadBasedOnConfig(){// This contains the default plugins if load option has been omitted by user\nlet pluginsToLoadFromConfig=state.plugins.pluginsToLoadFromConfig.value;if(!pluginsToLoadFromConfig){return [];}// Filter deprecated plugins\npluginsToLoadFromConfig=pluginsToLoadFromConfig.filter(pluginName=>{if(deprecatedPluginsList.includes(pluginName)){this.logger.warn(DEPRECATED_PLUGIN_WARNING(PLUGINS_MANAGER,pluginName));return false;}return true;});const pluginGroupsToProcess=[{configurationStatus:()=>isDefined(state.dataPlaneEvents.eventsQueuePluginName.value),configurationStatusStr:'Data plane events delivery is enabled',activePluginName:state.dataPlaneEvents.eventsQueuePluginName.value,supportedPlugins:Object.values(DataPlaneEventsTransportToPluginNameMap),shouldAddMissingPlugins:true},{configurationStatus:()=>getNonCloudDestinations(state.nativeDestinations.configuredDestinations.value).length>0,configurationStatusStr:'Device mode destinations are connected to the source',supportedPlugins:['DeviceModeDestinations','NativeDestinationQueue']},{configurationStatus:()=>getNonCloudDestinations(state.nativeDestinations.configuredDestinations.value).some(destination=>destination.shouldApplyDeviceModeTransformation),configurationStatusStr:'Device mode transformations are enabled for at least one destination',supportedPlugins:['DeviceModeTransformation']},{configurationStatus:()=>isDefined(state.consents.activeConsentManagerPluginName.value),configurationStatusStr:'Consent management is enabled',activePluginName:state.consents.activeConsentManagerPluginName.value,supportedPlugins:Object.values(ConsentManagersToPluginNameMap)},{configurationStatus:()=>isDefined(state.storage.encryptionPluginName.value),configurationStatusStr:'Storage encryption is enabled',activePluginName:state.storage.encryptionPluginName.value,supportedPlugins:Object.values(StorageEncryptionVersionsToPluginNameMap)},{configurationStatus:()=>state.storage.migrate.value,configurationStatusStr:'Storage migration is enabled',supportedPlugins:['StorageMigrator']}];const addMissingPlugins=false;pluginGroupsToProcess.forEach(group=>{if(group.configurationStatus()){pluginsToLoadFromConfig=pluginsToLoadFromConfig.filter(group.activePluginName?pluginName=>!(pluginName!==group.activePluginName&&group.supportedPlugins.includes(pluginName)):pluginName=>isDefined(pluginName)// pass through\n);this.addMissingPlugins(group,addMissingPlugins,pluginsToLoadFromConfig);}else {pluginsToLoadFromConfig=pluginsToLoadFromConfig.filter(group.basePlugins!==undefined?pluginName=>!(group.basePlugins.includes(pluginName)||group.supportedPlugins.includes(pluginName)):pluginName=>!group.supportedPlugins.includes(pluginName));}});return [...Object.keys(getMandatoryPluginsMap()),...pluginsToLoadFromConfig];}addMissingPlugins(group,addMissingPlugins,pluginsToLoadFromConfig){const shouldAddMissingPlugins=group.shouldAddMissingPlugins||addMissingPlugins;let pluginsToConfigure;if(group.activePluginName){pluginsToConfigure=[...(group.basePlugins||[]),group.activePluginName];}else {pluginsToConfigure=[...group.supportedPlugins];}const missingPlugins=pluginsToConfigure.filter(pluginName=>!pluginsToLoadFromConfig.includes(pluginName));if(missingPlugins.length>0){if(shouldAddMissingPlugins){pluginsToLoadFromConfig.push(...missingPlugins);}this.logger.warn(generateMisconfiguredPluginsWarning(PLUGINS_MANAGER,group.configurationStatusStr,missingPlugins,shouldAddMissingPlugins));}}/**\n   * Determine the list of plugins that should be activated\n   */setActivePlugins(){const pluginsToLoad=this.getPluginsToLoadBasedOnConfig();// Merging available mandatory and optional plugin name list\nconst availablePlugins=[...Object.keys(pluginsInventory),...pluginNamesList];const activePlugins=[];const failedPlugins=[];pluginsToLoad.forEach(pluginName=>{if(availablePlugins.includes(pluginName)){activePlugins.push(pluginName);}else {failedPlugins.push(pluginName);}});if(failedPlugins.length>0){this.logger.warn(UNKNOWN_PLUGINS_WARNING(PLUGINS_MANAGER,failedPlugins));}r(()=>{state.plugins.totalPluginsToLoad.value=pluginsToLoad.length;state.plugins.activePlugins.value=activePlugins;state.plugins.failedPlugins.value=failedPlugins;});}/**\n   * Register plugins that are direct imports to PluginEngine\n   */registerLocalPlugins(){Object.values(pluginsInventory).forEach(localPlugin=>{if(isFunction(localPlugin)&&state.plugins.activePlugins.value.includes(localPlugin().name)){this.register([localPlugin()]);}});}/**\n   * Register plugins that are dynamic imports to PluginEngine\n   */registerRemotePlugins(){const remotePluginsList=remotePluginsInventory(state.plugins.activePlugins.value);Promise.all(Object.keys(remotePluginsList).map(async remotePluginKey=>{await remotePluginsList[remotePluginKey]().then(remotePluginModule=>this.register([remotePluginModule.default()])).catch(err=>{// TODO: add retry here if dynamic import fails\nstate.plugins.failedPlugins.value=[...state.plugins.failedPlugins.value,remotePluginKey];this.onError(err,`Failed to load plugin \"${remotePluginKey}\"`,err);});})).catch(err=>{this.onError(err);});}/**\n   * Extension point invoke that allows multiple plugins to be registered to it with error handling\n   */invokeMultiple(extPoint,...args){try{return this.engine.invokeMultiple(extPoint,...args);}catch(e){this.onError(e,extPoint);return [];}}/**\n   * Extension point invoke that allows a single plugin to be registered to it with error handling\n   */invokeSingle(extPoint,...args){try{return this.engine.invokeSingle(extPoint,...args);}catch(e){this.onError(e,extPoint);return null;}}/**\n   * Plugin engine register with error handling\n   */register(plugins){plugins.forEach(plugin=>{try{this.engine.register(plugin,state);}catch(e){state.plugins.failedPlugins.value=[...state.plugins.failedPlugins.value,plugin.name];this.onError(e,`Failed to register plugin \"${plugin.name}\"`);}});}// TODO: Implement reset API instead\nunregisterLocalPlugins(){Object.values(pluginsInventory).forEach(localPlugin=>{try{this.engine.unregister(localPlugin().name);}catch(e){this.onError(e,`Failed to unregister plugin \"${localPlugin().name}\"`);}});}/**\n   * Handle errors\n   */onError(error,customMessage,groupingHash){this.errorHandler.onError({error,context:PLUGINS_MANAGER,customMessage,groupingHash});}}\n\nconst COOKIE_STORAGE='cookieStorage';const LOCAL_STORAGE='localStorage';const SESSION_STORAGE='sessionStorage';const MEMORY_STORAGE='memoryStorage';const NO_STORAGE='none';const STORAGE_TEST_COOKIE='test_rudder_cookie';const STORAGE_TEST_LOCAL_STORAGE='test_rudder_ls';const STORAGE_TEST_SESSION_STORAGE='test_rudder_ss';\n\nconst userIdKey='rl_user_id';const userTraitsKey='rl_trait';const anonymousUserIdKey='rl_anonymous_id';const groupIdKey='rl_group_id';const groupTraitsKey='rl_group_trait';const pageInitialReferrerKey='rl_page_init_referrer';const pageInitialReferringDomainKey='rl_page_init_referring_domain';const sessionInfoKey='rl_session';const authTokenKey='rl_auth_token';const COOKIE_KEYS={userId:userIdKey,userTraits:userTraitsKey,anonymousId:anonymousUserIdKey,groupId:groupIdKey,groupTraits:groupTraitsKey,initialReferrer:pageInitialReferrerKey,initialReferringDomain:pageInitialReferringDomainKey,sessionInfo:sessionInfoKey,authToken:authTokenKey};\n\nconst STORAGE_TEST_TOP_LEVEL_DOMAIN='__tld__';const CLIENT_DATA_STORE_COOKIE='clientDataInCookie';const CLIENT_DATA_STORE_LS='clientDataInLocalStorage';const CLIENT_DATA_STORE_MEMORY='clientDataInMemory';const CLIENT_DATA_STORE_SESSION='clientDataInSessionStorage';const USER_SESSION_KEYS=['userId','userTraits','anonymousId','groupId','groupTraits','initialReferrer','initialReferringDomain','sessionInfo','authToken'];\n\nconst storageClientDataStoreNameMap={[COOKIE_STORAGE]:CLIENT_DATA_STORE_COOKIE,[LOCAL_STORAGE]:CLIENT_DATA_STORE_LS,[MEMORY_STORAGE]:CLIENT_DATA_STORE_MEMORY,[SESSION_STORAGE]:CLIENT_DATA_STORE_SESSION};\n\n/**\n * Encode.\n */const encode=(value,logger)=>{try{return encodeURIComponent(value);}catch(err){logger?.error(COOKIE_DATA_ENCODING_ERROR,err);return undefined;}};/**\n * Decode\n */const decode=value=>{try{return decodeURIComponent(value);}catch(err){// Do nothing as non-RS SDK cookies may not be URI encoded\nreturn undefined;}};/**\n * Parse cookie `str`\n */const parse=str=>{const obj={};const pairs=str.split(/\\s*;\\s*/);let pair;if(!pairs[0]){return obj;}// TODO: Decode only the cookies that are needed by the SDK\npairs.forEach(pairItem=>{pair=pairItem.split('=');const keyName=pair[0]?decode(pair[0]):undefined;if(keyName){obj[keyName]=pair[1]?decode(pair[1]):undefined;}});return obj;};/**\n * Set cookie `name` to `value`\n */const set=(name,value,optionsConfig,logger)=>{const options={...(optionsConfig||{})};let cookieString=`${encode(name,logger)}=${encode(value,logger)}`;if(isNull(value)){options.maxage=-1;}if(options.maxage){options.expires=new Date(+new Date()+options.maxage);}if(options.path){cookieString+=`; path=${options.path}`;}if(options.domain){cookieString+=`; domain=${options.domain}`;}if(options.expires){cookieString+=`; expires=${options.expires.toUTCString()}`;}if(options.samesite){cookieString+=`; samesite=${options.samesite}`;}if(options.secure){cookieString+=`; secure`;}globalThis.document.cookie=cookieString;};/**\n * Return all cookies\n */const all=()=>{const cookieStringValue=globalThis.document.cookie;return parse(cookieStringValue);};/**\n * Get cookie `name`\n */const get=name=>all()[name];/**\n * Set or get cookie `name` with `value` and `options` object\n */// eslint-disable-next-line func-names\nconst cookie=function(name,value,options,logger){switch(arguments.length){case 4:case 3:case 2:return set(name,value,options,logger);case 1:if(name){return get(name);}return all();default:return all();}};\n\nconst legacyGetHostname=href=>{const l=document.createElement('a');l.href=href;return l.hostname;};/**\n * Levels returns all levels of the given url\n *\n * The method returns an empty array when the hostname is an ip.\n */const levelsFunc=url=>{// This is called before the polyfills load thus new URL cannot be used\nconst host=typeof globalThis.URL!=='function'?legacyGetHostname(url):new URL(url).hostname;const parts=host?.split('.')??[];const last=parts[parts.length-1];const levels=[];// Ip address.\nif(parts.length===4&&last&&last===parseInt(last,10).toString()){return levels;}// Localhost.\nif(parts.length<=1){// Fix to support localhost\nif(parts[0]&&parts[0].indexOf('localhost')!==-1){return ['localhost'];}return levels;}// Create levels.\nfor(let i=parts.length-2;i>=0;i-=1){levels.push(parts.slice(i).join('.'));}return levels;};/**\n * Get the top domain.\n *\n * The function constructs the levels of domain and attempts to set a global\n * cookie on each one when it succeeds it returns the top level domain.\n *\n * The method returns an empty string when the hostname is an ip.\n */const domain=url=>{const levels=levelsFunc(url);// Lookup the real top level one.\n// eslint-disable-next-line unicorn/no-for-loop\nfor(let i=0;i<levels.length;i+=1){const domain=levels[i];const cname=STORAGE_TEST_TOP_LEVEL_DOMAIN;const opts={domain:`${domain.indexOf('localhost')!==-1?'':'.'}${domain}`};try{// Set cookie on domain\ncookie(cname,1,opts);// If successful\nif(cookie(cname)){// Remove cookie from domain\ncookie(cname,null,opts);return domain;}}catch{// Silently continue to next domain level if cookie access is restricted or setting fails\n// Best-effort cleanup to avoid leaking the test cookie\ntry{cookie(cname,null,opts);}catch{// Ignore if we are unable to delete the cookie\n}}}return '';};\n\nconst getDefaultCookieOptions=()=>{const topDomain=`.${domain(globalThis.location.href)}`;return {maxage:DEFAULT_COOKIE_MAX_AGE_MS,path:'/',domain:!topDomain||topDomain==='.'?undefined:topDomain,samesite:'Lax',enabled:true};};const getDefaultLocalStorageOptions=()=>({enabled:true});const getDefaultSessionStorageOptions=()=>({enabled:true});const getDefaultInMemoryStorageOptions=()=>({enabled:true});\n\n/**\n * A storage utility to retain values in memory via Storage interface\n */class InMemoryStorage{isEnabled=true;length=0;data={};constructor(logger){this.options=getDefaultInMemoryStorageOptions();this.logger=logger;}configure(options){this.options=mergeDeepRight(this.options,options??{});this.isEnabled=Boolean(this.options.enabled);return this.options;}setItem(key,value){this.data[key]=value;this.length=Object.keys(this.data).length;return value;}getItem(key){if(key in this.data){return this.data[key];}return null;}removeItem(key){if(key in this.data){delete this.data[key];}this.length=Object.keys(this.data).length;return null;}clear(){this.data={};this.length=0;}key(index){const curKeys=this.keys();return curKeys[index]??null;}keys(){return Object.keys(this.data);}}const defaultInMemoryStorage=new InMemoryStorage(defaultLogger);\n\nvar store$2 = {exports: {}};\n\nvar store$1=store$2.exports;var hasRequiredStore;function requireStore(){if(hasRequiredStore)return store$2.exports;hasRequiredStore=1;(function(module,exports$1){(function(global,factory){module.exports=factory();})(store$1,function(){function isJSON(obj){obj=JSON.stringify(obj);if(!/^\\{[\\s\\S]*\\}$/.test(obj)){return false;}return true;}function stringify(val){return val===undefined||typeof val===\"function\"?val+'':JSON.stringify(val);}function deserialize(value){if(typeof value!=='string'){return undefined;}try{return JSON.parse(value);}catch(e){return value;}}function isFunction(value){return {}.toString.call(value)===\"[object Function]\";}function isArray(value){return Object.prototype.toString.call(value)===\"[object Array]\";}// https://github.com/jaywcjlove/store.js/pull/8\n// Error: QuotaExceededError\nfunction dealIncognito(storage){var _KEY='_Is_Incognit',_VALUE='yes';try{// NOTE: set default storage when not passed in\nif(!storage){storage=window.localStorage;}storage.setItem(_KEY,_VALUE);storage.removeItem(_KEY);}catch(e){var inMemoryStorage={};inMemoryStorage._data={};inMemoryStorage.setItem=function(id,val){return inMemoryStorage._data[id]=String(val);};inMemoryStorage.getItem=function(id){return inMemoryStorage._data.hasOwnProperty(id)?inMemoryStorage._data[id]:undefined;};inMemoryStorage.removeItem=function(id){return delete inMemoryStorage._data[id];};inMemoryStorage.clear=function(){return inMemoryStorage._data={};};storage=inMemoryStorage;}finally{if(storage.getItem(_KEY)===_VALUE)storage.removeItem(_KEY);}return storage;}// deal QuotaExceededError if user use incognito mode in browser\nvar storage=dealIncognito();function Store(){if(!(this instanceof Store)){return new Store();}}Store.prototype={set:function set(key,val){if(key&&!isJSON(key)){storage.setItem(key,stringify(val));}else if(isJSON(key)){for(var a in key)this.set(a,key[a]);}return this;},get:function get(key){// Return all entries if no key\nif(key===undefined){var ret={};this.forEach(function(key,val){return ret[key]=val;});return ret;}if(key.charAt(0)==='?'){return this.has(key.substr(1));}var args=arguments;if(args.length>1){var dt={};for(var i=0,len=args.length;i<len;i++){var value=deserialize(storage.getItem(args[i]));if(this.has(args[i])){dt[args[i]]=value;}}return dt;}return deserialize(storage.getItem(key));},clear:function clear(){storage.clear();return this;},remove:function remove(key){var val=this.get(key);storage.removeItem(key);return val;},has:function has(key){return {}.hasOwnProperty.call(this.get(),key);},keys:function keys(){var d=[];this.forEach(function(k){d.push(k);});return d;},forEach:function forEach(callback){for(var i=0,len=storage.length;i<len;i++){var key=storage.key(i);callback(key,this.get(key));}return this;},search:function search(str){var arr=this.keys(),dt={};for(var i=0,len=arr.length;i<len;i++){if(arr[i].indexOf(str)>-1)dt[arr[i]]=this.get(arr[i]);}return dt;},len:function len(){return storage.length;}};var _Store=null;function store(key,data){var argm=arguments;var dt=null;if(!_Store)_Store=Store();if(argm.length===0)return _Store.get();if(argm.length===1){if(typeof key===\"string\")return _Store.get(key);if(isJSON(key))return _Store.set(key);}if(argm.length===2&&typeof key===\"string\"){if(!data)return _Store.remove(key);if(data&&typeof data===\"string\")return _Store.set(key,data);if(data&&isFunction(data)){dt=null;dt=data(key,_Store.get(key));store.set(key,dt);}}if(argm.length===2&&isArray(key)&&isFunction(data)){for(var i=0,len=key.length;i<len;i++){dt=data(key[i],_Store.get(key[i]));store.set(key[i],dt);}}return store;}for(var a in Store.prototype)store[a]=Store.prototype[a];return store;});})(store$2);return store$2.exports;}\n\nvar storeExports = requireStore();\nconst store = /*@__PURE__*/getDefaultExportFromCjs(storeExports);\n\nconst isStorageQuotaExceeded=e=>{const matchingNames=['QuotaExceededError','NS_ERROR_DOM_QUOTA_REACHED'];// Everything except Firefox, Firefox\nconst matchingCodes=[22,1014];if(e instanceof DOMException){return matchingNames.includes(e.name)||matchingCodes.includes(e.code);}return false;};// TODO: also check for SecurityErrors\n//  https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage#exceptions\nconst isStorageAvailable=(type=LOCAL_STORAGE,storageInstance,logger)=>{let storage;let testData;const msgPrefix=STORAGE_UNAVAILABILITY_ERROR_PREFIX(CAPABILITIES_MANAGER,type);let reason='unavailable';let isAccessible=true;let errObj;try{switch(type){case MEMORY_STORAGE:return true;case COOKIE_STORAGE:storage=storageInstance;testData=STORAGE_TEST_COOKIE;break;case LOCAL_STORAGE:storage=storageInstance??globalThis.localStorage;testData=STORAGE_TEST_LOCAL_STORAGE;// was STORAGE_TEST_LOCAL_STORAGE in ours and generateUUID() in segment retry one\nbreak;case SESSION_STORAGE:storage=storageInstance??globalThis.sessionStorage;testData=STORAGE_TEST_SESSION_STORAGE;break;default:return false;}if(storage){storage.setItem(testData,'true');if(storage.getItem(testData)){storage.removeItem(testData);return true;}}isAccessible=false;}catch(err){isAccessible=false;errObj=err;if(isStorageQuotaExceeded(err)){reason='full';}}if(!isAccessible){logger?.warn(`${msgPrefix}${reason}.`,errObj);}// if we've have reached here, it means the storage is not available\nreturn false;};\n\n//  check if the get, set overloads and search methods are used at all\n//  if we do, ensure we provide types to support overloads as per storejs docs\n//  https://www.npmjs.com/package/storejs\n/**\n * A storage utility to persist values in localstorage via Storage interface\n */class LocalStorage{isSupportAvailable=true;isEnabled=true;length=0;constructor(logger){this.options=getDefaultLocalStorageOptions();this.logger=logger;}configure(options){this.options=mergeDeepRight(this.options,options??{});this.isSupportAvailable=isStorageAvailable(LOCAL_STORAGE);this.isEnabled=Boolean(this.options.enabled&&this.isSupportAvailable);return this.options;}setItem(key,value){store.set(key,value);this.length=store.len();}// eslint-disable-next-line class-methods-use-this\ngetItem(key){const value=store.get(key);return isUndefined(value)?null:value;}removeItem(key){store.remove(key);this.length=store.len();}clear(){store.clear();this.length=0;}key(index){const curKeys=this.keys();return curKeys[index]??null;}// eslint-disable-next-line class-methods-use-this\nkeys(){return store.keys();}}const defaultLocalStorage=new LocalStorage(defaultLogger);\n\n/**\n * A storage utility to persist values in SessionStorage via Storage interface\n */class SessionStorage{isSupportAvailable=true;isEnabled=true;length=0;constructor(logger){this.options=getDefaultSessionStorageOptions();this.logger=logger;}configure(options){this.options=mergeDeepRight(this.options,options??{});this.isSupportAvailable=isStorageAvailable(SESSION_STORAGE);// when storage is blocked by the user, even accessing the property throws an error\nif(this.isSupportAvailable){this.store=globalThis.sessionStorage;}this.isEnabled=Boolean(this.options.enabled&&this.isSupportAvailable);return this.options;}setItem(key,value){if(!this.store){return;}this.store.setItem(key,value);this.length=this.store.length;}getItem(key){if(!this.store){return null;}const value=this.store.getItem(key);return isUndefined(value)?null:value;}removeItem(key){if(!this.store){return;}this.store.removeItem(key);this.length=this.store.length;}clear(){this.store?.clear();this.length=0;}key(index){return this.store?.key(index)??null;}keys(){const keys=[];if(!this.store){return keys;}for(let i=0;i<this.store.length;i+=1){const key=this.store.key(i);if(key!==null){keys.push(key);}}return keys;}}const defaultSessionStorage=new SessionStorage(defaultLogger);\n\n/**\n * A storage utility to persist values in cookies via Storage interface\n */class CookieStorage{isSupportAvailable=true;isEnabled=true;length=0;constructor(logger){this.logger=logger;}configure(options){if(!this.options){this.options=getDefaultCookieOptions();}this.options=mergeDeepRight(this.options,options??{});if(this.options.sameDomainCookiesOnly){delete this.options.domain;}this.isSupportAvailable=isStorageAvailable(COOKIE_STORAGE,this);this.isEnabled=Boolean(this.options.enabled&&this.isSupportAvailable);return this.options;}setItem(key,value){cookie(key,value,this.options,this.logger);this.length=Object.keys(cookie()).length;return true;}// eslint-disable-next-line class-methods-use-this\ngetItem(key){const value=cookie(key);return isUndefined(value)?null:value;}removeItem(key){const result=this.setItem(key,null);this.length=Object.keys(cookie()).length;return result;}// eslint-disable-next-line class-methods-use-this\nclear(){// Not implemented\n// getting a list of all cookie storage keys and remove all values\n// sounds risky to do as it will take on all top domain cookies\n// better to explicitly clear specific ones if needed\n}key(index){const curKeys=this.keys();return curKeys[index]??null;}// eslint-disable-next-line class-methods-use-this\nkeys(){return Object.keys(cookie());}}const defaultCookieStorage=new CookieStorage(defaultLogger);\n\n/**\n * A utility to retrieve the storage singleton instance by type\n */const getStorageEngine=type=>{switch(type){case LOCAL_STORAGE:return defaultLocalStorage;case SESSION_STORAGE:return defaultSessionStorage;case MEMORY_STORAGE:return defaultInMemoryStorage;case COOKIE_STORAGE:return defaultCookieStorage;default:return defaultInMemoryStorage;}};/**\n * Configure cookie storage singleton\n */const configureCookieStorageEngine=options=>{const cookieStorageOptions=defaultCookieStorage.configure(options);// Update the state with the final cookie storage options\nstate.storage.cookie.value={maxage:cookieStorageOptions.maxage,path:cookieStorageOptions.path,domain:cookieStorageOptions.domain,samesite:cookieStorageOptions.samesite,expires:cookieStorageOptions.expires,secure:cookieStorageOptions.secure};};/**\n * Configure local storage singleton\n */const configureLocalStorageEngine=options=>{defaultLocalStorage.configure(options);};/**\n * Configure in memory storage singleton\n */const configureInMemoryStorageEngine=options=>{defaultInMemoryStorage.configure(options);};/**\n * Configure session storage singleton\n */const configureSessionStorageEngine=options=>{defaultSessionStorage.configure(options);};/**\n * Configure all storage singleton instances\n */const configureStorageEngines=(cookieStorageOptions={},localStorageOptions={},inMemoryStorageOptions={},sessionStorageOptions={})=>{configureCookieStorageEngine(cookieStorageOptions);configureLocalStorageEngine(localStorageOptions);configureInMemoryStorageEngine(inMemoryStorageOptions);configureSessionStorageEngine(sessionStorageOptions);};\n\n/**\n * Store Implementation with dedicated storage\n */class Store{constructor(config,engine,pluginsManager){this.id=config.id;this.name=config.name;this.isEncrypted=config.isEncrypted??false;this.validKeys=config.validKeys??{};this.engine=engine;this.noKeyValidation=Object.keys(this.validKeys).length===0;this.noCompoundKey=config.noCompoundKey;this.originalEngine=this.engine;this.errorHandler=config.errorHandler;this.logger=config.logger;this.pluginsManager=pluginsManager;}/**\n   * Ensure the key is valid and with correct format\n   */createValidKey(key){const{name,id,validKeys,noKeyValidation,noCompoundKey}=this;if(noKeyValidation){return noCompoundKey?key:[name,id,key].join('.');}// validate and return undefined if invalid key\nlet compoundKey;Object.values(validKeys).forEach(validKeyName=>{if(validKeyName===key){compoundKey=noCompoundKey?key:[name,id,key].join('.');}});return compoundKey;}/**\n   * Switch to inMemoryEngine, bringing any existing data with.\n   */swapQueueStoreToInMemoryEngine(){const{name,id,validKeys,noCompoundKey}=this;const inMemoryStorage=getStorageEngine(MEMORY_STORAGE);// grab existing data, but only for this page's queue instance, not all\n// better to keep other queues in localstorage to be flushed later\n// than to pull them into memory and remove them from durable storage\nObject.keys(validKeys).forEach(key=>{const value=this.get(validKeys[key]);const validKey=noCompoundKey?key:[name,id,key].join('.');inMemoryStorage.setItem(validKey,value);// TODO: are we sure we want to drop clientData\n//  if cookies are not available and localstorage is full?\nthis.remove(key);});this.engine=inMemoryStorage;}/**\n   * Set value by key.\n   */set(key,value){const validKey=this.createValidKey(key);if(!validKey){return;}try{// storejs that is used in localstorage engine already stringifies json\nthis.engine.setItem(validKey,this.encrypt(stringifyWithoutCircular(value,false,[],this.logger)));}catch(err){if(isStorageQuotaExceeded(err)){this.logger.warn(STORAGE_QUOTA_EXCEEDED_WARNING(`Store ${this.id}`));// switch to inMemory engine\nthis.swapQueueStoreToInMemoryEngine();// and save it there\nthis.set(key,value);}else {const customMessage=STORE_DATA_SAVE_ERROR(key);this.onError(err,customMessage,customMessage);}}}/**\n   * Get by Key.\n   */get(key){const validKey=this.createValidKey(key);let decryptedValue;try{if(!validKey){return null;}decryptedValue=this.decrypt(this.engine.getItem(validKey));if(isNullOrUndefined(decryptedValue)||decryptedValue===''){return null;}// storejs that is used in localstorage engine already deserializes json strings but swallows errors\nreturn JSON.parse(decryptedValue);}catch(err){const customMessage=STORE_DATA_FETCH_ERROR(key);this.onError(err,customMessage,customMessage);return null;}}/**\n   * Remove by Key.\n   */remove(key){const validKey=this.createValidKey(key);if(validKey){this.engine.removeItem(validKey);}}/**\n   * Get original engine\n   */getOriginalEngine(){return this.originalEngine;}/**\n   * Decrypt values\n   */decrypt(value){if(isNullOrUndefined(value)){return null;}return this.crypto(value,'decrypt');}/**\n   * Encrypt value\n   */encrypt(value){return this.crypto(value,'encrypt');}/**\n   * Extension point to use with encryption plugins\n   */crypto(value,mode){const noEncryption=!this.isEncrypted||!value||typeof value!=='string'||trim(value)==='';if(noEncryption){return value;}const extensionPointName=`storage.${mode}`;const formattedValue=this.pluginsManager?this.pluginsManager.invokeSingle(extensionPointName,value):value;return typeof formattedValue==='undefined'?value:formattedValue??'';}/**\n   * Handle errors\n   */onError(error,customMessage,groupingHash){this.errorHandler.onError({error,context:`Store ${this.id}`,customMessage,groupingHash});}}\n\nconst getStorageTypeFromPreConsentIfApplicable=(state,sessionKey)=>{let overriddenStorageType;if(state.consents.preConsent.value.enabled){switch(state.consents.preConsent.value.storage?.strategy){case 'none':overriddenStorageType=NO_STORAGE;break;case 'session':if(sessionKey!=='sessionInfo'){overriddenStorageType=NO_STORAGE;}break;case 'anonymousId':if(sessionKey!=='anonymousId'){overriddenStorageType=NO_STORAGE;}break;}}return overriddenStorageType;};\n\n/**\n * A service to manage stores & available storage client configurations\n */class StoreManager{stores={};isInitialized=false;constructor(pluginsManager,errorHandler,logger){this.errorHandler=errorHandler;this.logger=logger;this.pluginsManager=pluginsManager;}/**\n   * Configure available storage client instances\n   */init(){if(this.isInitialized){return;}const loadOptions=state.loadOptions.value;const config={cookieStorageOptions:{samesite:loadOptions.sameSiteCookie,secure:loadOptions.secureCookie,domain:loadOptions.setCookieDomain,sameDomainCookiesOnly:loadOptions.sameDomainCookiesOnly},localStorageOptions:{},inMemoryStorageOptions:{},sessionStorageOptions:{}};configureStorageEngines(removeUndefinedValues(mergeDeepRight(config.cookieStorageOptions??{},state.storage.cookie?.value??{})),removeUndefinedValues(config.localStorageOptions),removeUndefinedValues(config.inMemoryStorageOptions),removeUndefinedValues(config.sessionStorageOptions));this.initClientDataStores();this.isInitialized=true;}/**\n   * Create store to persist data used by the SDK like session, used details etc\n   */initClientDataStores(){this.initializeStorageState();// TODO: fill in extra config values and bring them in from StoreManagerOptions if needed\n// TODO: should we pass the keys for all in order to validate or leave free as v1.1?\n// Initializing all the enabled store because previous user data might be in different storage\n// that needs auto migration\nconst storageTypes=[MEMORY_STORAGE,LOCAL_STORAGE,COOKIE_STORAGE,SESSION_STORAGE];storageTypes.forEach(storageType=>{if(getStorageEngine(storageType)?.isEnabled){this.setStore({id:storageClientDataStoreNameMap[storageType],name:storageClientDataStoreNameMap[storageType],isEncrypted:true,noCompoundKey:true,type:storageType,errorHandler:this.errorHandler,logger:this.logger});}});}initializeStorageState(){let globalStorageType=state.storage.type.value;let entriesOptions=state.loadOptions.value.storage?.entries;// Use the storage options from post consent if anything is defined\nconst postConsentStorageOpts=state.consents.postConsent.value.storage;if(isDefined(postConsentStorageOpts?.type)||isDefined(postConsentStorageOpts?.entries)){globalStorageType=postConsentStorageOpts?.type;entriesOptions=postConsentStorageOpts?.entries;}let trulyAnonymousTracking=true;let storageEntries={};USER_SESSION_KEYS.forEach(sessionKey=>{const key=sessionKey;const storageKey=sessionKey;const configuredStorageType=entriesOptions?.[key]?.type;const preConsentStorageType=getStorageTypeFromPreConsentIfApplicable(state,sessionKey);// Storage type precedence order: pre-consent strategy > entry type > global type > default\nconst storageType=preConsentStorageType??configuredStorageType??globalStorageType??DEFAULT_STORAGE_TYPE;const finalStorageType=this.getResolvedStorageTypeForEntry(storageType,sessionKey);if(finalStorageType!==NO_STORAGE){trulyAnonymousTracking=false;}storageEntries={...storageEntries,[sessionKey]:{type:finalStorageType,key:COOKIE_KEYS[storageKey]}};});r(()=>{state.storage.type.value=globalStorageType;state.storage.entries.value=storageEntries;state.storage.trulyAnonymousTracking.value=trulyAnonymousTracking;});}getResolvedStorageTypeForEntry(storageType,sessionKey){let finalStorageType=storageType;switch(storageType){case LOCAL_STORAGE:if(!getStorageEngine(LOCAL_STORAGE)?.isEnabled){finalStorageType=MEMORY_STORAGE;}break;case SESSION_STORAGE:if(!getStorageEngine(SESSION_STORAGE)?.isEnabled){finalStorageType=MEMORY_STORAGE;}break;case MEMORY_STORAGE:case NO_STORAGE:break;case COOKIE_STORAGE:default:// First try setting the storage to cookie else to local storage\nif(getStorageEngine(COOKIE_STORAGE)?.isEnabled){finalStorageType=COOKIE_STORAGE;}else if(getStorageEngine(LOCAL_STORAGE)?.isEnabled){finalStorageType=LOCAL_STORAGE;}else if(getStorageEngine(SESSION_STORAGE)?.isEnabled){finalStorageType=SESSION_STORAGE;}else {finalStorageType=MEMORY_STORAGE;}break;}if(finalStorageType!==storageType){this.logger.warn(STORAGE_UNAVAILABLE_WARNING(STORE_MANAGER,sessionKey,storageType,finalStorageType));}return finalStorageType;}/**\n   * Create a new store\n   */setStore(storeConfig){const storageEngine=getStorageEngine(storeConfig.type);this.stores[storeConfig.id]=new Store(storeConfig,storageEngine,this.pluginsManager);return this.stores[storeConfig.id];}/**\n   * Retrieve a store\n   */getStore(id){return this.stores[id];}}\n\nconst isValidSourceConfig=res=>isObjectLiteralAndNotNull(res)&&isObjectLiteralAndNotNull(res.source)&&!isNullOrUndefined(res.source.id)&&isObjectLiteralAndNotNull(res.source.config)&&Array.isArray(res.source.destinations);const isValidStorageType=storageType=>typeof storageType==='string'&&SUPPORTED_STORAGE_TYPES.includes(storageType);const getTopDomain=url=>{// Create a URL object\nconst urlObj=new URL(url);// Extract the host and protocol\nconst{host,protocol}=urlObj;// Split the host into parts\nconst parts=host.split('.');let topDomain;// Handle different cases, especially for co.uk or similar TLDs\nif(parts.length>2){// Join the last two parts for the top-level domain\ntopDomain=`${parts[parts.length-2]}.${parts[parts.length-1]}`;}else {// If only two parts or less, return as it is\ntopDomain=host;}return {topDomain,protocol};};const getTopDomainUrl=url=>{const{topDomain,protocol}=getTopDomain(url);return `${protocol}//${topDomain}`;};const getDataServiceUrl=(endpoint,useExactDomain)=>{const url=useExactDomain?window.location.origin:getTopDomainUrl(window.location.href);const formattedEndpoint=endpoint.startsWith('/')?endpoint.substring(1):endpoint;return `${url}/${formattedEndpoint}`;};const isWebpageTopLevelDomain=providedDomain=>{const{topDomain}=getTopDomain(window.location.href);return topDomain===providedDomain;};\n\n/**\n * Removes trailing slash from url\n * @param url\n * @returns url\n */const removeTrailingSlashes=url=>url?.endsWith('/')?removeTrailingSlashes(url.substring(0,url.length-1)):url;const getDomain=url=>{try{const urlObj=new URL(url);return urlObj.host;}catch(error){return null;}};/**\n * Get the referring domain from the referrer URL\n * @param referrer Page referrer\n * @returns Page referring domain\n */const getReferringDomain=referrer=>getDomain(referrer)??'';/**\n * Extracts UTM parameters from the URL\n * @param url Page URL\n * @returns UTM parameters\n */const extractUTMParameters=url=>{const result={};try{const urlObj=new URL(url);const UTM_PREFIX='utm_';urlObj.searchParams.forEach((value,sParam)=>{if(sParam.startsWith(UTM_PREFIX)){let utmParam=sParam.substring(UTM_PREFIX.length);// Not sure why we're doing this\nif(utmParam==='campaign'){utmParam='name';}result[utmParam]=value;}});}catch(error){// Do nothing\n}return result;};/**\n * To get the URL until the hash\n * @param url The input URL\n * @returns URL until the hash\n */const getUrlWithoutHash=url=>{let urlWithoutHash=url;try{const urlObj=new URL(url);urlWithoutHash=urlObj.origin+urlObj.pathname+urlObj.search;}catch(error){// Do nothing\n}return urlWithoutHash;};\n\nconst removeDuplicateSlashes=str=>str.replace(/\\/{2,}/g,'/');/**\n * Checks if provided url is valid or not\n * @param url\n * @returns true if `url` is valid and false otherwise\n */const isValidURL=url=>{if(!isString(url)){return false;}try{// If URL is supported by the browser, we can use it to validate the URL\n// Otherwise, we can at least check if the URL matches the pattern\nif(isFunction(globalThis.URL)){// eslint-disable-next-line no-new\nnew URL(url);}return URL_PATTERN.test(url);}catch(e){return false;}};\n\nconst DEFAULT_PRE_CONSENT_STORAGE_STRATEGY='none';const DEFAULT_PRE_CONSENT_EVENTS_DELIVERY_TYPE='immediate';\n\nconst isErrorReportingEnabled=sourceConfig=>sourceConfig?.statsCollection?.errors?.enabled===true;const isMetricsReportingEnabled=sourceConfig=>sourceConfig?.statsCollection?.metrics?.enabled===true;\n\n/**\n * Validates and normalizes the consent options provided by the user\n * @param options Consent options provided by the user\n * @returns Validated and normalized consent options\n */const getValidPostConsentOptions=options=>{const validOptions={sendPageEvent:false,trackConsent:false,discardPreConsentEvents:false};if(isObjectLiteralAndNotNull(options)){const clonedOptions=clone(options);validOptions.storage=clonedOptions.storage;if(isNonEmptyObject(clonedOptions.integrations)){validOptions.integrations=clonedOptions.integrations;}validOptions.discardPreConsentEvents=clonedOptions.discardPreConsentEvents===true;validOptions.sendPageEvent=clonedOptions.sendPageEvent===true;validOptions.trackConsent=clonedOptions.trackConsent===true;if(isNonEmptyObject(clonedOptions.consentManagement)){// Override enabled value with the current state value\nvalidOptions.consentManagement=mergeDeepRight(clonedOptions.consentManagement,{enabled:state.consents.enabled.value});}}return validOptions;};/**\n * Validates if the input is a valid consents data\n * @param value Input consents data\n * @returns true if the input is a valid consents data else false\n */const isValidConsentsData=value=>isNonEmptyObject(value)||Array.isArray(value);/**\n * Retrieves the corresponding provider and plugin name of the selected consent manager from the supported consent managers\n * @param consentManagementOpts consent management options\n * @param logger logger instance\n * @returns Corresponding provider and plugin name of the selected consent manager from the supported consent managers\n */const getConsentManagerInfo=(consentManagementOpts,logger)=>{let{provider}=consentManagementOpts;const consentManagerPluginName=provider?ConsentManagersToPluginNameMap[provider]:undefined;if(provider&&!consentManagerPluginName){logger.error(UNSUPPORTED_CONSENT_MANAGER_ERROR(CONFIG_MANAGER,provider,ConsentManagersToPluginNameMap));// Reset the provider value\nprovider=undefined;}return {provider,consentManagerPluginName};};/**\n * Validates and converts the consent management options into a normalized format\n * @param consentManagementOpts Consent management options provided by the user\n * @param logger logger instance\n * @returns An object containing the consent manager plugin name, initialized, enabled and consents data\n */const getConsentManagementData=(consentManagementOpts,logger)=>{let consentManagerPluginName;let allowedConsentIds=[];let deniedConsentIds=[];let initialized=false;let provider;let enabled=consentManagementOpts?.enabled===true;if(isNonEmptyObject(consentManagementOpts)&&enabled){// Get the corresponding plugin name of the selected consent manager from the supported consent managers\n({provider,consentManagerPluginName}=getConsentManagerInfo(consentManagementOpts,logger));if(isValidConsentsData(consentManagementOpts.allowedConsentIds)){allowedConsentIds=consentManagementOpts.allowedConsentIds;initialized=true;}if(isValidConsentsData(consentManagementOpts.deniedConsentIds)){deniedConsentIds=consentManagementOpts.deniedConsentIds;initialized=true;}}const consentsData={allowedConsentIds,deniedConsentIds};// Enable consent management only if consent manager is supported\nenabled=enabled&&Boolean(consentManagerPluginName);return {provider,consentManagerPluginName,initialized,enabled,consentsData};};\n\n/**\n * Determines the SDK URL\n * @returns sdkURL\n */const getSDKUrl=()=>{// First try the new method of getting the SDK URL\n// from the script tag\nconst scriptTag=document.querySelector('script[data-rsa-write-key]');if(scriptTag&&scriptTag.dataset.rsaWriteKey===state.lifecycle.writeKey.value){return scriptTag.src;}// If the new method fails, try the old method\n// TODO: We need to remove this once all the customers upgrade to the\n// latest SDK loading snippet\nconst scripts=document.getElementsByTagName('script');const sdkFileNameRegex=/(?:^|\\/)rsa(\\.min)?\\.js$/;// eslint-disable-next-line no-restricted-syntax\nfor(const script of scripts){const src=script.getAttribute('src');if(src&&sdkFileNameRegex.test(src)){return src;}}return undefined;};/**\n * Updates the reporting state variables from the source config data\n * @param res Source config\n * @param logger Logger instance\n */const updateReportingState=res=>{state.reporting.isErrorReportingEnabled.value=isErrorReportingEnabled(res.source.config)&&!isSDKRunningInChromeExtension();state.reporting.isMetricsReportingEnabled.value=isMetricsReportingEnabled(res.source.config);};const getServerSideCookiesStateData=logger=>{const{useServerSideCookies,dataServiceEndpoint,storage:storageOptsFromLoad,setCookieDomain,sameDomainCookiesOnly}=state.loadOptions.value;let cookieOptions=storageOptsFromLoad?.cookie;let sscEnabled=false;let finalDataServiceUrl;if(useServerSideCookies){sscEnabled=useServerSideCookies;const providedCookieDomain=cookieOptions.domain??setCookieDomain;/**\n     * Based on the following conditions, we decide whether to use the exact domain or not to determine the data service URL:\n     * 1. If the cookie domain is provided and it is not a top-level domain, then use the exact domain\n     * 2. If the sameDomainCookiesOnly flag is set to true, then use the exact domain\n     */const useExactDomain=isDefined(providedCookieDomain)&&!isWebpageTopLevelDomain(removeLeadingPeriod(providedCookieDomain))||sameDomainCookiesOnly;const dataServiceUrl=getDataServiceUrl(dataServiceEndpoint??DEFAULT_DATA_SERVICE_ENDPOINT,useExactDomain);if(isValidURL(dataServiceUrl)){finalDataServiceUrl=removeTrailingSlashes(dataServiceUrl);const curHost=getDomain(window.location.href);const dataServiceHost=getDomain(dataServiceUrl);// If the current host is different from the data service host, then it is a cross-site request\n// For server-side cookies to work, we need to set the SameSite=None and Secure attributes\n// One round of cookie options manipulation is taking place here\n// Based on these(setCookieDomain/storage.cookie or sameDomainCookiesOnly) two load-options, final cookie options are set in the storage module\n// TODO: Refactor the cookie options manipulation logic in one place\nif(curHost!==dataServiceHost){cookieOptions={...cookieOptions,samesite:'None',secure:true};}/**\n       * If the sameDomainCookiesOnly flag is not set and the cookie domain is provided(not top level domain),\n       * and the data service host is different from the provided cookie domain, then we disable server-side cookies\n       * ex: provided cookie domain: 'random.com', data service host: 'sub.example.com'\n       */if(!sameDomainCookiesOnly&&useExactDomain&&dataServiceHost!==removeLeadingPeriod(providedCookieDomain)){sscEnabled=false;logger.warn(SERVER_SIDE_COOKIE_FEATURE_OVERRIDE_WARNING(CONFIG_MANAGER,providedCookieDomain,dataServiceHost));}}else {sscEnabled=false;}}return {sscEnabled,cookieOptions,finalDataServiceUrl};};const updateStorageStateFromLoadOptions=logger=>{const{storage:storageOptsFromLoad}=state.loadOptions.value;let storageType=storageOptsFromLoad?.type;if(isDefined(storageType)&&!isValidStorageType(storageType)){logger.warn(STORAGE_TYPE_VALIDATION_WARNING(CONFIG_MANAGER,storageType,DEFAULT_STORAGE_TYPE));storageType=DEFAULT_STORAGE_TYPE;}let storageEncryptionVersion=storageOptsFromLoad?.encryption?.version;const encryptionPluginName=storageEncryptionVersion&&StorageEncryptionVersionsToPluginNameMap[storageEncryptionVersion];if(!isUndefined(storageEncryptionVersion)&&isUndefined(encryptionPluginName)){// set the default encryption plugin\nlogger.warn(UNSUPPORTED_STORAGE_ENCRYPTION_VERSION_WARNING(CONFIG_MANAGER,storageEncryptionVersion,StorageEncryptionVersionsToPluginNameMap,DEFAULT_STORAGE_ENCRYPTION_VERSION));storageEncryptionVersion=DEFAULT_STORAGE_ENCRYPTION_VERSION;}else if(isUndefined(storageEncryptionVersion)){storageEncryptionVersion=DEFAULT_STORAGE_ENCRYPTION_VERSION;}// Allow migration only if the configured encryption version is the default encryption version\nconst configuredMigrationValue=storageOptsFromLoad?.migrate;const finalMigrationVal=configuredMigrationValue&&storageEncryptionVersion===DEFAULT_STORAGE_ENCRYPTION_VERSION;if(configuredMigrationValue===true&&finalMigrationVal!==configuredMigrationValue){logger.warn(STORAGE_DATA_MIGRATION_OVERRIDE_WARNING(CONFIG_MANAGER,storageEncryptionVersion,DEFAULT_STORAGE_ENCRYPTION_VERSION));}const{sscEnabled,finalDataServiceUrl,cookieOptions}=getServerSideCookiesStateData(logger);r(()=>{state.storage.type.value=storageType;state.storage.cookie.value=cookieOptions;state.serverCookies.isEnabledServerSideCookies.value=sscEnabled;state.serverCookies.dataServiceUrl.value=finalDataServiceUrl;state.storage.encryptionPluginName.value=StorageEncryptionVersionsToPluginNameMap[storageEncryptionVersion];state.storage.migrate.value=finalMigrationVal;});};const updateConsentsStateFromLoadOptions=logger=>{const{provider,consentManagerPluginName,initialized,enabled,consentsData}=getConsentManagementData(state.loadOptions.value.consentManagement,logger);// Pre-consent\nconst preConsentOpts=state.loadOptions.value.preConsent;let storageStrategy=preConsentOpts?.storage?.strategy??DEFAULT_PRE_CONSENT_STORAGE_STRATEGY;const StorageStrategies=['none','session','anonymousId'];if(isDefined(storageStrategy)&&!StorageStrategies.includes(storageStrategy)){storageStrategy=DEFAULT_PRE_CONSENT_STORAGE_STRATEGY;logger.warn(UNSUPPORTED_PRE_CONSENT_STORAGE_STRATEGY(CONFIG_MANAGER,preConsentOpts?.storage?.strategy,DEFAULT_PRE_CONSENT_STORAGE_STRATEGY));}let eventsDeliveryType=preConsentOpts?.events?.delivery??DEFAULT_PRE_CONSENT_EVENTS_DELIVERY_TYPE;const deliveryTypes=['immediate','buffer'];if(isDefined(eventsDeliveryType)&&!deliveryTypes.includes(eventsDeliveryType)){eventsDeliveryType=DEFAULT_PRE_CONSENT_EVENTS_DELIVERY_TYPE;logger.warn(UNSUPPORTED_PRE_CONSENT_EVENTS_DELIVERY_TYPE(CONFIG_MANAGER,preConsentOpts?.events?.delivery,DEFAULT_PRE_CONSENT_EVENTS_DELIVERY_TYPE));}r(()=>{state.consents.activeConsentManagerPluginName.value=consentManagerPluginName;state.consents.initialized.value=initialized;state.consents.enabled.value=enabled;state.consents.data.value=consentsData;state.consents.provider.value=provider;state.consents.preConsent.value={// Only enable pre-consent if it is explicitly enabled and\n// if it is not already initialized and\n// if consent management is enabled\nenabled:state.loadOptions.value.preConsent?.enabled===true&&initialized===false&&enabled===true,storage:{strategy:storageStrategy},events:{delivery:eventsDeliveryType}};});};/**\n * Determines the consent management state variables from the source config data\n * @param resp Source config response\n * @param logger Logger instance\n */const updateConsentsState=resp=>{let resolutionStrategy=state.consents.resolutionStrategy.value;let cmpMetadata;if(isObjectLiteralAndNotNull(resp.consentManagementMetadata)){if(state.consents.provider.value){resolutionStrategy=resp.consentManagementMetadata.providers.find(p=>p.provider===state.consents.provider.value)?.resolutionStrategy??state.consents.resolutionStrategy.value;}cmpMetadata=resp.consentManagementMetadata;}// If the provider is custom, then the resolution strategy is not applicable\nif(state.consents.provider.value==='custom'){resolutionStrategy=undefined;}r(()=>{state.consents.metadata.value=clone(cmpMetadata);state.consents.resolutionStrategy.value=resolutionStrategy;});};const updateDataPlaneEventsStateFromLoadOptions=logger=>{if(state.dataPlaneEvents.deliveryEnabled.value){const defaultEventsQueuePluginName='XhrQueue';let eventsQueuePluginName=defaultEventsQueuePluginName;if(state.loadOptions.value.useBeacon){if(state.capabilities.isBeaconAvailable.value){eventsQueuePluginName='BeaconQueue';}else {eventsQueuePluginName=defaultEventsQueuePluginName;logger.warn(UNSUPPORTED_BEACON_API_WARNING(CONFIG_MANAGER));}}r(()=>{state.dataPlaneEvents.eventsQueuePluginName.value=eventsQueuePluginName;});}};const getSourceConfigURL=(configUrl,writeKey,lockIntegrationsVersion,lockPluginsVersion,logger)=>{const defSearchParams=new URLSearchParams({p:MODULE_TYPE,v:APP_VERSION,build:BUILD_TYPE,writeKey,lockIntegrationsVersion:lockIntegrationsVersion.toString(),lockPluginsVersion:lockPluginsVersion.toString()});let origin=DEFAULT_CONFIG_BE_URL;let searchParams=defSearchParams;let pathname='/sourceConfig/';let hash='';if(isValidURL(configUrl)){const configUrlInstance=new URL(configUrl);if(!removeTrailingSlashes(configUrlInstance.pathname).endsWith('/sourceConfig')){configUrlInstance.pathname=`${removeTrailingSlashes(configUrlInstance.pathname)}/sourceConfig/`;}configUrlInstance.pathname=removeDuplicateSlashes(configUrlInstance.pathname);defSearchParams.forEach((value,key)=>{if(configUrlInstance.searchParams.get(key)===null){configUrlInstance.searchParams.set(key,value);}});origin=configUrlInstance.origin;pathname=configUrlInstance.pathname;searchParams=configUrlInstance.searchParams;hash=configUrlInstance.hash;}else {logger.warn(INVALID_CONFIG_URL_WARNING(CONFIG_MANAGER,configUrl));}return `${origin}${pathname}?${searchParams}${hash}`;};/**\n * Transforms destinations config from source config response to Destination format\n * @param destinations Array of destination items from config response\n * @returns Array of transformed Destination objects\n */const getDestinationsFromConfig=destinations=>destinations.map(destination=>({id:destination.id,displayName:destination.destinationDefinition.displayName,enabled:destination.enabled,config:destination.config,shouldApplyDeviceModeTransformation:destination.shouldApplyDeviceModeTransformation??false,propagateEventsUntransformedOnError:destination.propagateEventsUntransformedOnError??false,userFriendlyId:getDestinationUserFriendlyId(destination.destinationDefinition.displayName,destination.id),isCustomIntegration:destination.destinationDefinition.displayName===CUSTOM_DEVICE_MODE_DESTINATION_DISPLAY_NAME}));\n\n/**\n * A function that determines the base URL for the integrations or plugins SDK\n * @param componentType The type of the component (integrations or plugins)\n * @param pathSuffix The path suffix to be appended to the base URL (js-integrations or plugins)\n * @param defaultComponentUrl The default URL to be used if the user has not provided a custom URL\n * @param currentSdkVersion The current version of the SDK\n * @param lockVersion Flag to lock the version of the component\n * @param urlFromLoadOptions The URL provided by the user in the load options\n * @param logger Logger instance\n * @returns The base URL for the integrations or plugins SDK\n */const getSDKComponentBaseURL=(componentType,pathSuffix,defaultComponentUrl,currentSdkVersion,lockVersion,urlFromLoadOptions,logger)=>{let sdkComponentBaseURL;// If the user has provided a custom URL, then validate, clean up and use it\nif(urlFromLoadOptions){if(!isValidURL(urlFromLoadOptions)){logger.error(COMPONENT_BASE_URL_ERROR(CONFIG_MANAGER,componentType,urlFromLoadOptions));return null;}sdkComponentBaseURL=removeTrailingSlashes(urlFromLoadOptions);}else {sdkComponentBaseURL=defaultComponentUrl;// We can automatically determine the base URL only for CDN installations\nif(state.context.app.value.installType==='cdn'){const sdkURL=getSDKUrl();if(sdkURL){// Extract the base URL from the core SDK file URL\n// and append the path suffix to it\nsdkComponentBaseURL=sdkURL.split('/').slice(0,-1).concat(pathSuffix).join('/');}}}// If the version needs to be locked, then replace the major version in the URL\n// with the current version of the SDK\nif(lockVersion){sdkComponentBaseURL=sdkComponentBaseURL.replace(new RegExp(`/${CDN_ARCH_VERSION_DIR}/${BUILD_TYPE}/${pathSuffix}$`),`/${currentSdkVersion}/${BUILD_TYPE}/${pathSuffix}`);}return sdkComponentBaseURL;};/**\n * A function that determines integration SDK loading path\n * @param currentSdkVersion Current SDK version\n * @param lockIntegrationsVersion Flag to lock the integrations version\n * @param integrationsUrlFromLoadOptions URL to load the integrations from as provided by the user\n * @param logger Logger instance\n * @returns\n */const getIntegrationsCDNPath=(currentSdkVersion,lockIntegrationsVersion,integrationsUrlFromLoadOptions,logger)=>getSDKComponentBaseURL('integrations',CDN_INT_DIR,DEFAULT_INTEGRATION_SDKS_URL,currentSdkVersion,lockIntegrationsVersion,integrationsUrlFromLoadOptions,logger);/**\n * A function that determines plugins SDK loading path\n * @param currentSdkVersion Current SDK version\n * @param lockPluginsVersion Flag to lock the plugins version\n * @param pluginsUrlFromLoadOptions URL to load the plugins from as provided by the user\n * @param logger Logger instance\n * @returns Final plugins CDN path\n */const getPluginsCDNPath=(currentSdkVersion,lockPluginsVersion,pluginsUrlFromLoadOptions,logger)=>getSDKComponentBaseURL('plugins',CDN_PLUGINS_DIR,DEFAULT_PLUGINS_URL,currentSdkVersion,lockPluginsVersion,pluginsUrlFromLoadOptions,logger);\n\nclass ConfigManager{constructor(httpClient,errorHandler,logger){this.errorHandler=errorHandler;this.logger=logger;this.httpClient=httpClient;this.onError=this.onError.bind(this);this.processConfig=this.processConfig.bind(this);}attachEffects(){E(()=>{this.logger.setMinLogLevel(state.lifecycle.logLevel.value);});}/**\n   * A function to validate, construct and store loadOption, lifecycle, source and destination\n   * config related information in global state\n   */init(){const{logLevel,configUrl,lockIntegrationsVersion,lockPluginsVersion,destSDKBaseURL,pluginsSDKBaseURL,integrations}=state.loadOptions.value;// determine the path to fetch integration SDK from\nconst intgCdnUrl=getIntegrationsCDNPath(APP_VERSION,lockIntegrationsVersion,destSDKBaseURL,this.logger);if(isNull(intgCdnUrl)){return;}let pluginsCDNPath;{// determine the path to fetch remote plugins from\npluginsCDNPath=getPluginsCDNPath(APP_VERSION,lockPluginsVersion,pluginsSDKBaseURL,this.logger);}if(pluginsCDNPath===null){return;}this.attachEffects();state.lifecycle.activeDataplaneUrl.value=removeTrailingSlashes(state.lifecycle.dataPlaneUrl.value);updateStorageStateFromLoadOptions(this.logger);updateConsentsStateFromLoadOptions(this.logger);updateDataPlaneEventsStateFromLoadOptions(this.logger);// set application lifecycle state in global state\nr(()=>{state.lifecycle.integrationsCDNPath.value=intgCdnUrl;state.lifecycle.pluginsCDNPath.value=pluginsCDNPath;if(logLevel){state.lifecycle.logLevel.value=logLevel;}state.lifecycle.sourceConfigUrl.value=getSourceConfigURL(configUrl,state.lifecycle.writeKey.value,lockIntegrationsVersion,lockPluginsVersion,this.logger);state.metrics.metricsServiceUrl.value=`${state.lifecycle.activeDataplaneUrl.value}/${METRICS_SERVICE_ENDPOINT}`;// Data in the loadOptions state is already normalized\nstate.nativeDestinations.loadOnlyIntegrations.value=integrations;});this.getConfig();}/**\n   * Handle errors\n   */onError(error,customMessage,groupingHash){this.errorHandler.onError({error,context:CONFIG_MANAGER,customMessage,groupingHash});}/**\n   * A callback function that is executed once we fetch the source config response.\n   * Use to construct and store information that are dependent on the sourceConfig.\n   */processConfig(response,details){// TODO: add retry logic with backoff based on rejectionDetails.xhr.status\n// We can use isErrRetryable utility method\nif(!isDefined(response)){if(isDefined(details)){this.onError(details.error,SOURCE_CONFIG_FETCH_ERROR);}else {this.onError(new Error(SOURCE_CONFIG_FETCH_ERROR));}return;}let res;try{if(isString(response)){res=JSON.parse(response);}else {res=response;}}catch(err){this.onError(err,SOURCE_CONFIG_RESOLUTION_ERROR);return;}if(!isValidSourceConfig(res)){this.onError(new Error(SOURCE_CONFIG_RESOLUTION_ERROR));return;}// Log error and abort if source is disabled\nif(res.source.enabled===false){this.logger.error(SOURCE_DISABLED_ERROR);return;}// set the values in state for reporting slice\nupdateReportingState(res);const nativeDestinations=res.source.destinations.length>0?getDestinationsFromConfig(res.source.destinations):[];// set in the state --> source, destination, lifecycle, reporting\nr(()=>{// set source related information in state\nstate.source.value={config:res.source.config,name:res.source.name,id:res.source.id,workspaceId:res.source.workspaceId};// set device mode destination related information in state\nstate.nativeDestinations.configuredDestinations.value=nativeDestinations;// set the desired optional plugins\nstate.plugins.pluginsToLoadFromConfig.value=state.loadOptions.value.plugins??[];updateConsentsState(res);// set application lifecycle state\nstate.lifecycle.status.value='configured';});}/**\n   * A function to fetch source config either from /sourceConfig endpoint\n   * or from getSourceConfig load option\n   * @returns\n   */getConfig(){const sourceConfigFunc=state.loadOptions.value.getSourceConfig;if(sourceConfigFunc){if(!isFunction(sourceConfigFunc)){this.logger.error(SOURCE_CONFIG_OPTION_ERROR(CONFIG_MANAGER));return;}// Fetch source config from the function\nconst res=sourceConfigFunc();if(res instanceof Promise){res.then(pRes=>this.processConfig(pRes)).catch(err=>{this.onError(err,'SourceConfig');});}else {this.processConfig(res);}}else {// Fetch source configuration from the configured URL\nthis.httpClient.getAsyncData({url:state.lifecycle.sourceConfigUrl.value,options:{headers:{'Content-Type':undefined}},callback:this.processConfig});}}}\n\n/**\n * To get the timezone of the user\n *\n * @returns string\n */const getTimezone=()=>{// Not susceptible to super-linear backtracking\n// eslint-disable-next-line sonarjs/slow-regex\nconst timezone=/([A-Z]+[+-]\\d+)/.exec(new Date().toString());return timezone?.[1]?timezone[1]:'NA';};\n\n/**\n * Get the referrer URL\n * @returns The referrer URL\n */const getReferrer=(getDocument=()=>document)=>getDocument()?.referrer||'$direct';/**\n * To get the canonical URL of the page\n * @returns canonical URL\n */const getCanonicalUrl=(getDocument=()=>document)=>{const docInstance=getDocument();const tags=docInstance.getElementsByTagName('link');let canonicalUrl='';for(let i=0;tags[i];i+=1){const tag=tags[i];if(tag.getAttribute('rel')==='canonical'&&!canonicalUrl){canonicalUrl=tag.getAttribute('href')??'';break;}}return canonicalUrl;};const getUserAgent=(getNavigator=()=>globalThis.navigator)=>{const navigator=getNavigator();if(isUndefined(navigator)){return null;}let{userAgent}=navigator;const{brave}=navigator;// For supporting Brave browser detection,\n// add \"Brave/<version>\" to the user agent with the version value from the Chrome component\nif(brave&&Object.getPrototypeOf(brave).isBrave){// Example:\n// Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.114 Safari/537.36\nconst matchedArr=userAgent.match(/(chrome)\\/([\\w.]+)/i);if(matchedArr){userAgent=`${userAgent} Brave/${matchedArr[2]}`;}}return userAgent;};const getLanguage=(getNavigator=()=>globalThis.navigator)=>{const navigator=getNavigator();if(isUndefined(navigator)){return null;}return navigator.language??navigator.browserLanguage;};/**\n * Default page properties\n * @returns Default page properties\n */const getDefaultPageProperties=(getLocation=()=>globalThis.location,getDocument=()=>document)=>{const location=getLocation();const canonicalUrl=getCanonicalUrl(getDocument);let path=location.pathname;const{href:tabUrl}=location;let pageUrl=tabUrl;const{search}=location;// If valid canonical URL is provided use this as page URL.\nif(canonicalUrl){try{const urlObj=new URL(canonicalUrl);// If existing, query params of canonical URL will be used instead of the location.search ones\nif(urlObj.search===''){pageUrl=canonicalUrl+search;}else {pageUrl=canonicalUrl;}path=urlObj.pathname;}catch(err){// Do nothing\n}}const url=getUrlWithoutHash(pageUrl);const{title}=getDocument();const referrer=getReferrer(getDocument);return {path,referrer,referring_domain:getReferringDomain(referrer),search,title,url,tab_url:tabUrl};};\n\nconst getUserAgentClientHint=(callback,level='none')=>{if(level==='none'){callback(undefined);}if(level==='default'){callback(navigator.userAgentData);}if(level==='full'){navigator.userAgentData?.getHighEntropyValues(['architecture','bitness','brands','mobile','model','platform','platformVersion','uaFullVersion','fullVersionList','wow64']).then(ua=>{callback(ua);}).catch(()=>{callback();});}};\n\nconst isDatasetAvailable=()=>{const testElement=globalThis.document.createElement('div');testElement.setAttribute('data-a-b','c');return testElement.dataset?testElement.dataset.aB==='c':false;};const legacyJSEngineRequiredPolyfills={// Ideally, we should separate the checks for URL and URLSearchParams but\n// the polyfill service serves them under the same feature name, \"URL\".\nURL:()=>!isFunction(globalThis.URL)||!isFunction(globalThis.URLSearchParams),Promise:()=>!isFunction(globalThis.Promise),'Number.isNaN':()=>!isFunction(globalThis.Number.isNaN),'Number.isInteger':()=>!isFunction(globalThis.Number.isInteger),'Array.from':()=>!isFunction(globalThis.Array.from),'Array.prototype.find':()=>!isFunction(globalThis.Array.prototype.find),'Array.prototype.includes':()=>!isFunction(globalThis.Array.prototype.includes),'String.prototype.endsWith':()=>!isFunction(globalThis.String.prototype.endsWith),'String.prototype.startsWith':()=>!isFunction(globalThis.String.prototype.startsWith),'String.prototype.includes':()=>!isFunction(globalThis.String.prototype.includes),'String.prototype.replaceAll':()=>!isFunction(globalThis.String.prototype.replaceAll),'String.fromCodePoint':()=>!isFunction(globalThis.String.fromCodePoint),'Object.entries':()=>!isFunction(globalThis.Object.entries),'Object.values':()=>!isFunction(globalThis.Object.values),'Object.assign':()=>!isFunction(globalThis.Object.assign),'Object.fromEntries':()=>!isFunction(globalThis.Object.fromEntries),'Element.prototype.dataset':()=>!isDatasetAvailable(),// Ideally, we should separate the checks for TextEncoder and TextDecoder but\n// the polyfill service serves them under the same feature name, \"TextEncoder\".\nTextEncoder:()=>!isFunction(globalThis.TextEncoder)||!isFunction(globalThis.TextDecoder),requestAnimationFrame:()=>!isFunction(globalThis.requestAnimationFrame)||!isFunction(globalThis.cancelAnimationFrame),CustomEvent:()=>!isFunction(globalThis.CustomEvent),'navigator.sendBeacon':()=>!isFunction(globalThis.navigator.sendBeacon),// Note, the polyfill service serves both ArrayBuffer and Uint8Array under the same feature name, \"ArrayBuffer\".\nArrayBuffer:()=>!isFunction(globalThis.Uint8Array),Set:()=>!isFunction(globalThis.Set),atob:()=>!isFunction(globalThis.atob)};const isLegacyJSEngine=()=>{const requiredCapabilitiesList=Object.keys(legacyJSEngineRequiredPolyfills);let needsPolyfill=false;/* eslint-disable-next-line unicorn/no-for-loop */for(let i=0;i<requiredCapabilitiesList.length;i++){const isCapabilityMissing=legacyJSEngineRequiredPolyfills[requiredCapabilitiesList[i]];if(isFunction(isCapabilityMissing)&&isCapabilityMissing()){needsPolyfill=true;break;}}return needsPolyfill;};\n\nconst polyfillIoSdkUrl='https://polyfill-fastly.io/v3/polyfill.min.js';const POLYFILL_URL=`${polyfillIoSdkUrl}?version=3.111.0&features=${Object.keys(legacyJSEngineRequiredPolyfills).join('%2C')}`;const POLYFILL_LOAD_TIMEOUT=10*1000;// 10 seconds\nconst POLYFILL_SCRIPT_ID='rudderstackPolyfill';\n\nconst hasCrypto=()=>!isNullOrUndefined(globalThis.crypto)&&isFunction(globalThis.crypto.getRandomValues);// eslint-disable-next-line compat/compat -- We are checking for the existence of navigator.userAgentData\nconst hasUAClientHints=()=>!isNullOrUndefined(globalThis.navigator.userAgentData);const hasBeacon=()=>!isNullOrUndefined(globalThis.navigator.sendBeacon)&&isFunction(globalThis.navigator.sendBeacon);\n\nconst getScreenDetails=()=>{let screenDetails={density:0,width:0,height:0,innerWidth:0,innerHeight:0};screenDetails={width:globalThis.screen.width,height:globalThis.screen.height,density:globalThis.devicePixelRatio,innerWidth:globalThis.innerWidth,innerHeight:globalThis.innerHeight};return screenDetails;};\n\nclass CapabilitiesManager{constructor(httpClient,errorHandler,logger){this.httpClient=httpClient;this.errorHandler=errorHandler;this.logger=logger;this.externalSrcLoader=new ExternalSrcLoader(this.logger);this.onError=this.onError.bind(this);this.onReady=this.onReady.bind(this);}init(){this.prepareBrowserCapabilities();this.attachWindowListeners();}/**\n   * Detect supported capabilities and set values in state\n   */// eslint-disable-next-line class-methods-use-this\ndetectBrowserCapabilities(){r(()=>{// Storage related details\nstate.capabilities.storage.isCookieStorageAvailable.value=isStorageAvailable(COOKIE_STORAGE,getStorageEngine(COOKIE_STORAGE),this.logger);state.capabilities.storage.isLocalStorageAvailable.value=isStorageAvailable(LOCAL_STORAGE,undefined,this.logger);state.capabilities.storage.isSessionStorageAvailable.value=isStorageAvailable(SESSION_STORAGE,undefined,this.logger);// Browser feature detection details\nstate.capabilities.isBeaconAvailable.value=hasBeacon();state.capabilities.isUaCHAvailable.value=hasUAClientHints();state.capabilities.isCryptoAvailable.value=hasCrypto();state.capabilities.isIE11.value=isIE11();state.capabilities.isOnline.value=globalThis.navigator.onLine;// Get page context details\nstate.context.userAgent.value=getUserAgent();state.context.locale.value=getLanguage();state.context.screen.value=getScreenDetails();state.context.timezone.value=getTimezone();if(hasUAClientHints()){getUserAgentClientHint(uach=>{state.context['ua-ch'].value=uach;},state.loadOptions.value.uaChTrackLevel);}});// Ad blocker detection\nE(()=>{if(state.loadOptions.value.sendAdblockPage===true&&state.lifecycle.sourceConfigUrl.value!==undefined){detectAdBlockers(this.httpClient);}});}/**\n   * Detect if polyfills are required and then load script from polyfill URL\n   */prepareBrowserCapabilities(){state.capabilities.isLegacyDOM.value=isLegacyJSEngine();const customPolyfillUrl=state.loadOptions.value.polyfillURL;let polyfillUrl=POLYFILL_URL;if(isDefinedAndNotNull(customPolyfillUrl)){if(isValidURL(customPolyfillUrl)){polyfillUrl=customPolyfillUrl;}else {this.logger.warn(INVALID_POLYFILL_URL_WARNING(CAPABILITIES_MANAGER,customPolyfillUrl));}}const shouldLoadPolyfill=state.loadOptions.value.polyfillIfRequired&&state.capabilities.isLegacyDOM.value&&isValidURL(polyfillUrl);if(shouldLoadPolyfill){const isDefaultPolyfillService=polyfillUrl!==state.loadOptions.value.polyfillURL;if(isDefaultPolyfillService){// write key specific callback\n// NOTE: we're not putting this into RudderStackGlobals as providing the property path to the callback function in the polyfill URL is not possible\nconst polyfillCallbackName=`RS_polyfillCallback_${state.lifecycle.writeKey.value}`;const polyfillCallback=()=>{this.onReady();// Remove the entry from window so we don't leave room for calling it again\ndelete globalThis[polyfillCallbackName];};globalThis[polyfillCallbackName]=polyfillCallback;polyfillUrl=`${polyfillUrl}&callback=${polyfillCallbackName}`;}this.externalSrcLoader.loadJSFile({url:polyfillUrl,id:POLYFILL_SCRIPT_ID,async:true,timeout:POLYFILL_LOAD_TIMEOUT,callback:scriptId=>{if(!scriptId){this.onError(new Error(POLYFILL_SCRIPT_LOAD_ERROR(POLYFILL_SCRIPT_ID,polyfillUrl)));}else if(!isDefaultPolyfillService){this.onReady();}}});}else {this.onReady();}}/**\n   * Attach listeners to window to observe event that update capabilities state values\n   */attachWindowListeners(){globalThis.addEventListener('offline',()=>{state.capabilities.isOnline.value=false;});globalThis.addEventListener('online',()=>{state.capabilities.isOnline.value=true;});globalThis.addEventListener('resize',debounce(()=>{state.context.screen.value=getScreenDetails();},this));}/**\n   * Set the lifecycle status to next phase\n   */// eslint-disable-next-line class-methods-use-this\nonReady(){this.detectBrowserCapabilities();state.lifecycle.status.value='browserCapabilitiesReady';}/**\n   * Handles error\n   * @param error The error object\n   */onError(error,groupingHash){this.errorHandler.onError({error,context:CAPABILITIES_MANAGER,groupingHash});}}\n\nconst CHANNEL='web';// These are the top-level elements in the standard RudderStack event spec\nconst TOP_LEVEL_ELEMENTS=['integrations','anonymousId','originalTimestamp'];// Reserved elements in the context of standard RudderStack event spec\n// Typically, these elements are not allowed to be overridden by the user\nconst CONTEXT_RESERVED_ELEMENTS=['library','consentManagement','userAgent','ua-ch','screen'];// Reserved elements in the standard RudderStack event spec\nconst RESERVED_ELEMENTS=['id','anonymous_id','user_id','sent_at','timestamp','received_at','original_timestamp','event','event_text','channel','context_ip','context_request_ip','context_passed_ip','group_id','previous_id'];\n\n/**\n * A function to check given value is a number or not\n * @param num input value\n * @returns boolean\n */const isNumber=num=>typeof num==='number'&&!Number.isNaN(num);/**\n * A function to check given number has minimum length or not\n * @param minimumLength     minimum length\n * @param num               input number\n * @returns boolean\n */const hasMinLength=(minimumLength,num)=>num.toString().length>=minimumLength;/**\n * A function to check given value is a positive integer or not\n * @param num input value\n * @returns boolean\n */const isPositiveInteger=num=>isNumber(num)&&num>=0&&Number.isInteger(num);\n\nconst MIN_SESSION_ID_LENGTH=10;const isCutOffTimeExceeded=sessionInfo=>{const{cutOff}=sessionInfo;const timestamp=Date.now();return Boolean(cutOff?.enabled&&cutOff.expiresAt&&timestamp>cutOff.expiresAt);};/**\n * A function to validate whether the current auto tracking session has expired or not.\n * It checks for the current session expiry and the cut off time expiry.\n * @param sessionInfo session info\n * @returns boolean\n */const hasSessionExpired=sessionInfo=>{const isCurrentSessionExpired=Boolean(!sessionInfo.expiresAt||Date.now()>sessionInfo.expiresAt);return isCurrentSessionExpired||isCutOffTimeExceeded(sessionInfo);};/**\n * A function to generate session id\n * @returns number\n */const generateSessionId=()=>Date.now();/**\n * Function to validate user provided sessionId\n * @param {number} sessionId\n * @param logger logger\n * @returns\n */const isManualSessionIdValid=(sessionId,logger)=>{if(!sessionId||!isPositiveInteger(sessionId)||!hasMinLength(MIN_SESSION_ID_LENGTH,sessionId)){logger.warn(INVALID_SESSION_ID_WARNING(USER_SESSION_MANAGER,sessionId,MIN_SESSION_ID_LENGTH));return false;}return true;};const getCutOffExpirationTimestamp=cutOff=>{if(!cutOff?.enabled){return undefined;}return cutOff.expiresAt??(isPositiveInteger(cutOff.duration)?Date.now()+cutOff.duration:undefined);};/**\n * A function to generate new auto tracking session\n * @param sessionInfo session info\n * @returns SessionInfo\n */const generateAutoTrackingSession=sessionInfo=>{const{timeout,cutOff}=sessionInfo;const timestamp=Date.now();return {id:timestamp,// set the current timestamp\nexpiresAt:timestamp+timeout,// set the expiry time of the session\ntimeout,autoTrack:true,...(cutOff&&{cutOff})};};/**\n * A function to generate new manual tracking session\n * @param id Provided sessionId\n * @param logger Logger module\n * @returns SessionInfo\n */const generateManualTrackingSession=(id,logger)=>{const sessionId=isManualSessionIdValid(id,logger)?id:generateSessionId();return {id:sessionId,sessionStart:undefined,manualTrack:true};};const isStorageTypeValidForStoringData=storageType=>Boolean(storageType===COOKIE_STORAGE||storageType===LOCAL_STORAGE||storageType===SESSION_STORAGE||storageType===MEMORY_STORAGE);/**\n * Generate a new anonymousId\n * @returns string anonymousID\n */const generateAnonymousId=()=>generateUUID();const getFinalResetOptions=options=>{// Legacy behavior: toggle only anonymousId without mutating defaults\nif(isBoolean(options)){const{entries,...rest}=DEFAULT_RESET_OPTIONS;return {...rest,entries:{...entries,anonymousId:options}};}// Override any defaults with the user provided options\nif(isObjectLiteralAndNotNull(options)&&isObjectLiteralAndNotNull(options.entries)){return mergeDeepRight(DEFAULT_RESET_OPTIONS,options);}return {...DEFAULT_RESET_OPTIONS};};\n\n/**\n * To get the page properties for context object\n * @param pageProps Page properties\n * @returns page properties object for context\n */const getContextPageProperties=pageProps=>{// Need to get updated page details on each event as an event to notify on SPA URL changes does not seem to exist\nconst curPageProps=getDefaultPageProperties();const ctxPageProps={};Object.keys(curPageProps).forEach(key=>{ctxPageProps[key]=pageProps?.[key]||curPageProps[key];});ctxPageProps.initial_referrer=pageProps?.initial_referrer||state.session.initialReferrer.value;ctxPageProps.initial_referring_domain=pageProps?.initial_referring_domain||state.session.initialReferringDomain.value;return ctxPageProps;};/**\n * Add any missing default page properties using values from options and defaults\n * @param properties Input page properties\n * @param options API options\n */const getUpdatedPageProperties=(properties,options)=>{const optionsPageProps=options?.page||{};const pageProps=properties;// Need to get updated page details on each event as an event to notify on SPA URL changes does not seem to exist\nconst curPageProps=getDefaultPageProperties();Object.keys(curPageProps).forEach(key=>{if(isUndefined(pageProps[key])){pageProps[key]=optionsPageProps[key]||curPageProps[key];}});if(isUndefined(pageProps.initial_referrer)){pageProps.initial_referrer=optionsPageProps.initial_referrer||state.session.initialReferrer.value;}if(isUndefined(pageProps.initial_referring_domain)){pageProps.initial_referring_domain=optionsPageProps.initial_referring_domain||state.session.initialReferringDomain.value;}return pageProps;};/**\n * Utility to check for reserved keys in the input object\n * @param obj Generic object\n * @param parentKeyPath Object's parent key path\n * @param logger Logger instance\n */const checkForReservedElementsInObject=(obj,parentKeyPath,logger)=>{if(isObjectLiteralAndNotNull(obj)){Object.keys(obj).forEach(property=>{if(RESERVED_ELEMENTS.includes(property)||RESERVED_ELEMENTS.includes(property.toLowerCase())){logger.warn(RESERVED_KEYWORD_WARNING(EVENT_MANAGER,property,parentKeyPath,RESERVED_ELEMENTS));}});}};/**\n * Checks for reserved keys in traits, properties, and contextual traits\n * @param rudderEvent Generated rudder event\n * @param logger Logger instance\n */const checkForReservedElements=(rudderEvent,logger)=>{//  properties, traits, contextualTraits are either undefined or object\nconst{properties,traits,context}=rudderEvent;const{traits:contextualTraits}=context;checkForReservedElementsInObject(properties,'properties',logger);checkForReservedElementsInObject(traits,'traits',logger);checkForReservedElementsInObject(contextualTraits,'context.traits',logger);};/**\n * Overrides the top-level event properties with data from API options\n * @param rudderEvent Generated rudder event\n * @param options API options\n */const updateTopLevelEventElements=(rudderEvent,options)=>{if(options.anonymousId&&isString(options.anonymousId)){// eslint-disable-next-line no-param-reassign\nrudderEvent.anonymousId=options.anonymousId;}if(isNonEmptyObject(options.integrations)){// eslint-disable-next-line no-param-reassign\nrudderEvent.integrations=options.integrations;}if(options.originalTimestamp&&isString(options.originalTimestamp)){// eslint-disable-next-line no-param-reassign\nrudderEvent.originalTimestamp=options.originalTimestamp;}};/**\n * To merge the contextual information in API options with existing data\n * @param rudderContext Generated rudder event\n * @param options API options\n * @param logger Logger instance\n */const getMergedContext=(rudderContext,options,logger)=>{let context=rudderContext;Object.keys(options).forEach(key=>{if(!TOP_LEVEL_ELEMENTS.includes(key)&&!CONTEXT_RESERVED_ELEMENTS.includes(key)){if(key!=='context'){context=mergeDeepRight(context,{[key]:options[key]});}else if(!isUndefined(options[key])&&isObjectLiteralAndNotNull(options[key])){const tempContext={};Object.keys(options[key]).forEach(e=>{if(!CONTEXT_RESERVED_ELEMENTS.includes(e)){tempContext[e]=options[key][e];}});context=mergeDeepRight(context,{...tempContext});}else {logger.warn(INVALID_CONTEXT_OBJECT_WARNING(EVENT_MANAGER));}}});return context;};/**\n * Updates rudder event object with data from the API options\n * @param rudderEvent Generated rudder event\n * @param options API options\n */const processOptions=(rudderEvent,options,logger)=>{// Only allow object type for options\nif(isObjectLiteralAndNotNull(options)){updateTopLevelEventElements(rudderEvent,options);// eslint-disable-next-line no-param-reassign\nrudderEvent.context=getMergedContext(rudderEvent.context,options,logger);}};/**\n * Returns the final integrations config for the event based on the global config and event's config\n * @param integrationsConfig Event's integrations config\n * @returns Final integrations config\n */const getEventIntegrationsConfig=integrationsConfig=>{let finalIntgConfig;if(state.loadOptions.value.useGlobalIntegrationsConfigInEvents){// Prefer the integrations object from the consent API response over the load API integrations object\nfinalIntgConfig=state.consents.postConsent.value.integrations??state.nativeDestinations.loadOnlyIntegrations.value;}else if(integrationsConfig){finalIntgConfig=integrationsConfig;}else {finalIntgConfig=DEFAULT_INTEGRATIONS_CONFIG;}return clone(finalIntgConfig);};/**\n * Enrich the base event object with data from state and the API options\n * @param rudderEvent RudderEvent object\n * @param options API options\n * @param pageProps Page properties\n * @param logger logger\n * @returns Enriched RudderEvent object\n */const getEnrichedEvent=(rudderEvent,options,pageProps,logger)=>{const commonEventData={channel:CHANNEL,context:{traits:clone(state.session.userTraits.value),sessionId:state.session.sessionInfo.value.id||undefined,sessionStart:state.session.sessionInfo.value.sessionStart||undefined,// Add 'consentManagement' only if consent management is enabled\n...(state.consents.enabled.value&&{consentManagement:{deniedConsentIds:clone(state.consents.data.value.deniedConsentIds),allowedConsentIds:clone(state.consents.data.value.allowedConsentIds),provider:state.consents.provider.value,resolutionStrategy:state.consents.resolutionStrategy.value}}),'ua-ch':state.context['ua-ch'].value,app:state.context.app.value,library:state.context.library.value,userAgent:state.context.userAgent.value,os:state.context.os.value,locale:state.context.locale.value,screen:state.context.screen.value,campaign:extractUTMParameters(globalThis.location.href),page:getContextPageProperties(pageProps),timezone:state.context.timezone.value,// Add auto tracking information\n...(state.autoTrack.enabled.value&&{autoTrack:{...(state.autoTrack.pageLifecycle.enabled.value&&{page:{pageViewId:state.autoTrack.pageLifecycle.pageViewId.value}})}})},originalTimestamp:getCurrentTimeFormatted(),messageId:generateUUID(),userId:rudderEvent.userId||state.session.userId.value};if(!isStorageTypeValidForStoringData(state.storage.entries.value.anonymousId?.type)){// Generate new anonymous id for each request\ncommonEventData.anonymousId=generateAnonymousId();}else {// Type casting to string as the user session manager will take care of initializing the value\ncommonEventData.anonymousId=state.session.anonymousId.value;}// set truly anonymous tracking flag\nif(state.storage.trulyAnonymousTracking.value){commonEventData.context.trulyAnonymousTracking=true;}if(rudderEvent.type==='identify'){commonEventData.context.traits=state.storage.entries.value.userTraits?.type!==NO_STORAGE?clone(state.session.userTraits.value):rudderEvent.context.traits;}if(rudderEvent.type==='group'){if(rudderEvent.groupId||state.session.groupId.value){commonEventData.groupId=rudderEvent.groupId||state.session.groupId.value;}if(rudderEvent.traits||state.session.groupTraits.value){commonEventData.traits=state.storage.entries.value.groupTraits?.type!==NO_STORAGE?clone(state.session.groupTraits.value):rudderEvent.traits;}}const processedEvent=mergeDeepRight(rudderEvent,commonEventData);// Set the default values for the event properties\n// matching with v1.1 payload\nif(processedEvent.event===undefined){processedEvent.event=null;}if(processedEvent.properties===undefined){processedEvent.properties=null;}processOptions(processedEvent,options,logger);checkForReservedElements(processedEvent,logger);// Update the integrations config for the event\nprocessedEvent.integrations=getEventIntegrationsConfig(processedEvent.integrations);return processedEvent;};\n\nclass RudderEventFactory{constructor(logger){this.logger=logger;}/**\n   * Generate a 'page' event based on the user-input fields\n   * @param category Page's category\n   * @param name Page name\n   * @param properties Page properties\n   * @param options API options\n   */generatePageEvent(category,name,properties,options){let props=properties??{};props=getUpdatedPageProperties(props,options);const pageEvent={properties:props,name,category,type:'page'};return getEnrichedEvent(pageEvent,options,props,this.logger);}/**\n   * Generate a 'track' event based on the user-input fields\n   * @param event The event name\n   * @param properties Event properties\n   * @param options API options\n   */generateTrackEvent(event,properties,options){const trackEvent={properties,event,type:'track'};return getEnrichedEvent(trackEvent,options,undefined,this.logger);}/**\n   * Generate an 'identify' event based on the user-input fields\n   * @param userId New user ID\n   * @param traits new traits\n   * @param options API options\n   */generateIdentifyEvent(userId,traits,options){const identifyEvent={userId,type:'identify',context:{traits}};return getEnrichedEvent(identifyEvent,options,undefined,this.logger);}/**\n   * Generate an 'alias' event based on the user-input fields\n   * @param to New user ID\n   * @param from Old user ID\n   * @param options API options\n   */generateAliasEvent(to,from,options){const aliasEvent={previousId:from,type:'alias'};const enrichedEvent=getEnrichedEvent(aliasEvent,options,undefined,this.logger);// override the User ID from the API inputs\nenrichedEvent.userId=to??enrichedEvent.userId;return enrichedEvent;}/**\n   * Generate a 'group' event based on the user-input fields\n   * @param groupId New group ID\n   * @param traits new group traits\n   * @param options API options\n   */generateGroupEvent(groupId,traits,options){const groupEvent={type:'group'};if(groupId){groupEvent.groupId=groupId;}if(traits){groupEvent.traits=traits;}return getEnrichedEvent(groupEvent,options,undefined,this.logger);}/**\n   * Generates a new RudderEvent object based on the user-input fields\n   * @param event API event parameters object\n   * @returns A RudderEvent object\n   */create(event){let eventObj;switch(event.type){case 'page':eventObj=this.generatePageEvent(event.category,event.name,event.properties,event.options);break;case 'track':eventObj=this.generateTrackEvent(event.name,event.properties,event.options);break;case 'identify':eventObj=this.generateIdentifyEvent(event.userId,event.traits,event.options);break;case 'alias':eventObj=this.generateAliasEvent(event.to,event.from,event.options);break;case 'group':default:eventObj=this.generateGroupEvent(event.groupId,event.traits,event.options);break;}return eventObj;}}\n\n/**\n * A service to generate valid event payloads and queue them for processing\n */class EventManager{/**\n   *\n   * @param eventRepository Event repository instance\n   * @param userSessionManager UserSession Manager instance\n   * @param errorHandler Error handler object\n   * @param logger Logger object\n   */constructor(eventRepository,userSessionManager,errorHandler,logger){this.eventRepository=eventRepository;this.userSessionManager=userSessionManager;this.errorHandler=errorHandler;this.logger=logger;this.eventFactory=new RudderEventFactory(this.logger);}/**\n   * Initializes the event manager\n   */init(){this.eventRepository.init();}resume(){this.eventRepository.resume();}/**\n   * Consumes a new incoming event\n   * @param event Incoming event data\n   */addEvent(event){this.userSessionManager.refreshSession();const rudderEvent=this.eventFactory.create(event);this.eventRepository.enqueue(rudderEvent,event.callback);}}\n\nclass UserSessionManager{/**\n   * Tracks whether a server-side cookie setting request is in progress or not.\n   */constructor(pluginsManager,storeManager,httpClient,errorHandler,logger){this.storeManager=storeManager;this.pluginsManager=pluginsManager;this.logger=logger;this.errorHandler=errorHandler;this.httpClient=httpClient;this.onError=this.onError.bind(this);this.serverSideCookieDebounceFuncs={};this.serverSideCookiesRequestInProgress={};}/**\n   * Initialize User session with values from storage\n   */init(){this.syncStorageDataToState();// Register the effect to sync with storage\nthis.registerEffects();}syncStorageDataToState(){this.migrateStorageIfNeeded();this.migrateDataFromPreviousStorage();// get the values from storage and set it again\nthis.setUserId(this.getUserId());this.setUserTraits(this.getUserTraits());this.setGroupId(this.getGroupId());this.setGroupTraits(this.getGroupTraits());const{externalAnonymousIdCookieName,anonymousIdOptions}=state.loadOptions.value;let externalAnonymousId;if(isDefinedAndNotNull(externalAnonymousIdCookieName)&&typeof externalAnonymousIdCookieName==='string'){externalAnonymousId=this.getExternalAnonymousIdByCookieName(externalAnonymousIdCookieName);}this.setAnonymousId(externalAnonymousId??this.getAnonymousId(anonymousIdOptions));this.setAuthToken(this.getAuthToken());this.setInitialReferrerInfo();this.configureSessionTracking();}configureSessionTracking(){let sessionInfo;if(this.isPersistenceEnabledForStorageEntry('sessionInfo')){const configuredSessionTrackingInfo=this.getConfiguredSessionTrackingInfo();const initialSessionInfo=this.getSessionInfo()??DEFAULT_USER_SESSION_VALUES.sessionInfo;// Merge the session info from the storage and the configuration\nsessionInfo={// If manualTrack is set to true in the storage, then do not enable auto tracking even if configured.\n// Once manual tracking ends (endSession is called), auto tracking will be enabled in the next SDK run.\nautoTrack:configuredSessionTrackingInfo.autoTrack&&initialSessionInfo.manualTrack!==true,timeout:configuredSessionTrackingInfo.timeout,manualTrack:initialSessionInfo.manualTrack,expiresAt:initialSessionInfo.expiresAt,id:initialSessionInfo.id,sessionStart:initialSessionInfo.sessionStart};// If both autoTrack and manualTrack are disabled, reset the session info to default values\nif(!sessionInfo.autoTrack&&sessionInfo.manualTrack!==true){sessionInfo=DEFAULT_USER_SESSION_VALUES.sessionInfo;}else if(configuredSessionTrackingInfo.cutOff?.enabled===true){sessionInfo.cutOff={enabled:true,duration:configuredSessionTrackingInfo.cutOff.duration,expiresAt:initialSessionInfo.cutOff?.expiresAt};}}else {sessionInfo=DEFAULT_USER_SESSION_VALUES.sessionInfo;}state.session.sessionInfo.value=sessionInfo;// If auto session tracking is enabled start the session tracking\nif(state.session.sessionInfo.value.autoTrack){this.startOrRenewAutoTracking(state.session.sessionInfo.value);}}setInitialReferrerInfo(){const persistedInitialReferrer=this.getInitialReferrer();const persistedInitialReferringDomain=this.getInitialReferringDomain();if(persistedInitialReferrer&&persistedInitialReferringDomain){this.setInitialReferrer(persistedInitialReferrer);this.setInitialReferringDomain(persistedInitialReferringDomain);}else {const initialReferrer=persistedInitialReferrer||getReferrer();this.setInitialReferrer(initialReferrer);this.setInitialReferringDomain(getReferringDomain(initialReferrer));}}isPersistenceEnabledForStorageEntry(entryName){return isStorageTypeValidForStoringData(state.storage.entries.value[entryName]?.type);}migrateDataFromPreviousStorage(){const entries=state.storage.entries.value;const storageTypesForMigration=[COOKIE_STORAGE,LOCAL_STORAGE,SESSION_STORAGE];Object.keys(entries).forEach(entry=>{const key=entry;const currentStorage=entries[key]?.type;const curStore=this.storeManager?.getStore(storageClientDataStoreNameMap[currentStorage]);if(curStore){storageTypesForMigration.forEach(storage=>{const store=this.storeManager?.getStore(storageClientDataStoreNameMap[storage]);if(store&&storage!==currentStorage){const value=store.get(COOKIE_KEYS[key]);if(isDefinedNotNullAndNotEmptyString(value)){curStore.set(COOKIE_KEYS[key],value);}store.remove(COOKIE_KEYS[key]);}});}});}migrateStorageIfNeeded(stores,keys){if(!state.storage.migrate.value){return;}let storesToMigrate=stores??[];if(storesToMigrate.length===0){const persistentStoreNames=[CLIENT_DATA_STORE_COOKIE,CLIENT_DATA_STORE_LS,CLIENT_DATA_STORE_SESSION];persistentStoreNames.forEach(storeName=>{const store=this.storeManager?.getStore(storeName);if(store){storesToMigrate.push(store);}});}let keysToMigrate=keys??Object.keys(COOKIE_KEYS);keysToMigrate.forEach(storageKey=>{const storageEntry=COOKIE_KEYS[storageKey];storesToMigrate.forEach(store=>{const migratedVal=this.pluginsManager?.invokeSingle('storage.migrate',storageEntry,store.engine,this.errorHandler,this.logger);// Skip setting the value if it is null or undefined\n// as those values indicate there is no need for migration or\n// migration failed\nif(!isNullOrUndefined(migratedVal)){store.set(storageEntry,migratedVal);}});});}getConfiguredSessionTrackingInfo(){let autoTrack=state.loadOptions.value.sessions.autoTrack!==false;// Do not validate any further if autoTrack is disabled\nif(!autoTrack){return {autoTrack};}let timeout;const configuredSessionTimeout=state.loadOptions.value.sessions?.timeout;if(!isPositiveInteger(configuredSessionTimeout)){this.logger.warn(TIMEOUT_NOT_NUMBER_WARNING(USER_SESSION_MANAGER,configuredSessionTimeout,DEFAULT_SESSION_TIMEOUT_MS));timeout=DEFAULT_SESSION_TIMEOUT_MS;}else {timeout=configuredSessionTimeout;}if(timeout===0){this.logger.warn(TIMEOUT_ZERO_WARNING(USER_SESSION_MANAGER));autoTrack=false;}// In case user provides a timeout value greater than 0 but less than 10 seconds SDK will show a warning\n// and will proceed with it\nif(timeout>0&&timeout<MIN_SESSION_TIMEOUT_MS){this.logger.warn(TIMEOUT_NOT_RECOMMENDED_WARNING(USER_SESSION_MANAGER,timeout,MIN_SESSION_TIMEOUT_MS));}const cutOff=this.getCutOffInfo(timeout);return {timeout,autoTrack,cutOff};}getCutOffInfo(sessionTimeout){const cutOff=state.loadOptions.value.sessions.cutOff;let cutOffDuration;let cutOffEnabled=false;if(cutOff.enabled===true){cutOffDuration=cutOff.duration;cutOffEnabled=true;if(!isPositiveInteger(cutOffDuration)){this.logger.warn(CUT_OFF_DURATION_NOT_NUMBER_WARNING(USER_SESSION_MANAGER,cutOffDuration,DEFAULT_SESSION_CUT_OFF_DURATION_MS));// Use the default value for cut off duration\ncutOffDuration=DEFAULT_SESSION_CUT_OFF_DURATION_MS;}else if(cutOffDuration<sessionTimeout){this.logger.warn(CUT_OFF_DURATION_LESS_THAN_TIMEOUT_WARNING(USER_SESSION_MANAGER,cutOffDuration,sessionTimeout));cutOffEnabled=false;}}return {enabled:cutOffEnabled,duration:cutOffDuration};}/**\n   * Handles error\n   * @param error The error object\n   */onError(error,customMessage,groupingHash){this.errorHandler.onError({error,context:USER_SESSION_MANAGER,customMessage,groupingHash});}/**\n   * A function to encrypt the cookie value and return the encrypted data\n   * @param cookiesData\n   * @param store\n   * @returns\n   */getEncryptedCookieData(cookiesData,store){const encryptedCookieData=[];cookiesData.forEach(cData=>{const encryptedValue=store?.encrypt(stringifyWithoutCircular(cData.value,false,[],this.logger));if(isDefinedAndNotNull(encryptedValue)){encryptedCookieData.push({name:cData.name,value:encryptedValue});}});return encryptedCookieData;}/**\n   * A function that makes request to data service to set the cookie\n   * @param encryptedCookieData\n   * @param callback\n   */makeRequestToSetCookie(encryptedCookieData,callback){this.httpClient?.getAsyncData({url:state.serverCookies.dataServiceUrl.value,options:{method:'POST',data:stringifyWithoutCircular({reqType:'setCookies',workspaceId:state.source.value?.workspaceId,data:{options:{maxAge:state.storage.cookie.value?.maxage,path:state.storage.cookie.value?.path,domain:state.storage.cookie.value?.domain,sameSite:state.storage.cookie.value?.samesite,secure:state.storage.cookie.value?.secure,expires:state.storage.cookie.value?.expires},cookies:encryptedCookieData}}),sendRawData:true,withCredentials:true},isRawResponse:true,callback});}/**\n   * A function to make an external request to set the cookie from server side\n   * @param sessionToCookiesMap map of session key to cookie name\n   * @param cb callback function to be called when the cookie is set\n   * @param store store to be used to get the cookie value\n   */setServerSideCookies(sessionToCookiesMap,cb,store){// Retrieve the cookie value from the state\nconst sessionKeys=Object.keys(sessionToCookiesMap);const getCurrentCookieValuesFromState=()=>{return sessionKeys.map(sessionKey=>{return {name:sessionToCookiesMap[sessionKey].name,value:state.session[sessionKey].value};});};// Preserve the current cookie values\nconst originalCookieValues={};sessionKeys.forEach(sessionKey=>{originalCookieValues[sessionToCookiesMap[sessionKey].name]=store?.get(sessionToCookiesMap[sessionKey].name);});const clearInProgressFlags=()=>{sessionKeys.forEach(sessionKey=>{this.serverSideCookiesRequestInProgress[sessionKey]=false;});};const setCookiesClientSide=()=>{getCurrentCookieValuesFromState().forEach(each=>{if(cb){cb(each.name,each.value);}});};try{const expectedCookieValues={};sessionKeys.forEach(sessionKey=>{expectedCookieValues[sessionToCookiesMap[sessionKey].name]=state.session[sessionKey].value;});// encrypt cookies values\nconst encryptedCookieData=this.getEncryptedCookieData(getCurrentCookieValuesFromState(),store);if(encryptedCookieData.length>0){// make request to data service to set the cookie from server side\nthis.makeRequestToSetCookie(encryptedCookieData,(res,details)=>{// Mark the cookie req status as done\nclearInProgressFlags();if(details?.xhr?.status===200){getCurrentCookieValuesFromState().forEach(cData=>{const originalCookieVal=originalCookieValues[cData.name];const currentCookieVal=store?.get(cData.name);// Check if the expected cookie values are set.\nif(stringifyWithoutCircular(expectedCookieValues[cData.name],false,[])!==stringifyWithoutCircular(currentCookieVal,false,[])){// It's fine if the values don't match as other active SDK sessions might have updated the cookie values\n// or other cookie requests might have updated the cookie value.\n// Log an error only when cookie didn't exist previously and currently also doesn't exist.\nif(isNull(originalCookieVal)&&isNull(currentCookieVal)){this.logger.error(FAILED_SETTING_COOKIE_FROM_SERVER_ERROR(cData.name));}if(cb){cb(cData.name,cData.value);}}});}else {this.logger.error(DATA_SERVER_REQUEST_FAIL_ERROR(details?.xhr?.status));setCookiesClientSide();}});}else {setCookiesClientSide();// Mark the cookie req status as done\nclearInProgressFlags();}}catch(e){this.onError(e,FAILED_SETTING_COOKIE_FROM_SERVER_GLOBAL_ERROR,FAILED_SETTING_COOKIE_FROM_SERVER_GLOBAL_ERROR);setCookiesClientSide();// Mark the cookie req status as done\nclearInProgressFlags();}}/**\n   * A function to sync values in storage\n   * @param sessionKey\n   */syncValueToStorage(sessionKey){const entries=state.storage.entries.value;const storageType=entries[sessionKey]?.type;if(isStorageTypeValidForStoringData(storageType)){const curStore=this.storeManager.getStore(storageClientDataStoreNameMap[storageType]);const cookieName=entries[sessionKey]?.key;const cookieValue=state.session[sessionKey].value;if(cookieValue&&(isString(cookieValue)||isNonEmptyObject(cookieValue))){// if useServerSideCookies load option is set to true\n// set the cookie from server side\nif(state.serverCookies.isEnabledServerSideCookies.value&&storageType===COOKIE_STORAGE){// Mark the requests as in progress.\nthis.serverSideCookiesRequestInProgress[sessionKey]=true;if(this.serverSideCookieDebounceFuncs[sessionKey]){globalThis.clearTimeout(this.serverSideCookieDebounceFuncs[sessionKey]);}this.serverSideCookieDebounceFuncs[sessionKey]=globalThis.setTimeout(()=>{// Create a map of session key to cookie name\nconst sessionToCookiesMap={[sessionKey]:{name:cookieName}};this.setServerSideCookies(sessionToCookiesMap,(cookieName,cookieValue)=>{curStore?.set(cookieName,cookieValue);},curStore);},SERVER_SIDE_COOKIES_DEBOUNCE_TIME);}else {curStore?.set(cookieName,cookieValue);}}else {curStore?.remove(cookieName);}}}/**\n   * Function to update storage whenever state value changes\n   */registerEffects(){// This will work as long as the user session entry key names are same as the state keys\nUSER_SESSION_KEYS.forEach(sessionKey=>{E(()=>{this.syncValueToStorage(sessionKey);});});}/**\n   * Sets anonymous id in the following precedence:\n   *\n   * 1. anonymousId: Id directly provided to the function.\n   * 2. rudderAmpLinkerParam: value generated from linker query parm (rudderstack)\n   *    using parseLinker util.\n   * 3. generateUUID: A new unique id is generated and assigned.\n   */setAnonymousId(anonymousId,rudderAmpLinkerParam){let finalAnonymousId=anonymousId;if(!isString(anonymousId)||!finalAnonymousId){finalAnonymousId=undefined;}if(this.isPersistenceEnabledForStorageEntry('anonymousId')){if(!finalAnonymousId&&rudderAmpLinkerParam){const linkerPluginsResult=this.pluginsManager?.invokeSingle('userSession.anonymousIdGoogleLinker',rudderAmpLinkerParam);finalAnonymousId=linkerPluginsResult;}finalAnonymousId=finalAnonymousId||generateAnonymousId();}else {finalAnonymousId=DEFAULT_USER_SESSION_VALUES.anonymousId;}state.session.anonymousId.value=finalAnonymousId;}/**\n   * Fetches anonymousId\n   * @param options option to fetch it from external source\n   * @returns anonymousId\n   */getAnonymousId(options){const storage=state.storage.entries.value.anonymousId?.type;if(isStorageTypeValidForStoringData(storage)){let persistedAnonymousId=state.session.anonymousId.value;// If the anonymous ID is the default value, fetch it from storage\nif(!persistedAnonymousId||persistedAnonymousId===DEFAULT_USER_SESSION_VALUES.anonymousId){persistedAnonymousId=this.getEntryValue('anonymousId');}if(!persistedAnonymousId&&options){// fetch anonymousId from external source\nconst autoCapturedAnonymousId=this.pluginsManager?.invokeSingle('storage.getAnonymousId',getStorageEngine,options);persistedAnonymousId=autoCapturedAnonymousId;}state.session.anonymousId.value=persistedAnonymousId||generateAnonymousId();}return state.session.anonymousId.value;}getEntryValue(sessionKey){const entries=state.storage.entries.value;const storageType=entries[sessionKey]?.type;if(isStorageTypeValidForStoringData(storageType)){const store=this.storeManager?.getStore(storageClientDataStoreNameMap[storageType]);// Migrate the storage data before fetching the value\n// This is needed for entries that are fetched from the storage\n// during the current session (for example, session info)\nthis.migrateStorageIfNeeded([store],[sessionKey]);const storageKey=entries[sessionKey]?.key;return store?.get(storageKey)??null;}return null;}getExternalAnonymousIdByCookieName(key){const storageEngine=getStorageEngine(COOKIE_STORAGE);if(storageEngine?.isEnabled){return storageEngine.getItem(key)??null;}return null;}/**\n   * Fetches the value for a session key. Preferably from storage, if the server-side\n   * cookies request is not in progress. Otherwise, from the state.\n   * @param sessionKey - The session key to fetch the value for\n   * @returns - The value for the session key\n   */getUserSessionValue(sessionKey){// If the server-side cookies request is in progress, fetch the value from the state.\nif(this.serverSideCookiesRequestInProgress[sessionKey]){return state.session[sessionKey].value;}// Otherwise, fetch the value from storage.\nreturn this.getEntryValue(sessionKey);}/**\n   * Fetches User Id\n   * @returns\n   */getUserId(){return this.getUserSessionValue('userId');}/**\n   * Fetches User Traits\n   * @returns\n   */getUserTraits(){return this.getUserSessionValue('userTraits');}/**\n   * Fetches Group Id\n   * @returns\n   */getGroupId(){return this.getUserSessionValue('groupId');}/**\n   * Fetches Group Traits\n   * @returns\n   */getGroupTraits(){return this.getUserSessionValue('groupTraits');}/**\n   * Fetches Initial Referrer\n   * @returns\n   */getInitialReferrer(){return this.getUserSessionValue('initialReferrer');}/**\n   * Fetches Initial Referring domain\n   * @returns\n   */getInitialReferringDomain(){return this.getUserSessionValue('initialReferringDomain');}/**\n   * Fetches session tracking information from storage\n   * @returns\n   */getSessionInfo(){return this.getUserSessionValue('sessionInfo');}/**\n   * Fetches auth token from storage\n   * @returns\n   */getAuthToken(){return this.getUserSessionValue('authToken');}/**\n   * If session is active it returns the sessionId\n   * @returns\n   */getSessionId(){const sessionInfo=this.getSessionInfo()??DEFAULT_USER_SESSION_VALUES.sessionInfo;if(sessionInfo.autoTrack&&!hasSessionExpired(sessionInfo)||sessionInfo.manualTrack){return sessionInfo.id??null;}return null;}/**\n   * A function to keep the session information up to date in the state\n   * before using it for building event payloads.\n   */refreshSession(){let sessionInfo=this.getSessionInfo()??DEFAULT_USER_SESSION_VALUES.sessionInfo;if(sessionInfo.autoTrack||sessionInfo.manualTrack){if(sessionInfo.autoTrack){this.startOrRenewAutoTracking(sessionInfo);sessionInfo=state.session.sessionInfo.value;}// Note that if sessionStart is false, then it's an active session.\n// So, we needn't update the session info.\n//\n// For other scenarios,\n// 1. If sessionStart is undefined, then it's a new session.\n//   Mark it as sessionStart.\n// 2. If sessionStart is true, then need to flip it for the future events.\nif(sessionInfo.sessionStart===undefined){sessionInfo={...sessionInfo,sessionStart:true};}else if(sessionInfo.sessionStart){sessionInfo={...sessionInfo,sessionStart:false};}}// Always write to state (in-turn to storage) to keep the session info up to date.\nstate.session.sessionInfo.value=sessionInfo;if(state.lifecycle.status.value!=='readyExecuted'){// Force update the storage as the 'effect' blocks are not getting triggered\n// when processing preload buffered requests\nthis.syncValueToStorage('sessionInfo');}}resetAndStartNewSession(){const session=state.session;const{manualTrack,autoTrack,timeout,cutOff}=session.sessionInfo.value;if(autoTrack){const sessionInfo={...DEFAULT_USER_SESSION_VALUES.sessionInfo,timeout};if(cutOff){sessionInfo.cutOff={enabled:cutOff.enabled,duration:cutOff.duration};}session.sessionInfo.value=sessionInfo;this.startOrRenewAutoTracking(session.sessionInfo.value);}else if(manualTrack){this.startManualTrackingInternal();}}/**\n   * Reset state values\n   * @param options options for reset\n   * @returns\n   */reset(options){const{session}=state;const opts=getFinalResetOptions(options);r(()=>{Object.keys(DEFAULT_USER_SESSION_VALUES).forEach(key=>{const userSessionKey=key;if(opts.entries[userSessionKey]!==true){return;}switch(key){case 'anonymousId':this.setAnonymousId();break;case 'sessionInfo':this.resetAndStartNewSession();break;default:session[userSessionKey].value=DEFAULT_USER_SESSION_VALUES[userSessionKey];break;}});});}/**\n   * Set user Id\n   * @param userId\n   */setUserId(userId){state.session.userId.value=this.isPersistenceEnabledForStorageEntry('userId')&&userId?userId:DEFAULT_USER_SESSION_VALUES.userId;}/**\n   * Set user traits\n   * @param traits\n   */setUserTraits(traits){state.session.userTraits.value=this.isPersistenceEnabledForStorageEntry('userTraits')&&isObjectLiteralAndNotNull(traits)?mergeDeepRight(state.session.userTraits.value??DEFAULT_USER_SESSION_VALUES.userTraits,traits):DEFAULT_USER_SESSION_VALUES.userTraits;}/**\n   * Set group Id\n   * @param groupId\n   */setGroupId(groupId){state.session.groupId.value=this.isPersistenceEnabledForStorageEntry('groupId')&&groupId?groupId:DEFAULT_USER_SESSION_VALUES.groupId;}/**\n   * Set group traits\n   * @param traits\n   */setGroupTraits(traits){state.session.groupTraits.value=this.isPersistenceEnabledForStorageEntry('groupTraits')&&isObjectLiteralAndNotNull(traits)?mergeDeepRight(state.session.groupTraits.value??DEFAULT_USER_SESSION_VALUES.groupTraits,traits):DEFAULT_USER_SESSION_VALUES.groupTraits;}/**\n   * Set initial referrer\n   * @param referrer\n   */setInitialReferrer(referrer){state.session.initialReferrer.value=this.isPersistenceEnabledForStorageEntry('initialReferrer')&&referrer?referrer:DEFAULT_USER_SESSION_VALUES.initialReferrer;}/**\n   * Set initial referring domain\n   * @param {String} referringDomain\n   */setInitialReferringDomain(referringDomain){state.session.initialReferringDomain.value=this.isPersistenceEnabledForStorageEntry('initialReferringDomain')&&referringDomain?referringDomain:DEFAULT_USER_SESSION_VALUES.initialReferringDomain;}/**\n   * A function to check for existing session details and depending on that create a new session\n   */startOrRenewAutoTracking(sessionInfo){let finalSessionInfo=sessionInfo;if(hasSessionExpired(sessionInfo)){finalSessionInfo=generateAutoTrackingSession(sessionInfo);}else {const timestamp=Date.now();const timeout=sessionInfo.timeout;// Set the expiry time of the session\nfinalSessionInfo.expiresAt=timestamp+timeout;}// Reset cut off expiry timestamp if it is exceeded\nif(isCutOffTimeExceeded(finalSessionInfo)){finalSessionInfo.cutOff.expiresAt=undefined;}// If cut off is active, set or retain the expiry time\nif(finalSessionInfo.cutOff){const cutOffExpiresAt=getCutOffExpirationTimestamp(finalSessionInfo.cutOff);finalSessionInfo.cutOff.expiresAt=cutOffExpiresAt;}// Update the session info in the state\nstate.session.sessionInfo.value=finalSessionInfo;}/**\n   * A function method to start a manual session\n   * @param {number} id     session identifier\n   * @returns\n   */start(id){state.session.sessionInfo.value=generateManualTrackingSession(id,this.logger);}/**\n   * An internal function to start manual session\n   */startManualTrackingInternal(){this.start(Date.now());}/**\n   * A public method to end an ongoing session.\n   */end(){state.session.sessionInfo.value=DEFAULT_USER_SESSION_VALUES.sessionInfo;}/**\n   * Set auth token\n   * @param userId\n   */setAuthToken(token){state.session.authToken.value=this.isPersistenceEnabledForStorageEntry('authToken')&&token?token:DEFAULT_USER_SESSION_VALUES.authToken;}}\n\n/**\n * Plugins to be loaded in the plugins loadOption is not defined\n */const defaultOptionalPluginsList=['BeaconQueue','CustomConsentManager','DeviceModeDestinations','DeviceModeTransformation','ExternalAnonymousId','GoogleLinker','IubendaConsentManager','KetchConsentManager','NativeDestinationQueue','OneTrustConsentManager','StorageEncryption','StorageEncryptionLegacy','StorageMigrator','XhrQueue'];\n\nconst normalizeLoadOptions=(loadOptionsFromState,loadOptions)=>{// TODO: Maybe add warnings for invalid values\nconst normalizedLoadOpts=clone(loadOptions);if(!isString(normalizedLoadOpts.setCookieDomain)){normalizedLoadOpts.setCookieDomain=undefined;}const cookieSameSiteValues=['Strict','Lax','None'];if(!cookieSameSiteValues.includes(normalizedLoadOpts.sameSiteCookie)){normalizedLoadOpts.sameSiteCookie=undefined;}normalizedLoadOpts.secureCookie=getNormalizedBooleanValue(normalizedLoadOpts.secureCookie,loadOptionsFromState.secureCookie);normalizedLoadOpts.sameDomainCookiesOnly=getNormalizedBooleanValue(normalizedLoadOpts.sameDomainCookiesOnly,loadOptionsFromState.sameDomainCookiesOnly);const uaChTrackLevels=['none','default','full'];if(!uaChTrackLevels.includes(normalizedLoadOpts.uaChTrackLevel)){normalizedLoadOpts.uaChTrackLevel=undefined;}normalizedLoadOpts.integrations=getNormalizedObjectValue(normalizedLoadOpts.integrations);if(!Array.isArray(normalizedLoadOpts.plugins)){normalizedLoadOpts.plugins=defaultOptionalPluginsList;}normalizedLoadOpts.useGlobalIntegrationsConfigInEvents=getNormalizedBooleanValue(normalizedLoadOpts.useGlobalIntegrationsConfigInEvents,loadOptionsFromState.useGlobalIntegrationsConfigInEvents);normalizedLoadOpts.bufferDataPlaneEventsUntilReady=getNormalizedBooleanValue(normalizedLoadOpts.bufferDataPlaneEventsUntilReady,loadOptionsFromState.bufferDataPlaneEventsUntilReady);normalizedLoadOpts.sendAdblockPage=getNormalizedBooleanValue(normalizedLoadOpts.sendAdblockPage,loadOptionsFromState.sendAdblockPage);normalizedLoadOpts.useServerSideCookies=getNormalizedBooleanValue(normalizedLoadOpts.useServerSideCookies,loadOptionsFromState.useServerSideCookies);if(!isString(normalizedLoadOpts.dataServiceEndpoint)){normalizedLoadOpts.dataServiceEndpoint=undefined;}normalizedLoadOpts.sendAdblockPageOptions=getNormalizedObjectValue(normalizedLoadOpts.sendAdblockPageOptions);normalizedLoadOpts.loadIntegration=getNormalizedBooleanValue(normalizedLoadOpts.loadIntegration,loadOptionsFromState.loadIntegration);if(!isNonEmptyObject(normalizedLoadOpts.storage)){normalizedLoadOpts.storage=undefined;}else {normalizedLoadOpts.storage.migrate=getNormalizedBooleanValue(normalizedLoadOpts.storage.migrate,loadOptionsFromState.storage?.migrate);normalizedLoadOpts.storage.cookie=getNormalizedObjectValue(normalizedLoadOpts.storage.cookie);normalizedLoadOpts.storage.encryption=getNormalizedObjectValue(normalizedLoadOpts.storage.encryption);normalizedLoadOpts.storage=removeUndefinedAndNullValues(normalizedLoadOpts.storage);}normalizedLoadOpts.destinationsQueueOptions=getNormalizedObjectValue(normalizedLoadOpts.destinationsQueueOptions);normalizedLoadOpts.queueOptions=getNormalizedObjectValue(normalizedLoadOpts.queueOptions);normalizedLoadOpts.lockIntegrationsVersion=getNormalizedBooleanValue(normalizedLoadOpts.lockIntegrationsVersion,loadOptionsFromState.lockIntegrationsVersion);normalizedLoadOpts.lockPluginsVersion=getNormalizedBooleanValue(normalizedLoadOpts.lockPluginsVersion,loadOptionsFromState.lockPluginsVersion);if(!isNumber(normalizedLoadOpts.dataPlaneEventsBufferTimeout)){normalizedLoadOpts.dataPlaneEventsBufferTimeout=undefined;}normalizedLoadOpts.beaconQueueOptions=getNormalizedObjectValue(normalizedLoadOpts.beaconQueueOptions);normalizedLoadOpts.preConsent=getNormalizedObjectValue(normalizedLoadOpts.preConsent);normalizedLoadOpts.sourceConfigurationOverride=getNormalizedObjectValue(normalizedLoadOpts.sourceConfigurationOverride);const mergedLoadOptions=mergeDeepRight(loadOptionsFromState,removeUndefinedAndNullValues(normalizedLoadOpts));return mergedLoadOptions;};\n\nconst DATA_PLANE_QUEUE_EXT_POINT_PREFIX='dataplaneEventsQueue';const DESTINATIONS_QUEUE_EXT_POINT_PREFIX='destinationsEventsQueue';const DMT_EXT_POINT_PREFIX='transformEvent';\n\n/**\n * Filters and returns the user supplied integrations config that should take preference over the destination specific integrations config\n * @param eventIntgConfig User supplied integrations config at event level\n * @param destinationsIntgConfig Cumulative integrations config from all destinations\n * @returns Filtered user supplied integrations config\n */const getOverriddenIntegrationOptions=(eventIntgConfig,destinationsIntgConfig)=>Object.keys(eventIntgConfig).filter(intgName=>eventIntgConfig[intgName]!==true||!destinationsIntgConfig[intgName]).reduce((obj,key)=>{const retVal=clone(obj);retVal[key]=eventIntgConfig[key];return retVal;},{});/**\n * Returns the event object with final integrations config\n * @param event RudderEvent object\n * @param state Application state\n * @returns Mutated event with final integrations config\n */const getFinalEvent=(event,state)=>{const finalEvent=clone(event);// Merge the destination specific integrations config with the event's integrations config\n// In general, the preference is given to the event's integrations config\nconst destinationsIntgConfig=state.nativeDestinations.integrationsConfig.value;const overriddenIntgOpts=getOverriddenIntegrationOptions(event.integrations,destinationsIntgConfig);finalEvent.integrations=mergeDeepRight(destinationsIntgConfig,overriddenIntgOpts);return finalEvent;};const shouldBufferEventsForPreConsent=state=>state.consents.preConsent.value.enabled&&state.consents.preConsent.value.events?.delivery==='buffer';\n\nconst safelyInvokeCallback=(callback,args,apiName,logger)=>{if(!isDefined(callback)){return;}if(isFunction(callback)){try{callback(...args);}catch(error){logger.error(CALLBACK_INVOKE_ERROR(apiName),error);}}else {logger.error(INVALID_CALLBACK_FN_ERROR(apiName));}};\n\n/**\n * Event repository class responsible for queuing events for further processing and delivery\n */class EventRepository{/**\n   *\n   * @param pluginsManager Plugins manager instance\n   * @param storeManager Store Manager instance\n   * @param errorHandler Error handler object\n   * @param logger Logger object\n   */constructor(pluginsManager,storeManager,httpClient,errorHandler,logger){this.pluginsManager=pluginsManager;this.errorHandler=errorHandler;this.httpClient=httpClient;this.logger=logger;this.storeManager=storeManager;}/**\n   * Initializes the event repository\n   */init(){this.dataplaneEventsQueue=this.pluginsManager.invokeSingle(`${DATA_PLANE_QUEUE_EXT_POINT_PREFIX}.init`,state,this.httpClient,this.storeManager,this.errorHandler,this.logger);this.dmtEventsQueue=this.pluginsManager.invokeSingle(`${DMT_EXT_POINT_PREFIX}.init`,state,this.pluginsManager,this.httpClient,this.storeManager,this.errorHandler,this.logger);this.destinationsEventsQueue=this.pluginsManager.invokeSingle(`${DESTINATIONS_QUEUE_EXT_POINT_PREFIX}.init`,state,this.pluginsManager,this.storeManager,this.dmtEventsQueue,this.errorHandler,this.logger);// Start the queue once the client destinations are ready\nE(()=>{if(state.nativeDestinations.clientDestinationsReady.value===true){this.destinationsEventsQueue?.start();this.dmtEventsQueue?.start();}});const bufferEventsBeforeConsent=shouldBufferEventsForPreConsent(state);// Start the queue processing only when the destinations are ready or hybrid mode destinations exist\n// However, events will be enqueued for now.\n// At the time of processing the events, the integrations config data from destinations\n// is merged into the event object\nlet timeoutId;E(()=>{const shouldBufferDpEvents=state.loadOptions.value.bufferDataPlaneEventsUntilReady===true&&state.nativeDestinations.clientDestinationsReady.value===false;const hybridDestExist=state.nativeDestinations.activeDestinations.value.some(dest=>isHybridModeDestination(dest));if((hybridDestExist===false||shouldBufferDpEvents===false)&&!bufferEventsBeforeConsent&&this.dataplaneEventsQueue?.scheduleTimeoutActive!==true){globalThis.clearTimeout(timeoutId);this.dataplaneEventsQueue?.start();}});// Force start the data plane events queue processing after a timeout\nif(state.loadOptions.value.bufferDataPlaneEventsUntilReady===true){timeoutId=globalThis.setTimeout(()=>{if(this.dataplaneEventsQueue?.scheduleTimeoutActive!==true){this.dataplaneEventsQueue?.start();}},state.loadOptions.value.dataPlaneEventsBufferTimeout);}}resume(){if(this.dataplaneEventsQueue?.scheduleTimeoutActive!==true){if(state.consents.postConsent.value.discardPreConsentEvents){this.dataplaneEventsQueue?.clear();this.destinationsEventsQueue?.clear();}this.dataplaneEventsQueue?.start();}}/**\n   * Enqueues the event for processing\n   * @param event RudderEvent object\n   * @param callback API callback function\n   */enqueue(event,callback){const dpQEvent=getFinalEvent(event,state);this.pluginsManager.invokeSingle(`${DATA_PLANE_QUEUE_EXT_POINT_PREFIX}.enqueue`,state,this.dataplaneEventsQueue,dpQEvent,this.errorHandler,this.logger);const dQEvent=clone(event);this.pluginsManager.invokeSingle(`${DESTINATIONS_QUEUE_EXT_POINT_PREFIX}.enqueue`,state,this.destinationsEventsQueue,dQEvent,this.errorHandler,this.logger);// Invoke the callback if it exists\nconst apiName=`${event.type.charAt(0).toUpperCase()}${event.type.slice(1)}${API_SUFFIX}`;safelyInvokeCallback(callback,[dpQEvent],apiName,this.logger);}}\n\nconst dispatchSDKEvent=event=>{const customEvent=new CustomEvent(event,{detail:{analyticsInstance:globalThis.rudderanalytics},bubbles:true,cancelable:true,composed:true});globalThis.document.dispatchEvent(customEvent);};const isWriteKeyValid=writeKey=>isString(writeKey)&&writeKey.trim().length>0;const isDataPlaneUrlValid=dataPlaneUrl=>isValidURL(dataPlaneUrl);\n\n/*\n * Analytics class with lifecycle based on state ad user triggered events\n */class Analytics{/**\n   * Initialize services and components or use default ones if singletons\n   */constructor(){this.preloadBuffer=new BufferQueue();this.initialized=false;this.errorHandler=defaultErrorHandler;this.logger=defaultLogger;this.externalSrcLoader=new ExternalSrcLoader(this.logger);this.httpClient=defaultHttpClient;this.httpClient.init(this.errorHandler);this.capabilitiesManager=new CapabilitiesManager(this.httpClient,this.errorHandler,this.logger);}/**\n   * Start application lifecycle if not already started\n   */load(writeKey,dataPlaneUrl,loadOptions={}){if(state.lifecycle.status.value){return;}if(!isWriteKeyValid(writeKey)){this.logger.error(WRITE_KEY_VALIDATION_ERROR(ANALYTICS_CORE,writeKey));return;}if(!isDataPlaneUrlValid(dataPlaneUrl)){this.logger.error(DATA_PLANE_URL_VALIDATION_ERROR(ANALYTICS_CORE,dataPlaneUrl));return;}// Set initial state values\nr(()=>{state.lifecycle.writeKey.value=clone(writeKey);state.lifecycle.dataPlaneUrl.value=clone(dataPlaneUrl);state.loadOptions.value=normalizeLoadOptions(state.loadOptions.value,loadOptions);state.lifecycle.status.value='mounted';});// set log level as early as possible\nthis.logger.setMinLogLevel(state.loadOptions.value.logLevel??POST_LOAD_LOG_LEVEL);// Expose state to global objects\nsetExposedGlobal('state',state,writeKey);// Configure initial config of any services or components here\n// State application lifecycle\nthis.startLifecycle();}// Start lifecycle methods\n/**\n   * Orchestrate the lifecycle of the application phases/status\n   */startLifecycle(){E(()=>{try{switch(state.lifecycle.status.value){case 'mounted':this.onMounted();break;case 'browserCapabilitiesReady':this.onBrowserCapabilitiesReady();break;case 'configured':this.onConfigured();break;case 'pluginsLoading':break;case 'pluginsReady':this.onPluginsReady();break;case 'initialized':this.onInitialized();break;case 'loaded':this.onLoaded();break;case 'destinationsLoading':break;case 'destinationsReady':this.onDestinationsReady();break;case 'ready':this.onReady();break;case 'readyExecuted':default:break;}}catch(err){const issue='Failed to load the SDK';this.errorHandler.onError({error:err,context:ANALYTICS_CORE,customMessage:issue,groupingHash:issue});}});}onBrowserCapabilitiesReady(){// initialize the preloaded events enqueuing\nretrievePreloadBufferEvents(this);this.prepareInternalServices();this.loadConfig();}onLoaded(){this.processBufferedEvents();// Short-circuit the life cycle and move to the ready state if pre-consent behavior is enabled\nif(state.consents.preConsent.value.enabled===true){state.lifecycle.status.value='ready';}else {this.loadDestinations();}}/**\n   * Load browser polyfill if required\n   */onMounted(){this.capabilitiesManager.init();}/**\n   * Enqueue in SDK preload buffer events, used from preloadBuffer component\n   */enqueuePreloadBufferEvents(bufferedEvents){if(Array.isArray(bufferedEvents)){bufferedEvents.forEach(bufferedEvent=>this.preloadBuffer.enqueue(clone(bufferedEvent)));}}/**\n   * Process the buffer preloaded events by passing their arguments to the respective facade methods\n   */processDataInPreloadBuffer(){while(this.preloadBuffer.size()>0){const eventToProcess=this.preloadBuffer.dequeue();if(eventToProcess){consumePreloadBufferedEvent([...eventToProcess],this);}}}prepareInternalServices(){this.pluginsManager=new PluginsManager(defaultPluginEngine,this.errorHandler,this.logger);this.storeManager=new StoreManager(this.pluginsManager,this.errorHandler,this.logger);this.configManager=new ConfigManager(this.httpClient,this.errorHandler,this.logger);this.userSessionManager=new UserSessionManager(this.pluginsManager,this.storeManager,this.httpClient,this.errorHandler,this.logger);this.eventRepository=new EventRepository(this.pluginsManager,this.storeManager,this.httpClient,this.errorHandler,this.logger);this.eventManager=new EventManager(this.eventRepository,this.userSessionManager,this.errorHandler,this.logger);}/**\n   * Load configuration\n   */loadConfig(){if(state.lifecycle.writeKey.value){this.httpClient.setAuthHeader(state.lifecycle.writeKey.value);}this.configManager?.init();}/**\n   * Initialize the storage and event queue\n   */onPluginsReady(){// Initialize storage\nthis.storeManager?.init();this.userSessionManager?.init();// Initialize the appropriate consent manager plugin\nif(state.consents.enabled.value&&!state.consents.initialized.value){this.pluginsManager?.invokeSingle(`consentManager.init`,state,this.logger);if(state.consents.preConsent.value.enabled===false){this.pluginsManager?.invokeSingle(`consentManager.updateConsentsInfo`,state,this.storeManager,this.logger);}}// Initialize event manager\nthis.eventManager?.init();// Mark the SDK as initialized\nstate.lifecycle.status.value='initialized';}/**\n   * Load plugins\n   */onConfigured(){this.pluginsManager?.init();// TODO: are we going to enable custom plugins to be passed as load options?\n// registerCustomPlugins(state.loadOptions.value.customPlugins);\n}/**\n   * Trigger onLoaded callback if any is provided in config & emit initialised event\n   */onInitialized(){// Process any preloaded events\nthis.processDataInPreloadBuffer();// Set lifecycle state\nr(()=>{state.lifecycle.loaded.value=true;state.lifecycle.status.value='loaded';});this.initialized=true;// Execute onLoaded callback if provided in load options\nconst onLoadedCallbackFn=state.loadOptions.value.onLoaded;// TODO: we need to avoid passing the window object to the callback function\n// as this will prevent us from supporting multiple SDK instances in the same page\nsafelyInvokeCallback(onLoadedCallbackFn,[globalThis.rudderanalytics],LOAD_API,this.logger);// Emit an event to use as substitute to the onLoaded callback\ndispatchSDKEvent('RSA_Initialised');}/**\n   * Emit ready event\n   */// eslint-disable-next-line class-methods-use-this\nonReady(){state.lifecycle.status.value='readyExecuted';state.eventBuffer.readyCallbacksArray.value.forEach(callback=>{safelyInvokeCallback(callback,[],READY_API,this.logger);});// Emit an event to use as substitute to the ready callback\ndispatchSDKEvent('RSA_Ready');}/**\n   * Consume preloaded events buffer\n   */processBufferedEvents(){// This logic has been intentionally implemented without a simple\n// for-loop as the individual events that are processed may\n// add more events to the buffer (this is needed for the consent API)\nlet bufferedEvents=state.eventBuffer.toBeProcessedArray.value;while(bufferedEvents.length>0){const bufferedEvent=bufferedEvents.shift();state.eventBuffer.toBeProcessedArray.value=bufferedEvents;if(bufferedEvent){const methodName=bufferedEvent[0];if(isFunction(this[methodName])){// Send additional arg 'true' to indicate that this is a buffered invocation\nthis[methodName](...bufferedEvent.slice(1),true);}}bufferedEvents=state.eventBuffer.toBeProcessedArray.value;}}/**\n   * Load device mode destinations\n   */loadDestinations(){// If the integrations load is already triggered or completed, skip the rest of the logic\nif(state.lifecycle.status.value==='destinationsLoading'||state.lifecycle.status.value==='destinationsReady'){return;}// Set in state the desired activeDestinations to inject in DOM\nthis.pluginsManager?.invokeSingle('nativeDestinations.setActiveDestinations',state,this.pluginsManager,this.errorHandler,this.logger);const totalDestinationsToLoad=state.nativeDestinations.activeDestinations.value.length;if(totalDestinationsToLoad===0){state.lifecycle.status.value='destinationsReady';return;}// Start loading native integration scripts and create instances\nstate.lifecycle.status.value='destinationsLoading';this.pluginsManager?.invokeSingle('nativeDestinations.load',state,this.externalSrcLoader,this.errorHandler,this.logger);// Progress to next lifecycle phase if all native destinations are initialized or failed\nE(()=>{const areAllDestinationsReady=totalDestinationsToLoad===0||state.nativeDestinations.initializedDestinations.value.length+state.nativeDestinations.failedDestinations.value.length===totalDestinationsToLoad;if(areAllDestinationsReady){r(()=>{state.lifecycle.status.value='destinationsReady';state.nativeDestinations.clientDestinationsReady.value=true;});}});}/**\n   * Move to the ready state\n   */// eslint-disable-next-line class-methods-use-this\nonDestinationsReady(){// May be do any destination specific actions here\n// Mark the ready status if not already done\nif(state.lifecycle.status.value!=='ready'){state.lifecycle.status.value='ready';}}// End lifecycle methods\n// Start consumer exposed methods\nready(callback,isBufferedInvocation=false){const type='ready';if(!state.lifecycle.loaded.value){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type,callback]];return;}this.errorHandler.leaveBreadcrumb(`New ${type} invocation`);if(!isFunction(callback)){this.logger.error(INVALID_CALLBACK_FN_ERROR(READY_API));return;}/**\n     * If destinations are loaded or no integration is available for loading\n     * execute the callback immediately else push the callbacks to a queue that\n     * will be executed after loading completes\n     */if(state.lifecycle.status.value==='readyExecuted'){safelyInvokeCallback(callback,[],READY_API,this.logger);}else {state.eventBuffer.readyCallbacksArray.value=[...state.eventBuffer.readyCallbacksArray.value,callback];}}page(payload,isBufferedInvocation=false){const type='page';if(!state.lifecycle.loaded.value){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type,payload]];return;}this.errorHandler.leaveBreadcrumb(`New ${type} event`);state.metrics.triggered.value+=1;this.eventManager?.addEvent({type:'page',category:payload.category,name:payload.name,properties:payload.properties,options:payload.options,callback:payload.callback});// TODO: Maybe we should alter the behavior to send the ad-block page event even if the SDK is still loaded. It'll be pushed into the to be processed queue.\n// Send automatic ad blocked page event if ad-blockers are detected on the page\n// Check page category to avoid infinite loop\nif(state.capabilities.isAdBlocked.value===true&&payload.category!==ADBLOCK_PAGE_CATEGORY){this.page(pageArgumentsToCallOptions(ADBLOCK_PAGE_CATEGORY,ADBLOCK_PAGE_NAME,{// 'title' is intentionally omitted as it does not make sense\n// in v3 implementation\npath:ADBLOCK_PAGE_PATH},state.loadOptions.value.sendAdblockPageOptions));}}track(payload,isBufferedInvocation=false){const type='track';if(!state.lifecycle.loaded.value){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type,payload]];return;}this.errorHandler.leaveBreadcrumb(`New ${type} event - ${payload.name}`);state.metrics.triggered.value+=1;this.eventManager?.addEvent({type,name:payload.name||undefined,properties:payload.properties,options:payload.options,callback:payload.callback});}identify(payload,isBufferedInvocation=false){const type='identify';if(!state.lifecycle.loaded.value){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type,payload]];return;}this.errorHandler.leaveBreadcrumb(`New ${type} event`);state.metrics.triggered.value+=1;const shouldResetSession=Boolean(payload.userId&&state.session.userId.value&&payload.userId!==state.session.userId.value);if(shouldResetSession){this.reset();}// `null` value indicates that previous user ID needs to be retained\nif(!isNull(payload.userId)){this.userSessionManager?.setUserId(payload.userId);}this.userSessionManager?.setUserTraits(payload.traits);this.eventManager?.addEvent({type,userId:payload.userId,traits:payload.traits,options:payload.options,callback:payload.callback});}alias(payload,isBufferedInvocation=false){const type='alias';if(!state.lifecycle.loaded.value){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type,payload]];return;}this.errorHandler.leaveBreadcrumb(`New ${type} event`);state.metrics.triggered.value+=1;const previousId=payload.from??(this.getUserId()||this.userSessionManager?.getAnonymousId());this.eventManager?.addEvent({type,to:payload.to,from:previousId,options:payload.options,callback:payload.callback});}group(payload,isBufferedInvocation=false){const type='group';if(!state.lifecycle.loaded.value){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type,payload]];return;}this.errorHandler.leaveBreadcrumb(`New ${type} event`);state.metrics.triggered.value+=1;// `null` value indicates that previous group ID needs to be retained\nif(!isNull(payload.groupId)){this.userSessionManager?.setGroupId(payload.groupId);}this.userSessionManager?.setGroupTraits(payload.traits);this.eventManager?.addEvent({type,groupId:payload.groupId,traits:payload.traits,options:payload.options,callback:payload.callback});}reset(options,isBufferedInvocation=false){const type='reset';if(!state.lifecycle.loaded.value){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type,options]];return;}this.errorHandler.leaveBreadcrumb(`New ${type} invocation`);this.userSessionManager?.reset(options);}getAnonymousId(options){return this.userSessionManager?.getAnonymousId(options);}setAnonymousId(anonymousId,rudderAmpLinkerParam,isBufferedInvocation=false){const type='setAnonymousId';// Buffering is needed as setting the anonymous ID may require invoking the GoogleLinker plugin\nif(!state.lifecycle.loaded.value){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type,anonymousId,rudderAmpLinkerParam]];return;}this.errorHandler.leaveBreadcrumb(`New ${type} invocation`);this.userSessionManager?.setAnonymousId(anonymousId,rudderAmpLinkerParam);}// eslint-disable-next-line class-methods-use-this\ngetUserId(){return state.session.userId.value;}// eslint-disable-next-line class-methods-use-this\ngetUserTraits(){return state.session.userTraits.value;}// eslint-disable-next-line class-methods-use-this\ngetGroupId(){return state.session.groupId.value;}// eslint-disable-next-line class-methods-use-this\ngetGroupTraits(){return state.session.groupTraits.value;}startSession(sessionId,isBufferedInvocation=false){const type='startSession';if(!state.lifecycle.loaded.value){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type,sessionId]];return;}this.errorHandler.leaveBreadcrumb(`New ${type} invocation`);this.userSessionManager?.start(sessionId);}endSession(isBufferedInvocation=false){const type='endSession';if(!state.lifecycle.loaded.value){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type]];return;}this.errorHandler.leaveBreadcrumb(`New ${type} invocation`);this.userSessionManager?.end();}// eslint-disable-next-line class-methods-use-this\ngetSessionId(){const sessionId=this.userSessionManager?.getSessionId();return sessionId??null;}consent(options,isBufferedInvocation=false){const type='consent';if(!state.lifecycle.loaded.value){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type,options]];return;}this.errorHandler.leaveBreadcrumb(`New consent invocation`);r(()=>{state.consents.preConsent.value={...state.consents.preConsent.value,enabled:false};state.consents.postConsent.value=getValidPostConsentOptions(options);const{initialized,consentsData}=getConsentManagementData(state.consents.postConsent.value.consentManagement,this.logger);state.consents.initialized.value=initialized;state.consents.data.value=consentsData;});// Update consents data in state\nif(state.consents.enabled.value&&!state.consents.initialized.value){this.pluginsManager?.invokeSingle(`consentManager.updateConsentsInfo`,state,this.storeManager,this.logger);}// Re-init store manager\nthis.storeManager?.initializeStorageState();// Re-init user session manager\nthis.userSessionManager?.syncStorageDataToState();// Resume event manager to process the events to destinations\nthis.eventManager?.resume();this.loadDestinations();this.sendTrackingEvents(isBufferedInvocation);}sendTrackingEvents(isBufferedInvocation){// If isBufferedInvocation is true, then the tracking events will be added to the end of the\n// events buffer array so that any other preload events (mainly from query string API) will be processed first.\nif(state.consents.postConsent.value.trackConsent){const trackOptions=trackArgumentsToCallOptions(CONSENT_TRACK_EVENT_NAME);if(isBufferedInvocation){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,['track',trackOptions]];}else {this.track(trackOptions);}}if(state.consents.postConsent.value.sendPageEvent){const pageOptions=pageArgumentsToCallOptions();if(isBufferedInvocation){state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,['page',pageOptions]];}else {this.page(pageOptions);}}}setAuthToken(token){this.userSessionManager?.setAuthToken(token);}/**\n   * Add a custom integration for a custom destination.\n   * @param destinationId - The ID of the custom destination from the RudderStack dashboard.\n   * @param integration - The custom integration object.\n   * @param isBufferedInvocation - Whether the invocation is buffered.\n   */addCustomIntegration(destinationId,integration,isBufferedInvocation=false){const type='addCustomIntegration';if(isBufferedInvocation){this.errorHandler.leaveBreadcrumb(`New ${type} invocation`);this.pluginsManager?.invokeSingle('nativeDestinations.addCustomIntegration',destinationId,integration,state,this.logger);}else {if(state.lifecycle.loaded.value){this.logger.error(CUSTOM_INTEGRATION_CANNOT_BE_ADDED_ERROR(ANALYTICS_CORE,destinationId));return;}state.eventBuffer.toBeProcessedArray.value=[...state.eventBuffer.toBeProcessedArray.value,[type,destinationId,integration]];}}// End consumer exposed methods\n}\n\n/*\n * RudderAnalytics facade singleton that is exposed as global object and will:\n * expose overloaded methods\n * handle multiple Analytics instances\n * consume SDK preload event buffer\n */class RudderAnalytics{// START-NO-SONAR-SCAN\n// eslint-disable-next-line sonarjs/public-static-readonly\nstatic globalSingleton=null;// END-NO-SONAR-SCAN\nanalyticsInstances={};defaultAnalyticsKey='';logger=defaultLogger;// Singleton with constructor bind methods\nconstructor(){try{if(RudderAnalytics.globalSingleton){// START-NO-SONAR-SCAN\n// eslint-disable-next-line no-constructor-return\nreturn RudderAnalytics.globalSingleton;// END-NO-SONAR-SCAN\n}RudderAnalytics.initializeGlobalResources();this.setDefaultInstanceKey=this.setDefaultInstanceKey.bind(this);this.getAnalyticsInstance=this.getAnalyticsInstance.bind(this);this.load=this.load.bind(this);this.ready=this.ready.bind(this);this.triggerBufferedLoadEvent=this.triggerBufferedLoadEvent.bind(this);this.page=this.page.bind(this);this.track=this.track.bind(this);this.identify=this.identify.bind(this);this.alias=this.alias.bind(this);this.group=this.group.bind(this);this.reset=this.reset.bind(this);this.getAnonymousId=this.getAnonymousId.bind(this);this.setAnonymousId=this.setAnonymousId.bind(this);this.getUserId=this.getUserId.bind(this);this.getUserTraits=this.getUserTraits.bind(this);this.getGroupId=this.getGroupId.bind(this);this.getGroupTraits=this.getGroupTraits.bind(this);this.startSession=this.startSession.bind(this);this.endSession=this.endSession.bind(this);this.getSessionId=this.getSessionId.bind(this);this.setAuthToken=this.setAuthToken.bind(this);this.consent=this.consent.bind(this);this.addCustomIntegration=this.addCustomIntegration.bind(this);this.createSafeAnalyticsInstance();RudderAnalytics.globalSingleton=this;state.autoTrack.pageLifecycle.pageViewId.value=generateUUID();state.autoTrack.pageLifecycle.pageLoadedTimestamp.value=Date.now();// start loading if a load event was buffered or wait for explicit load call\nthis.triggerBufferedLoadEvent();// Assign to global \"rudderanalytics\" object after processing the preload buffer (if any exists)\n// for CDN bundling IIFE exports covers this but for npm ESM and CJS bundling has to be done explicitly\nglobalThis.rudderanalytics=this;}catch(error){dispatchErrorEvent(error);}}/**\n   * Create an instance of the current instance that can be used\n   * to call a subset of methods of the current instance.\n   * It is typically used to expose the analytics instance to the integrations (standard and custom)\n   */createSafeAnalyticsInstance(){state.lifecycle.safeAnalyticsInstance.value={page:this.page.bind(this),track:this.track.bind(this),identify:this.identify.bind(this),alias:this.alias.bind(this),group:this.group.bind(this),getAnonymousId:this.getAnonymousId.bind(this),getUserId:this.getUserId.bind(this),getUserTraits:this.getUserTraits.bind(this),getGroupId:this.getGroupId.bind(this),getGroupTraits:this.getGroupTraits.bind(this),getSessionId:this.getSessionId.bind(this)};}static initializeGlobalResources(){// We need to initialize the error handler first to catch any unhandled errors occurring in this module as well\ndefaultErrorHandler.init();// Initialize the storage engines with default options\ndefaultCookieStorage.configure();defaultLocalStorage.configure();defaultSessionStorage.configure();defaultInMemoryStorage.configure();}/**\n   * Set instance to use if no specific writeKey is provided in methods\n   * automatically for the first created instance\n   * TODO: to support multiple analytics instances in the near future\n   */setDefaultInstanceKey(writeKey){// IMP: Add try-catch block to handle any unhandled errors\n// similar to other public methods\n// if the implementation of this method goes beyond\n// this simple implementation\nif(isString(writeKey)&&writeKey){this.defaultAnalyticsKey=writeKey;}}/**\n   * Retrieve an existing analytics instance\n   */getAnalyticsInstance(writeKey){try{let instanceId=writeKey;if(!isString(instanceId)||!instanceId){instanceId=this.defaultAnalyticsKey;}const analyticsInstanceExists=Boolean(this.analyticsInstances[instanceId]);if(!analyticsInstanceExists){this.analyticsInstances[instanceId]=new Analytics();}return this.analyticsInstances[instanceId];}catch(error){dispatchErrorEvent(error);return undefined;}}/**\n   * Loads the SDK\n   * @param writeKey Source write key\n   * @param dataPlaneUrl Data plane URL\n   * @param loadOptions Additional options for loading the SDK\n   * @returns none\n   */load(writeKey,dataPlaneUrl,loadOptions){try{if(this.analyticsInstances[writeKey]){return;}this.setDefaultInstanceKey(writeKey);// Track page loaded lifecycle event if enabled\nthis.trackPageLifecycleEvents(loadOptions);// Get the preloaded events array from global buffer instead of window.rudderanalytics\n// as the constructor must have already pushed the events to the global buffer\nconst preloadedEventsArray=getExposedGlobal(GLOBAL_PRELOAD_BUFFER);// The array will be mutated in the below method\npromotePreloadedConsentEventsToTop(preloadedEventsArray);setExposedGlobal(GLOBAL_PRELOAD_BUFFER,clone(preloadedEventsArray));this.getAnalyticsInstance(writeKey)?.load(writeKey,dataPlaneUrl,getSanitizedValue(loadOptions));}catch(error){dispatchErrorEvent(error);}}/**\n   * A function to track page lifecycle events like page loaded and page unloaded\n   * @param loadOptions\n   * @returns\n   */trackPageLifecycleEvents(loadOptions){const{autoTrack,useBeacon}=loadOptions??{};const{enabled:autoTrackEnabled=false,options:autoTrackOptions={},pageLifecycle}=autoTrack??{};const{events=[PageLifecycleEvents.UNLOADED],enabled:pageLifecycleEnabled=autoTrackEnabled,options=autoTrackOptions}=pageLifecycle??{};state.autoTrack.pageLifecycle.enabled.value=pageLifecycleEnabled;// Set the autoTrack enabled state\n// if at least one of the autoTrack options is enabled\n// IMPORTANT: make sure this is done at the end as it depends on the above states\nstate.autoTrack.enabled.value=autoTrackEnabled||pageLifecycleEnabled;if(!pageLifecycleEnabled){return;}this.setupPageUnloadTracking(events,useBeacon,options);}/**\n   * Setup page unload tracking if enabled\n   * @param events\n   * @param useBeacon\n   * @param options\n   */setupPageUnloadTracking(events,useBeacon,options){if(events.length===0||events.includes(PageLifecycleEvents.UNLOADED)){if(useBeacon===true){onPageLeave(isAccessible=>{if(isAccessible===false&&state.lifecycle.loaded.value){const pageUnloadedTimestamp=Date.now();const timeOnPage=pageUnloadedTimestamp-state.autoTrack.pageLifecycle.pageLoadedTimestamp.value;this.track(PageLifecycleEvents.UNLOADED,{timeOnPage},{...options,originalTimestamp:getFormattedTimestamp(new Date(pageUnloadedTimestamp))});}},true);}else {// log warning if beacon is disabled\nthis.logger.warn(PAGE_UNLOAD_ON_BEACON_DISABLED_WARNING(RSA));}}}/**\n   * Trigger load event in buffer queue if exists and stores the\n   * remaining preloaded events array in global object\n   */triggerBufferedLoadEvent(){const preloadedEventsArray=Array.isArray(globalThis.rudderanalytics)?globalThis.rudderanalytics:[];// Get any load method call that is buffered if any\n// BTW, load method is also removed from the array\n// So, the Analytics object can directly consume the remaining events\nconst loadEvent=getPreloadedLoadEvent(preloadedEventsArray);// Set the final preloaded events array in global object\nsetExposedGlobal(GLOBAL_PRELOAD_BUFFER,clone([...preloadedEventsArray]));// Process load method if present in the buffered requests\nif(loadEvent.length>0){// Remove the event name from the Buffered Event array and keep only arguments\nloadEvent.shift();// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nthis.load.apply(null,loadEvent);}}/**\n   * Get ready callback arguments and forward to ready call\n   */ready(callback){try{this.getAnalyticsInstance()?.ready(getSanitizedValue(callback));}catch(error){dispatchErrorEvent(error);}}/**\n   * Process page arguments and forward to page call\n   */// These overloads should be same as AnalyticsPageMethod in @rudderstack/analytics-js-common/types/IRudderAnalytics\npage(category,name,properties,options,callback){try{this.getAnalyticsInstance()?.page(pageArgumentsToCallOptions(getSanitizedValue(category),getSanitizedValue(name),getSanitizedValue(properties),getSanitizedValue(options),getSanitizedValue(callback)));}catch(error){dispatchErrorEvent(error);}}/**\n   * Process track arguments and forward to page call\n   */// These overloads should be same as AnalyticsTrackMethod in @rudderstack/analytics-js-common/types/IRudderAnalytics\ntrack(event,properties,options,callback){try{this.getAnalyticsInstance()?.track(trackArgumentsToCallOptions(getSanitizedValue(event),getSanitizedValue(properties),getSanitizedValue(options),getSanitizedValue(callback)));}catch(error){dispatchErrorEvent(error);}}/**\n   * Process identify arguments and forward to page call\n   */// These overloads should be same as AnalyticsIdentifyMethod in @rudderstack/analytics-js-common/types/IRudderAnalytics\nidentify(userId,traits,options,callback){try{this.getAnalyticsInstance()?.identify(identifyArgumentsToCallOptions(getSanitizedValue(userId),getSanitizedValue(traits),getSanitizedValue(options),getSanitizedValue(callback)));}catch(error){dispatchErrorEvent(error);}}/**\n   * Process alias arguments and forward to page call\n   */// These overloads should be same as AnalyticsAliasMethod in @rudderstack/analytics-js-common/types/IRudderAnalytics\nalias(to,from,options,callback){try{this.getAnalyticsInstance()?.alias(aliasArgumentsToCallOptions(getSanitizedValue(to),getSanitizedValue(from),getSanitizedValue(options),getSanitizedValue(callback)));}catch(error){dispatchErrorEvent(error);}}/**\n   * Process group arguments and forward to page call\n   */// These overloads should be same as AnalyticsGroupMethod in @rudderstack/analytics-js-common/types/IRudderAnalytics\ngroup(groupId,traits,options,callback){try{this.getAnalyticsInstance()?.group(groupArgumentsToCallOptions(getSanitizedValue(groupId),getSanitizedValue(traits),getSanitizedValue(options),getSanitizedValue(callback)));}catch(error){dispatchErrorEvent(error);}}/**\n   * Reset the analytics instance\n   * @param options Reset options. Except for anonymousId, initialReferrer, and initialReferringDomain\n   * all other values will be reset by default.\n   * @example\n   * ```ts\n   * reset({\n   *  entries: {\n   *    anonymousId: true,\n   *  }\n   * });\n   * ```\n   * @example\n   * ```ts\n   * reset({\n   *  entries: {\n   *    userId: false,\n   *    sessionInfo: false,\n   *  }\n   * });\n   * ```\n   * @returns none\n   *//**\n   * Reset the analytics instance\n   * @param resetAnonymousId Reset anonymous ID\n   * @returns none\n   * @deprecated Use reset(options) instead\n   */reset(options){try{this.getAnalyticsInstance()?.reset(getSanitizedValue(options));}catch(error){dispatchErrorEvent(error);}}getAnonymousId(options){try{return this.getAnalyticsInstance()?.getAnonymousId(getSanitizedValue(options));}catch(error){dispatchErrorEvent(error);return undefined;}}setAnonymousId(anonymousId,rudderAmpLinkerParam){try{this.getAnalyticsInstance()?.setAnonymousId(getSanitizedValue(anonymousId),getSanitizedValue(rudderAmpLinkerParam));}catch(error){dispatchErrorEvent(error);}}getUserId(){try{return this.getAnalyticsInstance()?.getUserId();}catch(error){dispatchErrorEvent(error);return undefined;}}getUserTraits(){try{return this.getAnalyticsInstance()?.getUserTraits();}catch(error){dispatchErrorEvent(error);return undefined;}}getGroupId(){try{return this.getAnalyticsInstance()?.getGroupId();}catch(error){dispatchErrorEvent(error);return undefined;}}getGroupTraits(){try{return this.getAnalyticsInstance()?.getGroupTraits();}catch(error){dispatchErrorEvent(error);return undefined;}}startSession(sessionId){try{this.getAnalyticsInstance()?.startSession(getSanitizedValue(sessionId));}catch(error){dispatchErrorEvent(error);}}endSession(){try{this.getAnalyticsInstance()?.endSession();}catch(error){dispatchErrorEvent(error);}}getSessionId(){try{return this.getAnalyticsInstance()?.getSessionId();}catch(error){dispatchErrorEvent(error);return undefined;}}setAuthToken(token){try{this.getAnalyticsInstance()?.setAuthToken(getSanitizedValue(token));}catch(error){dispatchErrorEvent(error);}}consent(options){try{this.getAnalyticsInstance()?.consent(getSanitizedValue(options));}catch(error){dispatchErrorEvent(error);}}addCustomIntegration(destinationId,integration){try{this.getAnalyticsInstance()?.addCustomIntegration(getSanitizedValue(destinationId),getSanitizedValue(integration));}catch(error){dispatchErrorEvent(error);}}}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcnVkZGVyc3RhY2svYW5hbHl0aWNzLWpzL2Rpc3QvbnBtL21vZGVybi9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWSxVQUFVO0FBQ3RCLHdCQUF3QixzQkFBc0IsNENBQTRDLFdBQVcsTUFBTTs7QUFFM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZLFVBQVU7QUFDdEIsd0JBQXdCLHdCQUF3Qix5QkFBeUIsaUJBQWlCLHdEQUF3RCxpQkFBaUIsRUFBRSw4RkFBOEYsaUJBQWlCLHlDQUF5QyxpQkFBaUI7O0FBRTlVO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWSxVQUFVO0FBQ3RCLHdCQUF3QiwwQkFBMEIseUJBQXlCLGlCQUFpQiwyREFBMkQsb0JBQW9CLEVBQUUsZ0dBQWdHLG9CQUFvQiw0Q0FBNEMsb0JBQW9CLHVCQUF1QixtQkFBbUIsRUFBRSx1SUFBdUksb0JBQW9CLCtEQUErRCxvQkFBb0IsK0RBQStELG9CQUFvQix5Q0FBeUMsbUJBQW1CLHlDQUF5QyxtQkFBbUIseUNBQXlDLG1CQUFtQjs7QUFFbDRCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFlBQVk7QUFDWjtBQUNBO0FBQ0EsaUJBQWlCLEdBQUc7QUFDcEIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6Qix1QkFBdUIsR0FBRztBQUMxQiw2QkFBNkIsR0FBRztBQUNoQywyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCLG9EQUFvRCxzR0FBc0c7O0FBRTFKLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLFlBQVk7QUFDWiwrREFBK0Q7O0FBRS9ELDJCQUEyQiwyQ0FBMkM7O0FBRXRFLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsWUFBWSxHQUFHO0FBQ2YsbUNBQW1DLDRCQUE0QjtBQUMvRCx3QkFBd0IsY0FBYyxvQ0FBb0M7QUFDMUUsOEJBQThCLGVBQWUsbUJBQW1CLDJCQUEyQixzQkFBc0Isb0RBQW9ELCtDQUErQyxxQkFBcUIsb0JBQW9CLHVFQUF1RSw4Q0FBOEMsNkNBQTZDLHlDQUF5Qyw4T0FBOE8sdUJBQXVCLDZCQUE2QixzQkFBc0Isc0RBQXNELHVDQUF1QyxzQkFBc0IsWUFBWSxlQUFlLDZDQUE2Qyw2QkFBNkIsK0JBQStCLFlBQVksK0JBQStCLHlCQUF5QixpQkFBaUIsd0NBQXdDLGlCQUFpQixzQkFBc0IsNERBQTRELDBCQUEwQix1Q0FBdUM7QUFDeHhDO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCLHVCQUF1QixZQUFZLGdCQUFnQixNQUFNLHNCQUFzQixxQkFBcUIscUJBQXFCLFFBQVEsNkJBQTZCLCtCQUErQixZQUFZLFFBQVEsWUFBWSxnQkFBZ0IsTUFBTSxzQkFBc0IscUJBQXFCLHNCQUFzQixtQkFBbUI7O0FBRTFYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUcsSUFBSTtBQUNoQixXQUFXLEdBQUc7QUFDZCxZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0EsMkJBQTJCLElBQUksSUFBSTtBQUNuQztBQUNBLGtDQUFrQztBQUNsQyx3Q0FBd0M7QUFDeEMsd0RBQXdELGlGQUFpRjs7QUFFekksMkJBQTJCLFlBQVksWUFBWSxnQkFBZ0IsTUFBTSxjQUFjLGtCQUFrQixnQkFBZ0Isa0JBQWtCLGlCQUFpQixNQUFNLGFBQWE7O0FBRS9LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDaEQsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUNBQXlDO0FBQ2xFLHlCQUF5Qix5Q0FBeUM7QUFDbEUsZUFBZTtBQUNmLDZCQUE2QixZQUFZLElBQUksWUFBWSxNQUFNO0FBQy9ELHVFQUF1RSxjQUFjLE1BQU0sUUFBUSxRQUFRLFlBQVksY0FBYywyQ0FBMkMsWUFBWSwrQkFBK0IsaUJBQWlCLGVBQWU7O0FBRTNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRyxJQUFJLEdBQUcsSUFBSTtBQUNoRCxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjLGlDQUFpQztBQUM1RSw2QkFBNkIsY0FBYyxpQ0FBaUM7QUFDNUUsZUFBZSx1QkFBdUI7QUFDdEMscUZBQXFGLDBDQUEwQyxxQ0FBcUMsdUNBQXVDLE1BQU0seUJBQXlCLGFBQWE7O0FBRXZQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsR0FBRyxJQUFJLEdBQUcsSUFBSTtBQUN4QyxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYyxtQkFBbUI7QUFDM0QsMEJBQTBCLGNBQWMsbUJBQW1CO0FBQzNELGVBQWUsdUJBQXVCO0FBQ3RDLCtFQUErRSw4Q0FBOEMsc0JBQXNCLGFBQWE7O0FBRWhLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixHQUFHO0FBQ3JCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxNQUFNLEdBQUc7QUFDekMsNEJBQTRCLElBQUksTUFBTSxHQUFHO0FBQ3pDLCtCQUErQixJQUFJLGNBQWMsR0FBRztBQUNwRCxnQ0FBZ0MsSUFBSSxjQUFjLEdBQUc7QUFDckQscUJBQXFCLE9BQU8sR0FBRztBQUMvQixzQkFBc0IsVUFBVSxHQUFHO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTSxJQUFJO0FBQzFDLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUIsR0FBRyxNQUFNO0FBQy9ELDZEQUE2RCxjQUFjLHFCQUFxQiw2QkFBNkIseUJBQXlCLGVBQWU7O0FBRXJLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDhDQUE4Qyx5RkFBeUYseUNBQXlDO0FBQy9NO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxtQ0FBbUMsNkJBQTZCLG1FQUFtRSw4Q0FBOEM7QUFDdE47QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsMERBQTBELDBCQUEwQixtQ0FBbUMsbUNBQW1DO0FBQ3ZOLGdEQUFnRCxFQUFFLHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1IQUFtSDtBQUNuSDtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1DQUFtQyxrQ0FBa0Msd0JBQXdCLHFDQUFxQywyQ0FBMkMsRUFBRSxnQkFBZ0I7QUFDcE87QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZDQUE2QyxrQ0FBa0Msd0JBQXdCLHFDQUFxQyxrREFBa0QsRUFBRSxnQkFBZ0I7QUFDNVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCLGVBQWU7QUFDMUUsOEJBQThCO0FBQzlCO0FBQ0Esd0NBQXdDLDJCQUEyQixrQkFBa0IsMkNBQTJDO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix1QkFBdUIsdURBQXVELDJDQUEyQyx3QkFBd0IsRUFBRTs7QUFFdE8sa0RBQWtELDBEQUEwRDtBQUM1RztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZSw0Q0FBNEMsSUFBSSw0QkFBNEIsU0FBUyxjQUFjLGdCQUFnQjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzRUFBc0Usb0NBQW9DO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixlQUFlLHNGQUFzRix5QkFBeUIsMkJBQTJCLHdCQUF3QiwwQkFBMEIsa0JBQWtCLDhCQUE4QiwwQkFBMEIsMEJBQTBCLDJCQUEyQiwwQkFBMEIsa0JBQWtCLDZCQUE2QiwwQkFBMEIsNkJBQTZCLHFCQUFxQiwwQkFBMEIsdUJBQXVCLDZCQUE2QiwwQkFBMEIsdUJBQXVCLHlCQUF5QiwyQkFBMkIsdUJBQXVCLDZCQUE2QiwwQkFBMEIsMkJBQTJCLHdDQUF3Qyx1QkFBdUIsMkJBQTJCLDRCQUE0QixzQkFBc0Isc0JBQXNCLE1BQU0sNEJBQTRCLHlDQUF5Qyx1QkFBdUIsd0JBQXdCLDRCQUE0Qiw0QkFBNEIsTUFBTSw0QkFBNEI7QUFDbnNDO0FBQ0Esd0NBQXdDLDJCQUEyQix1QkFBdUI7QUFDMUY7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEIsNkJBQTZCLHdCQUF3QixtRUFBbUUsK0JBQStCLHdDQUF3QyxNQUFNLDJCQUEyQixvRkFBb0Ysb0dBQW9HO0FBQ3JkLHFHQUFxRyxFQUFFLHdCQUF3Qix1QkFBdUIsOEJBQThCLCtCQUErQixFQUFFLEVBQUUsaUJBQWlCO0FBQ3hPO0FBQ0EsMkVBQTJFLGVBQWUscUVBQXFFLHlCQUF5QiwyQkFBMkIsd0JBQXdCLDhCQUE4QiwwQkFBMEIsMEJBQTBCLDJCQUEyQiw2QkFBNkIsMEJBQTBCLDZCQUE2QjtBQUM1YTtBQUNBO0FBQ0Esd0ZBQXdGLCtCQUErQix3Q0FBd0MsTUFBTSwyQkFBMkIsaUJBQWlCO0FBQ2pOO0FBQ0EsMkVBQTJFLGVBQWUsZ0VBQWdFLHlCQUF5QiwyQkFBMkIsd0JBQXdCLHNCQUFzQixzQkFBc0IsMEJBQTBCLDBCQUEwQix1QkFBdUIsc0JBQXNCLHlCQUF5QiwwQkFBMEIseUJBQXlCLHNEQUFzRDtBQUNyZjtBQUNBLG9CQUFvQixzQkFBc0Isd0JBQXdCLHdCQUF3QixNQUFNLDRCQUE0QjtBQUM1SDtBQUNBO0FBQ0EsNENBQTRDLDhDQUE4QyxzQ0FBc0MsTUFBTSwwQkFBMEIsK0JBQStCLHdDQUF3QyxNQUFNLDJCQUEyQixpQkFBaUI7QUFDelI7QUFDQSxrRUFBa0UsZUFBZSxpREFBaUQseUJBQXlCLDJCQUEyQix3QkFBd0IsY0FBYyxrQkFBa0IsMEJBQTBCLDBCQUEwQixxQkFBcUIsY0FBYyx1QkFBdUIsMEJBQTBCLHVCQUF1Qix1REFBdUQsY0FBYyx1QkFBdUIsc0JBQXNCO0FBQy9mO0FBQ0E7QUFDQSwwQkFBMEIscUNBQXFDLDRCQUE0Qix5Q0FBeUMsTUFBTSx3QkFBd0IsK0JBQStCLHdDQUF3QyxNQUFNLDJCQUEyQixpQkFBaUI7QUFDM1I7QUFDQSx5RUFBeUUsZUFBZSxrRUFBa0UseUJBQXlCLDJCQUEyQix3QkFBd0Isd0JBQXdCLHNCQUFzQiwwQkFBMEIsMEJBQTBCLHVCQUF1Qix3QkFBd0IseUJBQXlCLDBCQUEwQix5QkFBeUIsd0RBQXdEO0FBQzNmO0FBQ0EscUJBQXFCLHVCQUF1Qix3QkFBd0Isd0JBQXdCLE1BQU0sNEJBQTRCO0FBQzlIO0FBQ0E7QUFDQSw4Q0FBOEMsOENBQThDLHNDQUFzQyxNQUFNLDBCQUEwQiwrQkFBK0Isd0NBQXdDLE1BQU0sMkJBQTJCOztBQUUxUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGdEQUFnRCw0QkFBNEIsR0FBRyxFQUFFO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixpREFBaUQscUNBQXFDLG1DQUFtQyx1Q0FBdUMsZ0RBQWdELG1DQUFtQyxtQ0FBbUMsbUNBQW1DLHdCQUF3QixXQUFXLEVBQUUsc0JBQXNCLFdBQVcsRUFBRSwrQkFBK0IsaUNBQWlDOztBQUV4ZCxxQkFBcUI7O0FBRXJCLHdDQUF3QyxLQUFLLFVBQVUsU0FBUyxvREFBb0QsZ0JBQWdCLDZCQUE2QixzQkFBc0IsU0FBUyxtQkFBbUIsS0FBSyxLQUFLLEtBQUssc0JBQXNCLDhCQUE4QixvQ0FBb0MscUJBQXFCLDRCQUE0QixVQUFVOztBQUVyWCwwQkFBMEIseURBQXlELGNBQWMsbUJBQW1CLHdCQUF3QixvQkFBb0Isd0NBQXdDLFNBQVMsS0FBSyxLQUFLLEtBQUssa0JBQWtCLDRCQUE0QixrQ0FBa0MsbUJBQW1CLDRCQUE0QixNQUFNOztBQUVyVzs7QUFFQSx3QkFBd0Isa0JBQWtCLGVBQWU7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSxtQkFBbUIsdUJBQXVCLHlCQUF5QixhQUFhLFFBQVEsY0FBYyx1QkFBdUI7QUFDN0g7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0IsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0RBQWdELG1CQUFtQixpQkFBaUIsR0FBRztBQUM5SDtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQixpQkFBaUIsRUFBRSx5Q0FBeUMsZ0JBQWdCLEVBQUU7QUFDeEksMENBQTBDLGlEQUFpRCxpQkFBaUIsRUFBRTtBQUM5RyxrREFBa0Qsa0JBQWtCLHdDQUF3QyxpQkFBaUIsTUFBTSxpQkFBaUI7O0FBRXBKLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLCtEQUErRCxHQUFHLCtFQUErRSx3REFBd0Qsd0JBQXdCLDRCQUE0QixHQUFHLGNBQWMsSUFBSSxHQUFHLGtFQUFrRSxTQUFTLHVEQUF1RCxHQUFHLGNBQWMsSUFBSSxHQUFHLG1EQUFtRCxRQUFRLEVBQUUsc0JBQXNCLHlFQUF5RSxJQUFJLHFDQUFxQyw2RUFBNkUscUVBQXFFLG9FQUFvRSxRQUFRLEVBQUUsc0JBQXNCLE9BQU8sWUFBWTs7QUFFLzVCLHFDQUFxQyxxQ0FBcUMsNERBQTRELDZEQUE2RCxtQkFBbUI7QUFDdE47QUFDQSwyQkFBMkIsK0JBQStCLGtCQUFrQiwwQ0FBMEMsa0JBQWtCLDJDQUEyQyxjQUFjO0FBQ2pNO0FBQ0E7QUFDQSxnRUFBZ0UsaUJBQWlCLDhCQUE4Qiw2REFBNkQsdUNBQXVDLHNCQUFzQixpQkFBaUI7QUFDMVA7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckI7QUFDQSwyRUFBMkUsSUFBSSxrRkFBa0YsV0FBVyx5Q0FBeUMsZUFBZSwyQkFBMkIsbUJBQW1CO0FBQ2xSO0FBQ0Esb0NBQW9DLG9CQUFvQiwyQkFBMkI7QUFDbkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnRUFBZ0UsZ0JBQWdCO0FBQ2hGLENBQUM7QUFDRCw4QkFBOEIsdUNBQXVDO0FBQ3JFLHNCQUFzQixpQkFBaUIsd0NBQXdDO0FBQy9FLHNDQUFzQztBQUN0QztBQUNBLHNCQUFzQix3Q0FBd0MscUJBQXFCO0FBQ25GLGtEQUFrRDtBQUNsRCw2RUFBNkUsdURBQXVELE1BQU0sOEJBQThCLGdCQUFnQjtBQUN4TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZCQUE2QjtBQUN6RSw2Q0FBNkMsMkRBQTJELHlDQUF5Qzs7QUFFakosdURBQXVELDBCQUEwQixNQUFNLGtEQUFrRCxLQUFLLG9EQUFvRCxpREFBaUQsb0JBQW9CLG1CQUFtQjtBQUMxUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0Isb0JBQW9CLE1BQU0sSUFBSSw4QkFBOEIsSUFBSSxJQUFJO0FBQ25JLHVDQUF1Qyx1Q0FBdUMsTUFBTSxJQUFJLFlBQVksR0FBRztBQUN2RywrQkFBK0IsVUFBVSxzQkFBc0I7QUFDL0QsOENBQThDLGlEQUFpRCxJQUFJLHdCQUF3QixNQUFNO0FBQ2pJLEdBQUcsRUFBRSxpQkFBaUIsTUFBTSxvQkFBb0IsTUFBTSxJQUFJLDhCQUE4QixNQUFNLGlDQUFpQyx5QkFBeUIsb0NBQW9DLGFBQWEsTUFBTSxrREFBa0QsT0FBTyxpQkFBaUI7QUFDelIsZUFBZSxNQUFNLElBQUksd0JBQXdCLEVBQUUsTUFBTTtBQUN6RCxvQkFBb0IsV0FBVyxJQUFJLHdCQUF3QixFQUFFLE1BQU07QUFDbkUsNEJBQTRCLGVBQWUsSUFBSSx3QkFBd0IsRUFBRSxTQUFTLGlEQUFpRCxpREFBaUQ7O0FBRXBMLDJDQUEyQywyQkFBMkIsZ0RBQWdELHdCQUF3QixpREFBaUQsZ0RBQWdELHNDQUFzQyxvREFBb0Q7O0FBRXpVLDRDQUE0Qyw4Q0FBOEMsNkNBQTZDLHdDQUF3Qzs7QUFFL0sscUNBQXFDO0FBQ3JDLDhDQUE4QztBQUM5Qyx3REFBd0Q7QUFDeEQsNENBQTRDO0FBQzVDLHFDQUFxQztBQUNyQywwREFBMEQ7QUFDMUQsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0EsNERBQTRELG1DQUFtQyxrQ0FBa0Msd0RBQXdELHlEQUF5RDtBQUNsUDtBQUNBLHNFQUFzRSwwQ0FBMEMsb0VBQW9FO0FBQ3BMO0FBQ0EsZ0VBQWdFLDBDQUEwQyxxRUFBcUUsMkRBQTJELGNBQWMsbUJBQW1CLG1DQUFtQyxxQ0FBcUMsMEJBQTBCOztBQUU3VztBQUNBO0FBQ0EsbUVBQW1FLGNBQWMsNkJBQTZCLHVDQUF1QztBQUNySix1REFBdUQ7QUFDdkQsZ0NBQWdDLEVBQUUsY0FBYztBQUNoRDtBQUNBLDZEQUE2RDtBQUM3RCxvQ0FBb0MsdUVBQXVFLGtFQUFrRTtBQUM3SyxzREFBc0Qsc0tBQXNLO0FBQzVOLHNEQUFzRCw2RkFBNkYseUNBQXlDO0FBQzVMLDJEQUEyRCx5REFBeUQ7QUFDcEgsa0RBQWtELDRGQUE0RjtBQUM5STtBQUNBLHNEQUFzRCw0QkFBNEIsaUJBQWlCO0FBQ25HO0FBQ0EsYUFBYSxxQ0FBcUMseUVBQXlFLHlDQUF5QyxpQ0FBaUMsT0FBTyxNQUFNLG1CQUFtQjtBQUNyTztBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsa0NBQWtDLHFHQUFxRyx3R0FBd0c7QUFDbFQ7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQSxnREFBZ0QsdUVBQXVFO0FBQ3ZILG9EQUFvRDtBQUNwRCxrQ0FBa0MsMERBQTBELDhDQUE4Qyw4REFBOEQsK0JBQStCLGdCQUFnQiw4Q0FBOEMsbUJBQW1CLDZEQUE2RCxNQUFNLCtEQUErRCxNQUFNLHFFQUFxRSxNQUFNLCtEQUErRCxNQUFNLCtEQUErRCxNQUFNLGdEQUFnRCxPQUFPLGdCQUFnQjs7QUFFNXRCLDhDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBLDJGQUEyRixJQUFJLHFEQUFxRCxxQ0FBcUMsNEJBQTRCLDhCQUE4QixzQkFBc0Isb0JBQW9CLDBCQUEwQixxREFBcUQsMEVBQTBFLEVBQUUsc0VBQXNFLHVCQUF1QjtBQUNyaEI7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMseURBQXlELDBCQUEwQiw0RUFBNEUsUUFBUTtBQUN2Syw2REFBNkQsMkRBQTJELCtFQUErRSxRQUFRO0FBQy9NLGlEQUFpRCwwQ0FBMEMsMkRBQTJELGdFQUFnRTtBQUN0TjtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBLGtHQUFrRywrQ0FBK0MsaUJBQWlCLG9EQUFvRCxJQUFJLGNBQWMsa0JBQWtCLG1DQUFtQyxjQUFjLG1CQUFtQixtQ0FBbUMsa0RBQWtEO0FBQ25aLCtFQUErRTtBQUMvRSxxQ0FBcUMsOERBQThELFdBQVcsV0FBVyxtRUFBbUU7O0FBRTVMO0FBQ0E7QUFDQSwyQkFBMkIsNERBQTRELG1CQUFtQixzQkFBc0I7QUFDaEk7QUFDQSx3QkFBd0IsTUFBTSw4Q0FBOEMsUUFBUSw0Q0FBNEMsMkVBQTJFLHFCQUFxQixlQUFlLGNBQWMscUJBQXFCLG1CQUFtQjs7QUFFclMsbUNBQW1DLGFBQWEsV0FBVyxjQUFjLGtCQUFrQixRQUFRLFNBQVMsSUFBSSxrQkFBa0IsVUFBVSxXQUFXLFFBQVEsc0JBQXNCLE9BQU8sU0FBUyxPQUFPLElBQUksU0FBUyxNQUFNLElBQUksSUFBSSxjQUFjLFVBQVUsY0FBYyxrQkFBa0IsSUFBSSxJQUFJLFlBQVksUUFBUSxNQUFNLGFBQWEsY0FBYyxRQUFRLFNBQVMsSUFBSSxZQUFZLFFBQVEsTUFBTSx5QkFBeUIsY0FBYyxlQUFlLFVBQVUsd0JBQXdCLEdBQUcsa0RBQWtELHdCQUF3QixNQUFNLE1BQU0saUJBQWlCLFVBQVUsa0JBQWtCLE1BQU0saUJBQWlCLFVBQVUsMEJBQTBCLFFBQVEsV0FBVyxRQUFRLE9BQU8sWUFBWSxnQkFBZ0IsU0FBUyxTQUFTLGNBQWMsY0FBYyxnQ0FBZ0Msa0NBQWtDLGlDQUFpQyxvQkFBb0IseUJBQXlCLGVBQWUsMEJBQTBCLG9CQUFvQix3QkFBd0IsTUFBTSxTQUFTLG9CQUFvQixrQkFBa0IsTUFBTSwwQkFBMEIsS0FBSywwQkFBMEIsV0FBVyxvQkFBb0IsZ0JBQWdCLGVBQWUsTUFBTSxZQUFZLGVBQWUsTUFBTSxZQUFZLGVBQWUsU0FBUywyQkFBMkIsTUFBTSwwQkFBMEIsTUFBTSxrQ0FBa0MsV0FBVyxvQkFBb0Isa0JBQWtCLFNBQVMsSUFBSSxNQUFNLFFBQVEsTUFBTSxFQUFFLFdBQVcsSUFBSSwrQkFBK0Isb0JBQW9CLGdDQUFnQyx1QkFBdUIsOEJBQThCLG9CQUFvQiw0QkFBNEIsUUFBUSxTQUFTLElBQUksbUJBQW1CLFFBQVEsT0FBTywyQ0FBMkMsZUFBZSxjQUFjLHlCQUF5QixlQUFlLGlCQUFpQixlQUFlLDJDQUEyQyxTQUFTLFNBQVMsSUFBSSxJQUFJLElBQUksaUJBQWlCLFdBQVcsZUFBZSxRQUFRLFFBQVEsRUFBRSxnQkFBZ0IsbUJBQW1CLGNBQWMsY0FBYyxXQUFXLHlEQUF5RCxlQUFlLGNBQWMsY0FBYyxXQUFXLE9BQU8sWUFBWSxvQkFBb0IsUUFBUSxPQUFPLGlCQUFpQixNQUFNLFNBQVMsY0FBYyxtQkFBbUIsa0JBQWtCLFVBQVUsYUFBYSxTQUFTLHNCQUFzQix5QkFBeUIsU0FBUyxVQUFVLDJCQUEyQixLQUFLLE9BQU8sZ0JBQWdCLG9CQUFvQixTQUFTLGNBQWMsV0FBVyxTQUFTLGdDQUFnQyxrQ0FBa0MsaUNBQWlDLG9CQUFvQix5QkFBeUIsV0FBVywwQkFBMEIsZ0NBQWdDLFdBQVcsMkJBQTJCLFNBQVMsVUFBVSx1QkFBdUIsV0FBVyxjQUFjLFFBQVEsSUFBSSxRQUFRLE9BQU8sZUFBZSxzQ0FBc0MsU0FBUyxZQUFZLFdBQVcsU0FBUyxTQUFTLFdBQVcsVUFBVSxJQUFJLFFBQVEsV0FBVyxlQUFlLDBCQUEwQixvQkFBb0IsV0FBVyxpQkFBaUIsV0FBVyxnQkFBZ0IsNkJBQTZCLDBCQUEwQixvQkFBb0IsMkJBQTJCLG9CQUFvQixZQUFZLGlCQUFpQixXQUFXLG1CQUFtQix5QkFBeUIsZ0JBQWdCLFVBQVUsaUJBQWlCLFdBQVcsaUJBQWlCLDJDQUEyQyxlQUFlLDhDQUE4QyxjQUFjLFNBQVMseUJBQXlCLDBCQUEwQixnQkFBZ0IsRUFBRSxjQUFjLFVBQVUsV0FBVyx5QkFBeUIsSUFBSSxRQUFRLFNBQVMsSUFBSSxLQUFLLFNBQVMsUUFBUSxPQUFPLEtBQUssU0FBUyxRQUFRLElBQUksT0FBTyxjQUFjLGNBQWMsV0FBVyxlQUFlLFdBQVcsV0FBVyxNQUFNLGNBQWMsbURBQW1ELFFBQVEsSUFBSSxXQUFXLG9CQUFvQixLQUFLLGdCQUFnQixTQUFTLGNBQWMsY0FBYyxjQUFjLFVBQVUsaUNBQWlDLHlCQUF5QixlQUFlLElBQUksbUJBQW1CLDBCQUEwQixlQUFlLGtDQUFrQyxRQUFRLE9BQU8seUJBQXlCLDhDQUE4QyxVQUFVLFdBQVcsUUFBUSxRQUFRLElBQUksUUFBUSxPQUFPLHdCQUF3Qix5QkFBeUIsZ0JBQWdCLFVBQVUsU0FBUyxVQUFVLHlCQUF5QixVQUFVLHlCQUF5QiwrQkFBK0IsV0FBVyxnQkFBZ0IsaUJBQWlCLElBQUksT0FBTyxTQUFTLE1BQU0sU0FBUyxrQkFBa0Isb0JBQW9COztBQUUxaEo7QUFDQTtBQUNBLHFCQUFxQixjQUFjLGVBQWUsY0FBYyx1QkFBdUIsVUFBVSwwQkFBMEIsYUFBYSwyQkFBMkIsVUFBVSw4QkFBOEIsT0FBTywwQkFBMEIsUUFBUTs7QUFFcFAscUJBQXFCLDRDQUE0Qyw4QkFBOEIsa0NBQWtDLDhCQUE4QiwrQ0FBK0MsbUJBQW1CLGFBQWEsRUFBRSx5Q0FBeUMsRUFBRTtBQUMzUjtBQUNBLGdCQUFnQix3RUFBd0UsNENBQTRDLGlCQUFpQiw4QkFBOEIsYUFBYSw0QkFBNEIsY0FBYyw2QkFBNkIsZUFBZSw4QkFBOEIsY0FBYyw2QkFBNkIsZUFBZSw4QkFBOEIsMEJBQTBCLCtDQUErQywyRUFBMkUsbUJBQW1CLGlDQUFpQztBQUNwbEI7QUFDQSx5QkFBeUIseUNBQXlDLGtDQUFrQyxvREFBb0Q7QUFDeEo7QUFDQSx5QkFBeUIsdUNBQXVDO0FBQ2hFLGNBQWMsZUFBZSxFQUFFO0FBQy9CLGVBQWUsT0FBTyxLQUFLLElBQUksV0FBVyxHQUFHO0FBQzdDLHNEQUFzRDtBQUN0RCxPQUFPLEtBQUssS0FBSyxZQUFZLEVBQUU7QUFDL0I7QUFDQSxFQUFFO0FBQ0YsdUJBQXVCLDZCQUE2QjtBQUNwRCxxQ0FBcUMsc0JBQXNCLGNBQWM7O0FBRXpFLCtDQUErQyxpREFBaUQscURBQXFELDREQUE0RCxrQkFBa0IsR0FBRzs7QUFFdE87QUFDQSx1R0FBdUc7O0FBRXZHLDZGQUE2RixnSEFBZ0gsdUVBQXVFLDRHQUE0Ryw0R0FBNEcsNkNBQTZDLFFBQVEsRUFBRSxzQkFBc0Isd0dBQXdHLDJEQUEyRCxRQUFRLEVBQUUsc0JBQXNCLGdCQUFnQixJQUFJLFFBQVEsV0FBVyxlQUFlO0FBQ2x6Qiw0R0FBNEcsUUFBUSxFQUFFLHNCQUFzQix1QkFBdUIsdUJBQXVCLHNGQUFzRiw0Q0FBNEMsSUFBSSw2Q0FBNkMsUUFBUSxFQUFFLHNCQUFzQix3QkFBd0IsT0FBTyxHQUFHLGtEQUFrRCx1Q0FBdUMsUUFBUSxFQUFFLHNCQUFzQiw2QkFBNkIsNENBQTRDLFFBQVEsRUFBRSxzQkFBc0IseUJBQXlCLDJEQUEyRCxRQUFRLEVBQUUsc0JBQXNCLFVBQVUsV0FBVyxtQkFBbUIsc0RBQXNELFFBQVEsRUFBRSxzQkFBc0IsVUFBVSxXQUFXLGNBQWMsdURBQXVELFFBQVEsRUFBRSxzQkFBc0IsVUFBVSxXQUFXLDBJQUEwSSw4REFBOEQsUUFBUSxFQUFFLHNCQUFzQixVQUFVLFdBQVcsMERBQTBELGFBQWEsaUJBQWlCLGdFQUFnRSxRQUFRLEVBQUUsc0JBQXNCLHdCQUF3QixTQUFTLCtCQUErQixXQUFXLElBQUksb0VBQW9FLHdEQUF3RCxRQUFRLEVBQUUsc0JBQXNCLGlCQUFpQixTQUFTLHdHQUF3RyxpRUFBaUUsUUFBUSxFQUFFLHNCQUFzQixzQkFBc0IsYUFBYSw2R0FBNkcsNENBQTRDLFFBQVEsRUFBRSxzQkFBc0Isb0RBQW9ELHFFQUFxRSxRQUFRLGNBQWMsUUFBUSxHQUFHLFdBQVcsYUFBYSxJQUFJLGNBQWMsZ0JBQWdCLEVBQUUsMkNBQTJDLFFBQVEsbUNBQW1DLFlBQVksZ0NBQWdDLElBQUksRUFBRSxzQ0FBc0MsUUFBUSxXQUFXLElBQUksRUFBRSxrRUFBa0UsSUFBSSxjQUFjLDJFQUEyRSxJQUFJLGdCQUFnQixpRkFBaUYsUUFBUSxnRkFBZ0YsbUZBQW1GLEtBQUssNkRBQTZELHdKQUF3SjtBQUN2cEcsbUZBQW1GLFFBQVEsRUFBRSxzQkFBc0Isb0JBQW9CLFlBQVksMkVBQTJFLHdCQUF3Qix1QkFBdUIsbUJBQW1CLHlCQUF5Qiw0SkFBNEosUUFBUSxFQUFFLHNCQUFzQixrQ0FBa0MsaUNBQWlDLDhFQUE4RSxzREFBc0QsMEJBQTBCLGVBQWUseUJBQXlCLG9HQUFvRyxRQUFRLEVBQUUsc0JBQXNCLGtHQUFrRyx5QkFBeUIsdUJBQXVCLGVBQWUsMEdBQTBHLHlHQUF5RyxRQUFRLEVBQUUsc0JBQXNCLDhCQUE4QixxQkFBcUIsaURBQWlELG9CQUFvQixnREFBZ0QscUZBQXFGLFFBQVEsRUFBRSxzQkFBc0IsT0FBTyxTQUFTLDRCQUE0QixjQUFjLDhHQUE4RyxpQkFBaUIsSUFBSSxvREFBb0QsV0FBVyxFQUFFLHNCQUFzQixvSUFBb0ksaURBQWlELFFBQVEsRUFBRSxzQkFBc0IsNkZBQTZGLG9FQUFvRSxRQUFRLEVBQUUsc0JBQXNCLDZCQUE2QixRQUFRLDRDQUE0QyxjQUFjLDBCQUEwQixvRkFBb0YsUUFBUSxFQUFFLHNCQUFzQixzQ0FBc0MsZUFBZSxxREFBcUQsY0FBYywwQkFBMEIsc0ZBQXNGLFFBQVEsRUFBRSxzQkFBc0Isc0NBQXNDLGVBQWUsK0NBQStDLFFBQVEsbURBQW1ELHVDQUF1QyxRQUFRLEVBQUUsc0JBQXNCLHlMQUF5TCx1RUFBdUUsUUFBUSxFQUFFLHNCQUFzQiw0QkFBNEIsU0FBUyw2Q0FBNkMsWUFBWSxpR0FBaUcsNEVBQTRFLFFBQVEsRUFBRSxzQkFBc0IsMkJBQTJCLFVBQVUsZ0VBQWdFLG1CQUFtQixpRUFBaUUsaURBQWlELFFBQVEsRUFBRSxzQkFBc0IsK0dBQStHLDJGQUEyRixRQUFRLEVBQUUsc0JBQXNCLG9CQUFvQixvQkFBb0IsZ0NBQWdDLE1BQU0sNkNBQTZDLGlCQUFpQix5QkFBeUIsd0NBQXdDLFFBQVEsRUFBRSxzQkFBc0IsaUNBQWlDLHlEQUF5RCxRQUFRLEVBQUUsc0JBQXNCLGtDQUFrQyxVQUFVLDREQUE0RCxnR0FBZ0csU0FBUyxhQUFhLElBQUksR0FBRyw4RkFBOEYsUUFBUSxFQUFFLHNCQUFzQixvQ0FBb0MsaUJBQWlCLG1JQUFtSSxnQkFBZ0IseUJBQXlCLDBHQUEwRyxRQUFRLEVBQUUsc0JBQXNCLHdDQUF3QyxxQkFBcUIsaUhBQWlILG9CQUFvQix5QkFBeUIseURBQXlELFFBQVEsRUFBRSxzQkFBc0IsRUFBRSxZQUFZLG9FQUFvRSxpSEFBaUgsK0NBQStDLHdDQUF3QyxrQkFBa0Isb0JBQW9CLDRCQUE0QixpQkFBaUIscUJBQXFCLFFBQVEsRUFBRSxzQkFBc0IsRUFBRSxvQkFBb0IsT0FBTyxlQUFlLHlCQUF5Qiw0QkFBNEIsVUFBVSxhQUFhLE1BQU0sNkNBQTZDLGdDQUFnQyxVQUFVLGFBQWEsNkRBQTZELDRCQUE0QixxQ0FBcUMsbUVBQW1FLFFBQVEsRUFBRSxzQkFBc0IsNkJBQTZCLGtCQUFrQiw4REFBOEQseURBQXlELFFBQVEsRUFBRSxzQkFBc0IseUhBQXlILDJEQUEyRCxRQUFRLEVBQUUsc0JBQXNCLDRCQUE0QiwwQkFBMEIsR0FBRywyRUFBMkUsUUFBUSxFQUFFLHNCQUFzQixvREFBb0QsY0FBYzs7QUFFcjBOLG1DQUFtQzs7QUFFbkMsb0NBQW9DLGdDQUFnQztBQUNwRSw2REFBNkQsR0FBRztBQUNoRTtBQUNBLCtDQUErQyxFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLDBCQUEwQixvREFBb0QsZ0NBQWdDLHNDQUFzQyxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyxXQUFXLEdBQUcsWUFBWSxFQUFFLDZCQUE2QixpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyxXQUFXLEdBQUcsZ0JBQWdCLEVBQUU7O0FBRXJVLDhDQUE4QyxnREFBZ0Qsc0NBQXNDLDZIQUE2SCxnREFBZ0QsMkZBQTJGLCtDQUErQyx1RUFBdUUsaURBQWlELDRDQUE0Qzs7QUFFL2xCLDBCQUEwQiwrREFBK0QsMERBQTBELGVBQWUsNEhBQTRILDRCQUE0QixnQkFBZ0IseVBBQXlQLFlBQVksMkNBQTJDLHdCQUF3QiwrRkFBK0YsNkJBQTZCOztBQUU5d0IsOENBQThDLHVCQUF1Qix5Q0FBeUMsNERBQTRELGdCQUFnQixFQUFFLHdDQUF3QyxTQUFTO0FBQzdPLHNFQUFzRSxFQUFFLDJDQUEyQzs7QUFFbkgsb0JBQW9COztBQUVwQix5QkFBeUIsMEJBQTBCLHNHQUFzRzs7QUFFekosc0JBQXNCOztBQUV0Qjs7QUFFQSxzQkFBc0I7O0FBRXRCLHFCQUFxQiwrQ0FBK0MsNERBQTRELGNBQWMsa0JBQWtCOztBQUVoSyxvQkFBb0I7O0FBRXBCLG9CQUFvQixPQUFPLGtGQUFrRiw0QkFBNEIsaUZBQWlGLHlEQUF5RCxtQkFBbUIsMkJBQTJCLHNEQUFzRDs7QUFFdlgsK0JBQStCLCtFQUErRSx5SUFBeUk7O0FBRXZQLHdCQUF3Qjs7QUFFeEIsb0JBQW9COztBQUVwQixvQkFBb0IscUdBQXFHOztBQUV6SCw4QkFBOEI7O0FBRTlCLDRCQUE0QjtBQUM1Qjs7QUFFQSxzQkFBc0IsZ0NBQWdDOztBQUV0RCwwQkFBMEIsbWJBQW1iLGFBQWE7O0FBRTFkO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCLG9CQUFvQjs7QUFFcEIsb0NBQW9DLDBCQUEwQiw2QkFBNkIscURBQXFELHdCQUF3Qiw0QkFBNEIsd0JBQXdCLDJCQUEyQiwyQkFBMkIsd0JBQXdCLHNCQUFzQiwyQ0FBMkMsMEJBQTBCLHFEQUFxRCxvQkFBb0Isa0JBQWtCLGtCQUFrQixvRUFBb0UsK0NBQStDLHFEQUFxRCx3QkFBd0IsK0JBQStCLCtFQUErRSx5QkFBeUIsZUFBZSxZQUFZLGVBQWUsS0FBSyw4QkFBOEIsb0RBQW9ELHNCQUFzQixtQkFBbUIsa0JBQWtCLHFCQUFxQix5REFBeUQsOENBQThDLGFBQWEsMEJBQTBCLHdCQUF3QiwyQkFBMkIsNEJBQTRCLG1CQUFtQiw2QkFBNkIsbUNBQW1DLE1BQU0scUVBQXFFLHFCQUFxQixvQ0FBb0Msd0NBQXdDLDRDQUE0Qyw0Q0FBNEMscUJBQXFCLGFBQWEsZ0VBQWdFLDhDQUE4QyxpQkFBaUIsdUVBQXVFLG1EQUFtRCwyREFBMkQsb0NBQW9DLHNDQUFzQyxpREFBaUQsaUVBQWlFLGlEQUFpRCxvQ0FBb0Msa0VBQWtFLHNCQUFzQix3QkFBd0IsMkJBQTJCLHVCQUF1Qix1SUFBdUksSUFBSSxZQUFZLHNCQUFzQixLQUFLLGtGQUFrRixxRUFBcUUsbUJBQW1CLHNCQUFzQixtQkFBbUIsWUFBWSxzQkFBc0IsS0FBSyxrRkFBa0YscUVBQXFFLG1CQUFtQixrQkFBa0IsNENBQTRDLHFCQUFxQixtQkFBbUIsWUFBWSxxQkFBcUIsS0FBSyxnRkFBZ0Ysb0VBQW9FLG1CQUFtQixxQkFBcUIsa0JBQWtCLG1CQUFtQixHQUFHLGdCQUFnQjs7QUFFN3hHLGdEQUFnRCxnQ0FBZ0MsbUNBQW1DLGlFQUFpRSw4QkFBOEIsNEJBQTRCLHdCQUF3QiwyQkFBMkIsOENBQThDLHlEQUF5RCwrQ0FBK0MsNERBQTRELDREQUE0RCxRQUFRO0FBQ3ZqQjtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsc0JBQXNCLE9BQU87QUFDN0IsMkRBQTJELHlGQUF5RiwrQkFBK0IsZ0VBQWdFLGdDQUFnQyxxQkFBcUIsb0NBQW9DLE1BQU0scURBQXFEO0FBQ3ZZLG9FQUFvRTtBQUNwRSw4QkFBOEIsa0JBQWtCLDBDQUEwQyxtREFBbUQsMkRBQTJELDJEQUEyRCwyREFBMkQsNkNBQTZDLE9BQU8sbUNBQW1DLDhCQUE4QjtBQUNuYixpRkFBaUYsNEZBQTRGO0FBQzdLO0FBQ0EsK0NBQStDO0FBQy9DLDJFQUEyRTtBQUMzRTtBQUNBLDJFQUEyRSxvREFBb0QsNEZBQTRGLHVCQUF1QixrSEFBa0gsR0FBRyxRQUFRLG1FQUFtRSwyREFBMkQsK0NBQStDLE9BQU8sbUNBQW1DO0FBQ3RrQiwrQkFBK0IsNkVBQTZFLG1EQUFtRDtBQUMvSix1QkFBdUIsa0JBQWtCLEdBQUcsTUFBTSxtREFBbUQsMENBQTBDLDBEQUEwRCwyRUFBMkUsdUJBQXVCLDBIQUEwSCxJQUFJLFFBQVEscURBQXFELDRHQUE0Ryw0QkFBNEIsa0JBQWtCLDZCQUE2QixNQUFNLDhCQUE4Qix1REFBdUQsK0NBQStDLGdDQUFnQyxjQUFjLDZCQUE2QixNQUFNLE1BQU0sZ0NBQWdDLFVBQVUsNEJBQTRCLHNEQUFzRCxLQUFLLGVBQWUseURBQXlELHdFQUF3RSxtQ0FBbUMsY0FBYyw2QkFBNkIsTUFBTSxNQUFNLGdDQUFnQyxVQUFVLDRCQUE0Qix1RkFBdUYsS0FBSyxlQUFlO0FBQzE1Qyw0REFBNEQsMkRBQTJELG9GQUFvRixPQUFPLG1DQUFtQywyQkFBMkIscURBQXFELG9DQUFvQyxpSEFBaUgsWUFBWSxzQ0FBc0MseURBQXlELGlHQUFpRyx1QkFBdUIsb0lBQW9JLEdBQUcsV0FBVyxHQUFHLHNCQUFzQjs7QUFFeDJCO0FBQ0E7O0FBRUEsZ0NBQWdDLG1DQUFtQyxvQkFBb0IscURBQXFELGNBQWM7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUyxrSUFBa0k7QUFDN0s7QUFDQTtBQUNBLHNEQUFzRCxvQkFBb0IsV0FBVyw2Q0FBNkMsdUVBQXVFLFFBQVEsK0NBQStDLFVBQVUsRUFBRSwyQkFBMkIsZ0VBQWdFLGdDQUFnQztBQUN2WSxJQUFJLDBCQUEwQixlQUFlLHdCQUF3QixNQUFNLGVBQWUsT0FBTywyQ0FBMkMsVUFBVSxtRUFBbUUsa0JBQWtCLE1BQU0sbUZBQW1GLGlCQUFpQixlQUFlLGlEQUFpRCxJQUFJLCtDQUErQyx1RUFBdUUsTUFBTTs7QUFFcmhCO0FBQ0E7QUFDQSxxREFBcUQsSUFBSSxxQ0FBcUMsV0FBVyxpRUFBaUUsZ0JBQWdCOztBQUUxTCx5REFBeUQsd0ZBQXdGLHVLQUF1SyxtREFBbUQsOEJBQThCLG9EQUFvRDs7QUFFN2IsbUNBQW1DLFNBQVMsMkRBQTJELGVBQWUsZUFBZTtBQUNySTtBQUNBLGlFQUFpRSwyRUFBMkUsRUFBRSxvQkFBb0IsOERBQThELDhCQUE4QixHQUFHLHVCQUF1Qix3QkFBd0I7QUFDaFQ7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLFlBQVksK0JBQStCLHNCQUFzQixNQUFNLCtEQUErRCxvQkFBb0IsUUFBUSwwREFBMEQsRUFBRTtBQUNsVSxTQUFTLCtCQUErQjtBQUN4QyxvQkFBb0IsUUFBUSxzSUFBc0ksSUFBSSxtQkFBbUIsUUFBUSxxSEFBcUgsY0FBYyxHQUFHLEVBQUUsSUFBSSx1QkFBdUIscUJBQXFCLGdCQUFnQixvQ0FBb0MsU0FBUyxzQ0FBc0MsR0FBRyxNQUFNLGVBQWUsMENBQTBDLG1DQUFtQywwQkFBMEI7QUFDM2xCO0FBQ0Esb0JBQW9CLGtEQUFrRCxnQ0FBZ0MsK0RBQStELEVBQUUsSUFBSSxtQkFBbUIsV0FBVyxRQUFRLGlHQUFpRyxJQUFJOztBQUV0VDtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQixtQkFBbUIsc0NBQXNDLG1CQUFtQixnQ0FBZ0M7QUFDcEo7QUFDQSwyQkFBMkIsTUFBTSxrQ0FBa0MsUUFBUSxJQUFJLDJHQUEyRyxRQUFRLCtGQUErRixjQUFjLFFBQVEsaUNBQWlDO0FBQ3hWO0FBQ0EsMEJBQTBCLE1BQU0sMkNBQTJDLFFBQVEsNENBQTRDLHNHQUFzRyxxQkFBcUIsNEZBQTRGLGVBQWUscUJBQXFCLDJCQUEyQixHQUFHO0FBQ3haO0FBQ0EsaUNBQWlDLDRCQUE0Qix1Q0FBdUMsR0FBRztBQUN2RztBQUNBLHVDQUF1Qyx1Q0FBdUMsTUFBTSxJQUFJLDhCQUE4QixRQUFRLEdBQUc7QUFDakk7QUFDQSx1QkFBdUIsaUNBQWlDOztBQUV4RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxzRUFBc0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlEQUFpRCwyRUFBMkUsdUJBQXVCOztBQUV6SyxvQ0FBb0MsNkRBQTZELElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsYUFBYSxlQUFlLEVBQUUsaUJBQWlCLFVBQVUseUJBQXlCLGFBQWE7QUFDNUosdUJBQXVCLDBCQUEwQixnREFBZ0QsOERBQThEO0FBQy9KO0FBQ0EsbUdBQW1HLEdBQUcsV0FBVztBQUNqSCw4REFBOEQ7QUFDOUQ7O0FBRUEsdUNBQXVDLGtCQUFrQixtQ0FBbUMsTUFBTSxNQUFNLEtBQUssbUJBQW1CLG1DQUFtQyxtQkFBbUIsc0RBQXNELHFDQUFxQyw0REFBNEQsRUFBRTtBQUMvVTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UseUJBQXlCLDBFQUEwRSxxQ0FBcUMsNEVBQTRFLGlEQUFpRCxvQ0FBb0MsOENBQThDLGdCQUFnQiw2REFBNkQsTUFBTSwyQ0FBMkMsSUFBSSxtQ0FBbUMsSUFBSSwrQ0FBK0MsZ0NBQWdDLEVBQUUsNkNBQTZDLDBFQUEwRSxFQUFFLHVFQUF1RSxNQUFNLHFEQUFxRCxPQUFPLE1BQU0sNkNBQTZDLFNBQVMsUUFBUSw2QkFBNkIsZ0VBQWdFLFVBQVUsd0lBQXdJLG9GQUFvRixvREFBb0QsMERBQTBELGlHQUFpRyxLQUFLLDRDQUE0QyxTQUFTLHdDQUF3QztBQUNqbEQ7QUFDQSxpQ0FBaUMseURBQXlELEtBQUs7QUFDL0Y7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsYUFBYTtBQUN4QixXQUFXLFVBQVU7QUFDckIsaUVBQWlFO0FBQ2pFLHNEQUFzRCxvRUFBb0UsOEJBQThCO0FBQ3hKLCtCQUErQixvREFBb0Q7QUFDbkYsc0RBQXNEO0FBQ3RELHNCQUFzQixHQUFHLE1BQU07QUFDL0IseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsYUFBYTtBQUN4QjtBQUNBLG1FQUFtRSwrQkFBK0IsNkJBQTZCO0FBQy9ILGlFQUFpRSx5Q0FBeUMsT0FBTyxzQkFBc0IsMkJBQTJCLDhDQUE4QztBQUNoTixtRUFBbUUsZ0JBQWdCLE1BQU07QUFDekYsdURBQXVELE1BQU07QUFDN0QsaUJBQWlCLE1BQU07QUFDdkIsZ0JBQWdCLE1BQU0sa0VBQWtFLElBQUk7QUFDNUY7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxnQ0FBZ0MsZ0RBQWdELGdEQUFnRCxjQUFjLHdFQUF3RSxtQ0FBbUM7QUFDelA7QUFDQSw2Q0FBNkMsNElBQTRJLHlEQUF5RCxZQUFZLGtFQUFrRSxpTUFBaU0saUJBQWlCLHdDQUF3QztBQUMxakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiwyQkFBMkIsbUNBQW1DLDRDQUE0QyxzQ0FBc0MsMkNBQTJDLE1BQU0sd0VBQXdFLHVDQUF1Qyx3REFBd0QsTUFBTSw2Q0FBNkM7O0FBRTNlO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDLCtCQUErQiwyQkFBMkIsb0JBQW9CO0FBQzlFO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQixRQUFRLDRCQUE0Qix1QkFBdUI7QUFDNUY7QUFDQSw0QkFBNEIsNENBQTRDLGNBQWMseUVBQXlFLEdBQUcsRUFBRSx5REFBeUQsY0FBYyx5RUFBeUUsR0FBRyxFQUFFO0FBQ3pUO0FBQ0EsNERBQTRELGdFQUFnRSwwSUFBMEksa0dBQWtHLEdBQUc7QUFDM1c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJLE1BQU0sa0RBQWtELFdBQVcsZ0VBQWdFLGtEQUFrRCw4REFBOEQsaUNBQWlDLFFBQVEsb0NBQW9DLGVBQWUsT0FBTyx3QkFBd0IsUUFBUSxFQUFFLHNCQUFzQixFQUFFLGFBQWEsRUFBRSx5RUFBeUUsZ0RBQWdELG1FQUFtRTtBQUM3bkI7QUFDQTtBQUNBLHVGQUF1RixRQUFRLGtEQUFrRCxvRkFBb0YsY0FBYyxrQkFBa0Isa0ZBQWtGLGlCQUFpQjtBQUN4VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHLCtGQUErRjtBQUMvRiw4QkFBOEIsbURBQW1ELDJGQUEyRixvQkFBb0IsSUFBSTtBQUNwTSw0REFBNEQseUNBQXlDLFdBQVc7QUFDaEgsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixpQ0FBaUMsSUFBSSwwR0FBMEcsV0FBVyxjQUFjLDZGQUE2RixLQUFLO0FBQzFROztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXLFVBQVUsU0FBUyxRQUFRLGFBQWEsNkJBQTZCLEVBQUUsYUFBYSx3QkFBd0Isb0JBQW9CLHVCQUF1QixpQkFBaUIsNERBQTRELHVCQUF1QiwrQkFBK0IsTUFBTSx1Q0FBdUMsU0FBUyw2QkFBNkIsMEVBQTBFLHVCQUF1QiwrQkFBK0IsTUFBTSxnQ0FBZ0MsU0FBUyxjQUFjLGtDQUFrQyw0QkFBNEIsMENBQTBDLDJDQUEyQywwQkFBMEIsRUFBRSxrQ0FBa0MsZ0NBQWdDLGtDQUFrQywyQkFBMkIsaUJBQWlCLCtCQUErQixZQUFZLDhEQUE4RCx1QkFBdUIsK0JBQStCLE1BQU0sZ0NBQWdDLFNBQVMseUNBQXlDLGVBQWUsK0RBQStELHVCQUF1QiwrQkFBK0IsTUFBTSxnQ0FBZ0MsU0FBUyxjQUFjLHlCQUF5QixrQ0FBa0MsOEJBQThCLGdCQUFnQiwwQkFBMEIscUJBQXFCLGtDQUFrQywrQkFBK0IsdURBQXVELDREQUE0RDtBQUMzb0QsNEVBQTRFLDZFQUE2RSxjQUFjLHNFQUFzRSxHQUFHLGtDQUFrQztBQUNsUjtBQUNBLDRCQUE0Qix1QkFBdUIsZUFBZSw0Q0FBNEMsZ0NBQWdDLHdCQUF3QixpREFBaUQsZ0RBQWdELGtFQUFrRTtBQUN6VSw2REFBNkQsd0JBQXdCLGlEQUFpRCw0REFBNEQsOEJBQThCLHlEQUF5RCxpSEFBaUgsb0NBQW9DLHVEQUF1RCxnQ0FBZ0MsZUFBZSxJQUFJLG1FQUFtRSxXQUFXO0FBQ3RtQixXQUFXLFdBQVcsTUFBTSwrRkFBK0YsYUFBYSxHQUFHLCtCQUErQiwrQ0FBK0MsaUNBQWlDLDRDQUE0QywwREFBMEQsWUFBWTs7QUFFNVc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0lBQStJO0FBQ3ZMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQ0FBZ0MsS0FBSyxHQUFHOztBQUVuRztBQUNBO0FBQ0Esb1VBQW9VOztBQUVwVTtBQUNBLGdDQUFnQyx3SUFBd0ksNkNBQTZDO0FBQ3JOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlDQUF5QyxrQkFBa0I7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsbUJBQW1CLDBLQUEwSyw0TEFBNEwsZ01BQWdNLG9NQUFvTSwwTEFBMEwsNEtBQTRLLDBMQUEwTCw4TEFBOEwsZ01BQWdNLGdNQUFnTSxzTEFBc0wsa01BQWtNLGtMQUFrTCxvS0FBb0ssNEJBQTRCO0FBQ3BuRjtBQUNBLGdFQUFnRSx1QkFBdUIsdUNBQXVDLHlDQUF5QywwREFBMEQsbUJBQW1CLDRDQUE0QyxFQUFFOztBQUVsUztBQUNBO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBLGlEQUFpRCxxRUFBcUUsd0JBQXdCLHdEQUF3RCxrREFBa0QsMENBQTBDOztBQUVsUztBQUNBO0FBQ0EscUJBQXFCLHdDQUF3QyxtQkFBbUIsK0JBQStCLG1CQUFtQixzQ0FBc0M7QUFDeEs7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBLENBQUMseUVBQXlFLHdCQUF3Qiw0QkFBNEIsNkJBQTZCLHNCQUFzQjtBQUNqTDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8saU1BQWlNLHNCQUFzQixPQUFPLCtCQUErQjtBQUNwUjtBQUNBLDZDQUE2QyxJQUFJLEdBQUc7QUFDcEQ7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx3RUFBd0UsNkJBQTZCLFdBQVc7QUFDaEgsb0VBQW9FLCtDQUErQyx3RUFBd0UsY0FBYyxhQUFhLEVBQUUsOEJBQThCLDRUQUE0VCxFQUFFLG1RQUFtUSxFQUFFLHNUQUFzVCxFQUFFLGtSQUFrUixFQUFFLHNRQUFzUSxFQUFFLCtJQUErSSxFQUFFLDhCQUE4QixzQ0FBc0MsZ0NBQWdDO0FBQ2w0RCxFQUFFLHlFQUF5RSxNQUFNLG9QQUFvUCxFQUFFLDhFQUE4RSxtRUFBbUUsK0VBQStFLHVCQUF1QiwyQkFBMkIsd0VBQXdFLE1BQU0sZ0RBQWdELDBHQUEwRyw0QkFBNEIsNEJBQTRCLGlEQUFpRCw2SUFBNkk7QUFDdmpDO0FBQ0Esd0JBQXdCLHlEQUF5RDtBQUNqRiw2RUFBNkUsdUJBQXVCLHVCQUF1QixtQ0FBbUMsMENBQTBDLGdDQUFnQyxNQUFNLGlDQUFpQyxFQUFFLDJCQUEyQiwwRUFBMEUsT0FBTyw0REFBNEQsZ0RBQWdELGlEQUFpRCxHQUFHO0FBQzdoQjtBQUNBLDRCQUE0QixzREFBc0QsNEZBQTRGLGlDQUFpQyxHQUFHO0FBQ2xOO0FBQ0EsNkJBQTZCLGtGQUFrRix1RUFBdUUsK0hBQStIO0FBQ3JULHlGQUF5RiwyQ0FBMkMsZ0JBQWdCLFNBQVMsR0FBRyxlQUFlLG1CQUFtQixHQUFHO0FBQ3JNO0FBQ0Esc0NBQXNDLElBQUkscURBQXFELFNBQVMseUJBQXlCLFlBQVk7QUFDN0k7QUFDQSxvQ0FBb0MsSUFBSSxtREFBbUQsU0FBUyx5QkFBeUIsY0FBYztBQUMzSTtBQUNBLHVCQUF1Qix5QkFBeUIsSUFBSSxvQ0FBb0MsU0FBUyxxRkFBcUYsNkNBQTZDLFlBQVksTUFBTSxHQUFHO0FBQ3hQLHlCQUF5QixzREFBc0QsSUFBSSw0Q0FBNEMsU0FBUywrQ0FBK0MsbUJBQW1CLE1BQU0sR0FBRztBQUNuTjtBQUNBLCtDQUErQywyQkFBMkIseURBQXlEOztBQUVuSSxxQ0FBcUMsbUNBQW1DLHVDQUF1QyxxQ0FBcUMsd0JBQXdCLCtDQUErQyxrREFBa0Q7O0FBRTdRLDZCQUE2QiwrQkFBK0IsMkNBQTJDLCtCQUErQixzQ0FBc0MscURBQXFELG9FQUFvRSxrQ0FBa0MsbUNBQW1DLG1CQUFtQjs7QUFFN1gsOENBQThDLG9EQUFvRCxzREFBc0Qsb0RBQW9ELDZEQUE2RDs7QUFFelEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0EsaUNBQWlDLElBQUksa0NBQWtDLFdBQVcsOENBQThDLG9CQUFvQjtBQUNwSjtBQUNBLHdCQUF3QixJQUFJLGtDQUFrQyxXQUFXO0FBQ3pFLG9CQUFvQjtBQUNwQjtBQUNBLHFCQUFxQixhQUFhLDJCQUEyQixNQUFNLFNBQVMsY0FBYyxZQUFZO0FBQ3RHLHlCQUF5Qix5QkFBeUIsZ0RBQWdELFlBQVksaURBQWlELEVBQUUsYUFBYTtBQUM5SztBQUNBLGlEQUFpRCxlQUFlLHFCQUFxQixHQUFHLG9CQUFvQixvQkFBb0IsR0FBRyxxQkFBcUIsRUFBRSxrQkFBa0IsbUJBQW1CLG1CQUFtQixzREFBc0QsaUJBQWlCLGlCQUFpQixPQUFPLGFBQWEsR0FBRyxtQkFBbUIsaUJBQWlCLFNBQVMsZUFBZSxHQUFHLG9CQUFvQixpQkFBaUIsVUFBVSw4QkFBOEIsR0FBRyxxQkFBcUIsaUJBQWlCLFdBQVcsaUJBQWlCLEdBQUcsbUJBQW1CLGlCQUFpQixTQUFTLDBDQUEwQztBQUM1bUI7QUFDQSxrQkFBa0IsbURBQW1ELGtDQUFrQztBQUN2RztBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsaURBQWlELHlCQUF5QiwyREFBMkQsZ0JBQWdCLGtCQUFrQixhQUFhOztBQUVwTCwrQkFBK0Isb0NBQW9DLFlBQVksb0JBQW9CO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwyRkFBMkYsaUNBQWlDLGlDQUFpQyxnQkFBZ0I7QUFDN0ssZ0VBQWdFLGVBQWU7QUFDL0Usb0JBQW9CO0FBQ3BCLGlEQUFpRCxzQkFBc0IsZUFBZTtBQUN0Rix5QkFBeUIsS0FBSyxNQUFNLHVDQUF1QyxnQkFBZ0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBLFlBQVksZ0JBQWdCLE1BQU0sdUJBQXVCLDBDQUEwQyxZQUFZLFVBQVUsd0NBQXdDLEVBQUUsT0FBTyxHQUFHLElBQUk7QUFDakwscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQix3QkFBd0IsZ0JBQWdCLE1BQU07QUFDOUM7QUFDQSxJQUFJLHlCQUF5QixNQUFNO0FBQ25DLEdBQUc7O0FBRUgsbUNBQW1DLG9CQUFvQixpQ0FBaUMsRUFBRSxRQUFRLGdJQUFnSSwwQ0FBMEMsYUFBYSxFQUFFLDRDQUE0QyxhQUFhLEVBQUUsNkNBQTZDLGFBQWE7O0FBRWhaO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZSxTQUFTLFFBQVEsb0JBQW9CLGdEQUFnRCxvQkFBb0IsbUJBQW1CLG9EQUFvRCxFQUFFLDZDQUE2QyxxQkFBcUIsbUJBQW1CLHFCQUFxQiwwQ0FBMEMsY0FBYyxhQUFhLHFCQUFxQix1QkFBdUIsYUFBYSxnQkFBZ0IscUJBQXFCLHVCQUF1QiwwQ0FBMEMsYUFBYSxRQUFRLGFBQWEsZUFBZSxXQUFXLDBCQUEwQiw2QkFBNkIsT0FBTyxnQ0FBZ0M7O0FBRWxzQixlQUFlOztBQUVmLDRCQUE0QixxQkFBcUIsd0JBQXdCLDJDQUEyQyxtQkFBbUIsNEJBQTRCLDBCQUEwQiwwQkFBMEIscUJBQXFCLHFCQUFxQix3QkFBd0IsUUFBUSxTQUFTLGNBQWMsY0FBYyxhQUFhLHdCQUF3Qiw0RUFBNEUsNEJBQTRCLDRCQUE0QixrQkFBa0IsSUFBSSwwQkFBMEIsU0FBUyxlQUFlLDJCQUEyQixTQUFTLDZDQUE2Qyx3QkFBd0IsaUVBQWlFO0FBQ2p1QjtBQUNBLGdDQUFnQyxxQ0FBcUMsSUFBSTtBQUN6RSxhQUFhLDZCQUE2Qiw2QkFBNkIsMEJBQTBCLFNBQVMsdUJBQXVCLHlCQUF5Qix5Q0FBeUMsK0NBQStDLHFDQUFxQyxzRkFBc0Ysd0NBQXdDLDBDQUEwQyxpQ0FBaUMsa0NBQWtDLHlCQUF5QixRQUFRLDREQUE0RCxnQkFBZ0I7QUFDL21CLDRCQUE0QixpQkFBaUIsNkJBQTZCLHFCQUFxQixpQkFBaUIsMEJBQTBCLHNCQUFzQixxQ0FBcUMscUJBQXFCLHFDQUFxQyxhQUFhLHVCQUF1QjtBQUNuUyxvQkFBb0IsV0FBVywrQkFBK0IscUJBQXFCLEVBQUUsWUFBWSx3QkFBd0IsZ0NBQWdDLG1CQUFtQixrQkFBa0IsVUFBVSw0QkFBNEIsTUFBTSxLQUFLLGdEQUFnRCxzQkFBc0Isb0JBQW9CLFdBQVcsMENBQTBDLHdCQUF3QixnQkFBZ0IsYUFBYSw2QkFBNkIsc0JBQXNCLHdCQUF3QixZQUFZLHVCQUF1QixTQUFTLHNDQUFzQyxzQkFBc0IsU0FBUyx5QkFBeUIsV0FBVyxFQUFFLFVBQVUsb0NBQW9DLCtCQUErQixNQUFNLEtBQUssdUJBQXVCLDZCQUE2QixhQUFhLDZCQUE2QiwwQkFBMEIsMkJBQTJCLE1BQU0sS0FBSyx1REFBdUQsV0FBVyxvQkFBb0IseUJBQXlCLGdCQUFnQix5QkFBeUIsbUJBQW1CLFlBQVksMEJBQTBCLHVDQUF1QyxvQkFBb0IsZ0RBQWdELHVDQUF1QywyQ0FBMkMsbUNBQW1DLDREQUE0RCwyQkFBMkIsUUFBUSw2QkFBNkIsb0JBQW9CLG9EQUFvRCwyQkFBMkIsTUFBTSxLQUFLLG1DQUFtQyx1QkFBdUIsY0FBYyx5REFBeUQsY0FBYyxHQUFHLFdBQVc7O0FBRW5zRDtBQUNBOztBQUVBLGlDQUFpQyx3RUFBd0U7QUFDekcsOEJBQThCLDhCQUE4Qix1RUFBdUUsZUFBZTtBQUNsSjtBQUNBLHVFQUF1RSxZQUFZLGFBQWEsK0VBQStFLHlCQUF5QixzQkFBc0IsV0FBVyxJQUFJLGFBQWEsZ0NBQWdDLDRDQUE0Qyw2QkFBNkIsTUFBTSxvRUFBb0Usb0NBQW9DO0FBQ2pkLE1BQU0sd0VBQXdFLHNDQUFzQyxNQUFNLHNCQUFzQixZQUFZLGlDQUFpQyw4QkFBOEIsNkJBQTZCLGNBQWMsb0JBQW9CLFdBQVcsbUJBQW1CLFdBQVcsZ0NBQWdDLGdCQUFnQixrQkFBa0IsZ0JBQWdCLFVBQVUsRUFBRSxPQUFPLFlBQVk7QUFDcGI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0IsZUFBZSxTQUFTLG9CQUFvQiw2Q0FBNkMsb0JBQW9CLG1CQUFtQixvREFBb0QsRUFBRSwwREFBMEQsc0VBQXNFLHFCQUFxQixtQkFBbUIscUJBQXFCLHlCQUF5QjtBQUMxYixhQUFhLDJCQUEyQixzQ0FBc0MsZ0JBQWdCLGtCQUFrQix5QkFBeUIsUUFBUSxjQUFjLGVBQWUsV0FBVywwQkFBMEIsNkJBQTZCO0FBQ2hQLE9BQU8sc0JBQXNCOztBQUU3QjtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QixlQUFlLFNBQVMsb0JBQW9CLCtDQUErQyxvQkFBb0IsbUJBQW1CLG9EQUFvRCxFQUFFLDREQUE0RDtBQUNwUyw0QkFBNEIsc0NBQXNDLHNFQUFzRSxxQkFBcUIsbUJBQW1CLGdCQUFnQixRQUFRLDhCQUE4QiwrQkFBK0IsYUFBYSxnQkFBZ0IsYUFBYSxvQ0FBb0Msc0NBQXNDLGdCQUFnQixnQkFBZ0IsUUFBUSwyQkFBMkIsK0JBQStCLFFBQVEsb0JBQW9CLGVBQWUsV0FBVyxxQ0FBcUMsT0FBTyxjQUFjLGdCQUFnQixhQUFhLFlBQVksb0JBQW9CLE1BQU0sNEJBQTRCLGVBQWUsaUJBQWlCLGNBQWM7O0FBRXh0QjtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QixlQUFlLFNBQVMsb0JBQW9CLG9CQUFvQixtQkFBbUIsa0JBQWtCLHdDQUF3QyxvREFBb0QsRUFBRSx1Q0FBdUMsNEJBQTRCLGdFQUFnRSxzRUFBc0UscUJBQXFCLG1CQUFtQiwyQ0FBMkMseUNBQXlDLGFBQWE7QUFDcGtCLGFBQWEsd0JBQXdCLHNDQUFzQyxnQkFBZ0Isb0NBQW9DLHlDQUF5QyxlQUFlO0FBQ3ZMLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxDQUFDLFdBQVcsMEJBQTBCLDZCQUE2QjtBQUNuRSxPQUFPLCtCQUErQjs7QUFFdEM7QUFDQTtBQUNBLGlDQUFpQyxhQUFhLDhDQUE4QyxrREFBa0Qsa0RBQWtELGdEQUFnRCx5Q0FBeUM7QUFDelI7QUFDQSxnREFBZ0QsbUVBQW1FO0FBQ25ILDRCQUE0Qix1TkFBdU47QUFDblA7QUFDQSwrQ0FBK0MseUNBQXlDO0FBQ3hGO0FBQ0Esa0RBQWtELDRDQUE0QztBQUM5RjtBQUNBLGlEQUFpRCwyQ0FBMkM7QUFDNUY7QUFDQSx5REFBeUQsdUJBQXVCLDBCQUEwQix5QkFBeUIsSUFBSSxtREFBbUQsaURBQWlELHVEQUF1RDs7QUFFbFM7QUFDQTtBQUNBLGVBQWUsMENBQTBDLGtCQUFrQixzQkFBc0IsMkNBQTJDLG9DQUFvQyxtQkFBbUIsNERBQTRELHdDQUF3QyxnQ0FBZ0Msc0NBQXNDLDBCQUEwQixvQ0FBb0M7QUFDM2E7QUFDQSx5QkFBeUIsTUFBTSxnREFBZ0QsTUFBTSxvQkFBb0Isa0RBQWtEO0FBQzNKLGdCQUFnQixnREFBZ0QsdUJBQXVCLHdEQUF3RCxFQUFFLG9CQUFvQjtBQUNySztBQUNBLHNDQUFzQyxNQUFNLGdDQUFnQyxNQUFNLHVEQUF1RDtBQUN6STtBQUNBO0FBQ0EscUNBQXFDLHFDQUFxQyx5REFBeUQsd0NBQXdDO0FBQzNLO0FBQ0Esa0JBQWtCLEVBQUUsNkJBQTZCO0FBQ2pEO0FBQ0Esb0JBQW9CLHdDQUF3QyxjQUFjLFFBQVEsSUFBSTtBQUN0RixrR0FBa0csV0FBVyxnQ0FBZ0MseURBQXlELFFBQVEsSUFBSTtBQUNsTixzQ0FBc0M7QUFDdEMscUJBQXFCLE1BQU0sK0NBQStDLGlEQUFpRDtBQUMzSDtBQUNBLGNBQWMsd0NBQXdDLG1CQUFtQixJQUFJLGNBQWMsYUFBYSwyREFBMkQsMkRBQTJELGFBQWE7QUFDM08sbUNBQW1DLFdBQVcsZ0RBQWdELDhDQUE4QyxjQUFjO0FBQzFKO0FBQ0EsaUJBQWlCLHdDQUF3QyxhQUFhLG1DQUFtQztBQUN6RztBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQSxvQkFBb0IsNkJBQTZCLGFBQWEscUNBQXFDO0FBQ25HO0FBQ0Esb0JBQW9CLHFDQUFxQztBQUN6RDtBQUNBLHdCQUF3Qix3RkFBd0YsaUJBQWlCLGNBQWMsb0NBQW9DLEtBQUssRUFBRSwwR0FBMEcscUVBQXFFO0FBQ3pXO0FBQ0EsK0NBQStDLDJCQUEyQix1QkFBdUIsUUFBUSw2QkFBNkI7O0FBRXRJLG9FQUFvRSwwQkFBMEIsNENBQTRDLDBEQUEwRCw2Q0FBNkMsTUFBTSw4Q0FBOEMsa0NBQWtDLE1BQU0sa0RBQWtELGtDQUFrQyxRQUFROztBQUV6YTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsb0JBQW9CLGdEQUFnRCwrQkFBK0IsbUJBQW1CLG9DQUFvQztBQUMxTDtBQUNBLFlBQVksdUJBQXVCLFFBQVEsMENBQTBDLGNBQWMsc0JBQXNCLCtKQUErSix1QkFBdUIsMEJBQTBCLDJCQUEyQiw0RkFBNEYsZ0NBQWdDLCtKQUErSiw0QkFBNEIseUJBQXlCO0FBQ3ByQjtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLG1DQUFtQyw2Q0FBNkMsZUFBZSxxTUFBcU0sSUFBSSxHQUFHLHlCQUF5QiwrQ0FBK0MsNERBQTREO0FBQ2hnQixzRUFBc0Usd0ZBQXdGLCtDQUErQyxnREFBZ0QsZ0NBQWdDLHNCQUFzQix1Q0FBdUMscUJBQXFCLDRCQUE0Qix3REFBd0QsdUZBQXVGO0FBQzFoQix3R0FBd0csbUZBQW1GLGtDQUFrQyw4QkFBOEIsZ0JBQWdCLGdDQUFnQyxxREFBcUQsRUFBRSxPQUFPLDJDQUEyQywyQ0FBMkMsbUVBQW1FLEdBQUcsdURBQXVELGlDQUFpQyxvQkFBb0IsbUVBQW1FLGlDQUFpQyxNQUFNLHVFQUF1RSxpQ0FBaUMsTUFBTSwwQ0FBMEM7QUFDbjNCLGdEQUFnRCxpQ0FBaUMsb0RBQW9ELGdDQUFnQyxzREFBc0Qsa0NBQWtDLE1BQU0saUNBQWlDLE9BQU8sbUNBQW1DLHNHQUFzRyx5QkFBeUI7QUFDN2M7QUFDQSwyQkFBMkIsdURBQXVELHFGQUFxRixvQ0FBb0M7QUFDM007QUFDQSxrQkFBa0I7O0FBRWxCLDhOQUE4TixtSEFBbUgseUJBQXlCO0FBQzFXLDBCQUEwQjtBQUMxQixNQUFNLGNBQWMsUUFBUTtBQUM1Qiw0QkFBNEIsY0FBYztBQUMxQyxtQkFBbUI7QUFDbkIsYUFBYSxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRyxNQUFNO0FBQ3JFLGdCQUFnQixRQUFRLHNCQUFzQiw0QkFBNEIsTUFBTSxtQkFBbUIsbUJBQW1CLFVBQVUsU0FBUyxJQUFJLFVBQVUsSUFBSSxvREFBb0Qsc0ZBQXNGLGdGQUFnRixVQUFVLElBQUksR0FBRyxrQkFBa0IsSUFBSSwrQ0FBK0MsTUFBTSxVQUFVLG9DQUFvQzs7QUFFL2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsc0JBQXNCLElBQUksMEJBQTBCLG9CQUFvQixhQUFhLGVBQWU7QUFDcE47QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0IsSUFBSSwwQkFBMEIsd0JBQXdCLDZDQUE2QyxrQ0FBa0MsaURBQWlEO0FBQzFPLDBCQUEwQixpQkFBaUIseUJBQXlCLEdBQUcsYUFBYTtBQUNwRixDQUFDLGdCQUFnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCLElBQUksMEJBQTBCLDREQUE0RCxhQUFhO0FBQy9KLENBQUM7O0FBRUQsa0RBQWtELEdBQUcsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CLGNBQWMsSUFBSTtBQUMvRDtBQUNBLCtCQUErQjtBQUMvQixjQUFjLDhCQUE4QixTQUFTOztBQUVyRCxrREFBa0Q7O0FBRWxELGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0JBQW9CLHNFQUFzRSx1Q0FBdUMsbUNBQW1DLDJDQUEyQyxpREFBaUQsc0RBQXNELGtGQUFrRiw4REFBOEQsNERBQTRELHNEQUFzRDtBQUN0bUIsK0VBQStFLHFDQUFxQyxJQUFJLHNCQUFzQjtBQUM5STtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsSUFBSSxTQUFTLHVCQUF1QiwyRkFBMkYsd0NBQXdDLHdHQUF3RztBQUMvVSxvQkFBb0IsUUFBUSxxQ0FBcUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsNkJBQTZCLHlCQUF5Qix3QkFBd0Isc0JBQXNCLGFBQWEsa0RBQWtELHFEQUFxRDtBQUMzUixFQUFFLGtDQUFrQyxzREFBc0QsaUVBQWlFLDBEQUEwRCxrQkFBa0IsZ0VBQWdFLHdEQUF3RCxtQkFBbUIsb0JBQW9CLG9DQUFvQztBQUMxYSxtREFBbUQsUUFBUTs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EscUVBQXFFLDhFQUE4RSxzQkFBc0I7QUFDeks7QUFDQTtBQUNBLHNEQUFzRCxrREFBa0Q7QUFDeEcsNkJBQTZCLHFDQUFxQyxvQ0FBb0MsYUFBYSxtQkFBbUI7QUFDdEk7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJIQUEySCwrRkFBK0YsNkNBQTZDLE1BQU0sMkdBQTJHLHlCQUF5Qiw4Q0FBOEMscUJBQXFCLHdCQUF3Qix5QkFBeUIsZ0NBQWdDLGlFQUFpRTtBQUMxb0I7QUFDQTtBQUNBO0FBQ0Esd0pBQXdKLDBHQUEwRywrQkFBK0IsMERBQTBELDhDQUE4QyxnREFBZ0Q7QUFDemI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZSwrQ0FBK0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsaUhBQWlILGlCQUFpQixnSEFBZ0gsTUFBTSxtQkFBbUIsUUFBUSxnREFBZ0QsaURBQWlELE1BQU0sNEJBQTRCLHlCQUF5QiwwQ0FBMEMsNkRBQTZELDhGQUE4RixrQ0FBa0Msc0VBQXNFLHdIQUF3SCw4RUFBOEU7QUFDbDZCLGlMQUFpTCw2REFBNkQsK0NBQStDLDZEQUE2RDtBQUMxViw0REFBNEQsZ0hBQWdILGtGQUFrRixrSUFBa0ksTUFBTSw2Q0FBNkMsdUNBQXVDLE9BQU8scUNBQXFDLHlDQUF5QyxnRUFBZ0UsNkRBQTZELDRHQUE0RywrQ0FBK0MsSUFBSSxrREFBa0QsTUFBTSxtRUFBbUUsNEVBQTRFO0FBQ2xoQyx3REFBd0QsNEZBQTRGLHlEQUF5RCw2RUFBNkUscURBQXFELDhJQUE4SSxrR0FBa0csMkNBQTJDLCtFQUErRSw0REFBNEQscUpBQXFKLE9BQU8sNkVBQTZFLDZDQUE2QyxxQ0FBcUMsdUNBQXVDLHVDQUF1QyxpQ0FBaUM7QUFDL3BDO0FBQ0E7QUFDQSx5R0FBeUcseUJBQXlCLFNBQVMsK0JBQStCLElBQUk7QUFDOUs7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtEQUErRCxnQkFBZ0IsOERBQThELGtDQUFrQyw4S0FBOEssNENBQTRDO0FBQzdhLDZDQUE2Qyw4QkFBOEIsT0FBTyxpREFBaUQsNERBQTRELElBQUkseURBQXlELGdEQUFnRCw4Q0FBOEMsdURBQXVELHNDQUFzQywrQ0FBK0MscUNBQXFDLE1BQU0sbURBQW1ELDhEQUE4RCxPQUFPLHlFQUF5RSxLQUFLLGtHQUFrRywyQ0FBMkMsa0tBQWtLLEVBQUUsaUNBQWlDLGlDQUFpQyw4QkFBOEIsWUFBWSwwQkFBMEIsMkNBQTJDLGlGQUFpRiw4QkFBOEIsa0RBQWtELGlCQUFpQiw4RUFBOEUsc0NBQXNDLG1EQUFtRCxnREFBZ0QsRUFBRSxnQ0FBZ0Msb0NBQW9DLDRDQUE0Qyw2QkFBNkIsTUFBTSxtRUFBbUUsVUFBVSxPQUFPLEVBQUUsU0FBUyxHQUFHLGFBQWEsRUFBRSxLQUFLLElBQUk7QUFDajFEO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixraEJBQWtoQjs7QUFFbm1CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUlBQXlJLHdCQUF3QjtBQUNqSyx1QkFBdUIsb0NBQW9DLHdGQUF3RixhQUFhLCtEQUErRCxNQUFNLHdDQUF3QztBQUM3USxnREFBZ0QseUJBQXlCLFdBQVc7QUFDcEY7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQSxnQkFBZ0IsK0RBQStELHFCQUFxQixHQUFHLFdBQVcsR0FBRyxXQUFXLFFBQVEsa0JBQWtCLEdBQUcsV0FBVyxHQUFHLFdBQVcsSUFBSSw2QkFBNkI7QUFDdk47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbVJBQW1SO0FBQ25SO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw0Q0FBNEMsK0JBQStCLG1CQUFtQiwyQkFBMkIscUNBQXFDLGtEQUFrRCxnQkFBZ0IsT0FBTyw0REFBNEQsR0FBRztBQUMxVDtBQUNBO0FBQ0EsWUFBWSxNQUFNLDRHQUE0Ryx5QkFBeUI7QUFDdkosd0dBQXdHLHVCQUF1QixRQUFRLG9CQUFvQjtBQUMzSixnR0FBZ0csMEJBQTBCLFFBQVEscUJBQXFCLG1HQUFtRywrQ0FBK0MsZ0RBQWdELHVEQUF1RDtBQUNoWixPQUFPLHFEQUFxRCxvREFBb0QsYUFBYSx5Q0FBeUMsMEpBQTBKLHlDQUF5Qyx5Q0FBeUMsR0FBRyx5QkFBeUIsRUFBRTtBQUNoYixrRUFBa0UsRUFBRSxrQkFBa0I7QUFDdEY7QUFDQSwrQ0FBK0MsMkJBQTJCLHdEQUF3RCxHQUFHO0FBQ3JJO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSx5QkFBeUIsdUJBQXVCLHVEQUF1RCxNQUFNLG9EQUFvRCxRQUFRLFFBQVEsSUFBSSx1QkFBdUIsMEJBQTBCLE1BQU0sZUFBZSxXQUFXLGlEQUFpRCxRQUFRLDhCQUE4Qix3REFBd0QsUUFBUTtBQUM3WiwrQkFBK0IseUNBQXlDLFFBQVE7QUFDaEYsMEJBQTBCLGdIQUFnSDtBQUMxSSxPQUFPO0FBQ1Asb0JBQW9CLG1HQUFtRztBQUN2SCx5RUFBeUU7QUFDekUsZ0ZBQWdGLHlCQUF5QjtBQUN6RywyQ0FBMkMsR0FBRztBQUM5QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQStELHFCQUFxQixrQ0FBa0MsOERBQThELFFBQVE7QUFDN00sNkJBQTZCLDJCQUEyQixxREFBcUQsa0NBQWtDLEdBQUcsTUFBTSwwQkFBMEIsTUFBTTtBQUN4TCw4QkFBOEIsbURBQW1ELFNBQVMsMEJBQTBCLDZCQUE2Qjs7QUFFako7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQyxvREFBb0Qsb0JBQW9CLFlBQVksUUFBUSxNQUFNLGtCQUFrQix5REFBeUQsMENBQTBDLFFBQVEsc0JBQXNCLDZEQUE2RCwrQkFBK0IsMkJBQTJCLGFBQWEsSUFBSSxVQUFVLFdBQVcsTUFBTSxNQUFNLFdBQVc7QUFDL2Y7QUFDQSxnREFBZ0Q7QUFDaEQsMkJBQTJCO0FBQzNCLHdEQUF3RCxlQUFlLGFBQWEsV0FBVyxRQUFRLGNBQWMsSUFBSSxtQkFBbUIsNERBQTRELCtCQUErQiwyQkFBMkIsYUFBYSx1REFBdUQ7QUFDdFU7QUFDQTtBQUNBLG1HQUFtRyw2QkFBNkIsZ0RBQWdELDJCQUEyQixNQUFNLFlBQVksVUFBVSxtQkFBbUIsTUFBTSxPQUFPLFVBQVU7QUFDalIsaUJBQWlCLElBQUksbUNBQW1DO0FBQ3hELHVCQUF1Qiw2QkFBNkIsTUFBTSxzQkFBc0Isc0JBQXNCLFdBQVc7QUFDakgsRUFBRSxxQ0FBcUMsTUFBTSxNQUFNLGVBQWUsd0NBQXdDLFFBQVE7O0FBRWxILHVEQUF1RCxtQkFBbUIscUJBQXFCLHNCQUFzQixtQ0FBbUMsbUJBQW1CLHFMQUFxTCxjQUFjLGFBQWEsWUFBWTs7QUFFdlksOEJBQThCLDJEQUEyRCx5Q0FBeUMsZ0VBQWdFLHVDQUF1QztBQUN6TztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCw0QkFBNEIsNEVBQTRFLHdCQUF3Qiw4REFBOEQsa0NBQWtDLEtBQUssdUZBQXVGLDJEQUEyRCxtQkFBbUIsUUFBUTs7QUFFaGhCLHVFQUF1RSxzQkFBc0IsaUJBQWlCLDRCQUE0Qix5REFBeUQsRUFBRSxvQ0FBb0M7QUFDek87O0FBRUEseUdBQXlHO0FBQ3pHLGtGQUFrRjs7QUFFbEYsNEJBQTRCLG1CQUFtQix1REFBdUQsZUFBZSx1S0FBdUs7O0FBRTVSLDBCQUEwQiw0Q0FBNEMsMkJBQTJCLCtCQUErQixtQkFBbUIsMERBQTBELHFDQUFxQyxzQ0FBc0MsT0FBTyxrQ0FBa0MsOEJBQThCO0FBQy9WO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQywwSUFBMEksaUhBQWlILHFIQUFxSDtBQUNoWCx1REFBdUQsNERBQTRELHVEQUF1RCx5Q0FBeUMsOERBQThEO0FBQ2pSLDZDQUE2Qyx5Q0FBeUMsOENBQThDLDJDQUEyQyx1QkFBdUIsOEJBQThCLG1DQUFtQywyQ0FBMkMsRUFBRTtBQUNwVCxPQUFPLHNHQUFzRyxvQ0FBb0MsR0FBRztBQUNwSjtBQUNBLGtDQUFrQyx3REFBd0QsNERBQTRELDZCQUE2QiwyQ0FBMkMsa0NBQWtDLCtCQUErQixNQUFNLHlGQUF5RixtSUFBbUksdUJBQXVCLGlGQUFpRiw2QkFBNkI7QUFDdG9CO0FBQ0Esa0RBQWtELCtCQUErQixFQUFFLDRCQUE0QixlQUFlO0FBQzlILDBDQUEwQyxrREFBa0QsZUFBZSxZQUFZLFlBQVkscUJBQXFCLEdBQUcsbUNBQW1DLG1HQUFtRyxjQUFjLHFGQUFxRixtQ0FBbUMsa0JBQWtCLEdBQUcsTUFBTSxpQkFBaUI7QUFDbmQ7QUFDQSw2QkFBNkIsMkNBQTJDLHlDQUF5QyxFQUFFLDBDQUEwQyx3Q0FBd0MsRUFBRSxtREFBbUQsK0NBQStDLFNBQVM7QUFDbFQ7QUFDQTtBQUNBLFVBQVUsaUNBQWlDLHlEQUF5RDtBQUNwRztBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQixnREFBZ0Q7O0FBRTVHLG9CQUFvQjtBQUNwQiw0RUFBNEU7QUFDNUU7QUFDQSw2RkFBNkY7QUFDN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLHlDQUF5QyxNQUFNLE9BQU8sYUFBYSwyQkFBMkIsZ0ZBQWdGO0FBQzdNO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdHQUFnRyxvRUFBb0U7QUFDN007QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EscURBQXFELDhGQUE4Riw4RkFBOEYsY0FBYyxjQUFjLDRDQUE0QyxxQkFBcUIsa0JBQWtCLHFHQUFxRztBQUNyYztBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTSxlQUFlLGFBQWEsMkJBQTJCLFFBQVE7QUFDeEg7QUFDQSxvQ0FBb0MsT0FBTyxLQUFLO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHlFQUF5RSxRQUFRLHdEQUF3RCxvTEFBb0w7QUFDbFg7QUFDQTtBQUNBLGdEQUFnRCxxQ0FBcUM7QUFDckYsdUJBQXVCLE1BQU0sZ0JBQWdCLHVCQUF1QixRQUFRLGlCQUFpQixrQ0FBa0M7QUFDL0gsbUZBQW1GLHNEQUFzRCxRQUFROztBQUVqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEMsc0JBQXNCLHdDQUF3Qyx1REFBdUQsRUFBRSwrRkFBK0Ysc0hBQXNILHNCQUFzQjtBQUNoWjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQseUNBQXlDLDJCQUEyQjtBQUM3SCw4Q0FBOEMsd0NBQXdDLGdDQUFnQywwREFBMEQsRUFBRSw0Q0FBNEMsbUdBQW1HLG9EQUFvRCwwSEFBMEgsbUJBQW1CO0FBQ2xnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxtQ0FBbUMsb0NBQW9DLDZGQUE2RixnR0FBZ0csS0FBSztBQUNoVjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsTUFBTSwwQkFBMEIsYUFBYSxNQUFNLHdCQUF3QixTQUFTLGlFQUFpRSx5REFBeUQsNkVBQTZFO0FBQzNSO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx1REFBdUQ7QUFDcEgsNkNBQTZDLDJDQUEyQztBQUN4RiwrQ0FBK0MsbUVBQW1FO0FBQ2xILDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwwQkFBMEIsbUNBQW1DLGdGQUFnRixvQkFBb0IsZ0NBQWdDLG1CQUFtQixHQUFHLDZFQUE2RSxxQkFBcUIsc0NBQXNDLDJDQUEyQyxpQ0FBaUMsRUFBRSxnQ0FBZ0MsZUFBZSxHQUFHLE1BQU0sOERBQThELEVBQUUsaUJBQWlCO0FBQ2puQjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsdUNBQXVDLGlEQUFpRDtBQUN4Riw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9CQUFvQixnRUFBZ0U7QUFDN0ksb0hBQW9ILDRCQUE0QixvQ0FBb0MsTUFBTSw2Q0FBNkMsZ0NBQWdDO0FBQ3ZRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSx1QkFBdUIseUJBQXlCO0FBQ25ILG1DQUFtQyxtQkFBbUIsMk9BQTJPO0FBQ2pTLG9DQUFvQyxXQUFXLGtEQUFrRCxNQUFNLDJEQUEyRCxHQUFHLEVBQUUsNkhBQTZILHFGQUFxRjtBQUN6WCxtREFBbUQsTUFBTTtBQUN6RCw2REFBNkQ7QUFDN0QsK0NBQStDLHFEQUFxRCxrQ0FBa0MsMkpBQTJKLCtCQUErQixxREFBcUQsMEVBQTBFLHdEQUF3RCw4SUFBOEksaUVBQWlFO0FBQ3RzQjtBQUNBLHFDQUFxQywyQkFBMkIsMENBQTBDLGdDQUFnQyw4Q0FBOEMsZ0RBQWdEO0FBQ3hPLG9GQUFvRjs7QUFFcEYseUJBQXlCLG9CQUFvQixvQkFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx5QkFBeUIsOENBQThDLGlCQUFpQiw0Q0FBNEMsOERBQThEO0FBQzNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQiwrQkFBK0IsbUVBQW1FO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQixnQ0FBZ0MsU0FBUyxzRUFBc0U7QUFDdEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCLDhCQUE4QiwrRUFBK0U7QUFDeEssOENBQThDLHNCQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQkFBa0IsY0FBYyxZQUFZLDRCQUE0QixXQUFXLDBCQUEwQixtRUFBbUU7QUFDaE87QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsbUJBQW1CLHNHQUFzRyxNQUFNLHlGQUF5RixNQUFNLDZGQUE2RixNQUFNLGlGQUFpRixNQUFNLGdHQUFnRyxPQUFPOztBQUUvaEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLHFDQUFxQywyQ0FBMkMsK0JBQStCLG1CQUFtQix1REFBdUQ7QUFDbFE7QUFDQSxZQUFZLDZCQUE2QixTQUFTLCtCQUErQjtBQUNqRjtBQUNBO0FBQ0EscUJBQXFCLHlDQUF5QyxrREFBa0Q7O0FBRWhILHlCQUF5QjtBQUN6QjtBQUNBLDZFQUE2RSwrQkFBK0IsbUNBQW1DLG1CQUFtQiwrQkFBK0IsMkJBQTJCLHFDQUFxQyxzQ0FBc0MsNENBQTRDO0FBQ25WO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUMsd0JBQXdCLHlCQUF5Qiw4QkFBOEIsc0NBQXNDO0FBQ3JILGlDQUFpQyx5Q0FBeUMsbUNBQW1DLDJDQUEyQyxNQUFNLGlEQUFpRCx5QkFBeUIsd0JBQXdCLHdHQUF3Ryw0RkFBNEYsa0ZBQWtGLHVDQUF1Qyw4QkFBOEIsaUNBQWlDLDJCQUEyQixnQkFBZ0IsNERBQTRELDRFQUE0RSx3RkFBd0Y7QUFDdjRCLGFBQWE7QUFDYjtBQUNBLGdTQUFnUztBQUNoUywyREFBMkQscURBQXFELDhEQUE4RCxvQkFBb0Isc0hBQXNILE1BQU0scURBQXFELDRDQUE0QztBQUMvWiw4Q0FBOEMsaUVBQWlFLHlCQUF5Qix5REFBeUQsdUVBQXVFLDhEQUE4RCxrREFBa0QsaUVBQWlFLE1BQU0sOERBQThELHlDQUF5QyxzRUFBc0UsK0NBQStDLHVGQUF1RixpQ0FBaUMsMENBQTBDLDhFQUE4RSxxQ0FBcUMsZ0JBQWdCLHdDQUF3QywwRkFBMEYsYUFBYSwyQ0FBMkMsZ0ZBQWdGLG9DQUFvQyx3Q0FBd0MsNkNBQTZDLHNDQUFzQyxpQ0FBaUMsSUFBSSxHQUFHLG9DQUFvQyxpQ0FBaUMsUUFBUSwrQkFBK0IsK0JBQStCLHFHQUFxRyx5Q0FBeUMsbURBQW1ELFVBQVUsOEJBQThCLEdBQUcsaURBQWlELG1DQUFtQywyQ0FBMkMsZ0NBQWdDLCtIQUErSDtBQUN0aUU7QUFDQTtBQUNBLG9DQUFvQyxzQ0FBc0MsR0FBRyxHQUFHLG1DQUFtQyxpRUFBaUU7QUFDcEwsZUFBZSxRQUFRLFlBQVksWUFBWSx5RUFBeUUsaURBQWlELHVIQUF1SCxvQ0FBb0MsTUFBTSxrQ0FBa0MsZ0JBQWdCLDZEQUE2RCxpQkFBaUI7QUFDMWM7QUFDQSw4Q0FBOEMsd0dBQXdHLHlDQUF5QyxRQUFRLDJCQUEyQiw4QkFBOEIscURBQXFELG1CQUFtQix3QkFBd0IsMEJBQTBCLCtCQUErQixtQkFBbUIsdUNBQXVDLCtIQUErSDtBQUNsbEIsb0RBQW9ELHVDQUF1QyxpSEFBaUgsc0JBQXNCLFFBQVEsZ0RBQWdEO0FBQzFSO0FBQ0E7QUFDQSwrQ0FBK0MsMkJBQTJCLDhEQUE4RCxHQUFHO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZCQUE2Qiw0QkFBNEIsZ0dBQWdHLHdDQUF3QywwQkFBMEIscUNBQXFDLElBQUksRUFBRSw0QkFBNEI7QUFDalY7QUFDQTtBQUNBO0FBQ0EsMERBQTBELCtCQUErQixzREFBc0QsNkNBQTZDLHVFQUF1RSxTQUFTLDhQQUE4UCw4QkFBOEIsd0NBQXdDLDZCQUE2QixHQUFHO0FBQ2huQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxtREFBbUQsMkNBQTJDLG9DQUFvQyxRQUFRLGtGQUFrRixJQUFJO0FBQ2hPLDhCQUE4QixpQ0FBaUMsNkdBQTZHLEVBQUUsZ0NBQWdDLGlDQUFpQywyREFBMkQsSUFBSSxnQ0FBZ0MsaURBQWlELE9BQU8sMkJBQTJCLElBQUksSUFBSSw4QkFBOEIsaUNBQWlDLDRGQUE0RixFQUFFO0FBQ3RrQiwrRkFBK0YsaUNBQWlDO0FBQ2hJLGdFQUFnRTtBQUNoRSx1QkFBdUIsK0JBQStCLGtEQUFrRCx5REFBeUQsOENBQThDO0FBQy9NLDhIQUE4SDtBQUM5SDtBQUNBO0FBQ0Esd0RBQXdELHdFQUF3RSxPQUFPLDhCQUE4QixHQUFHLE1BQU0sd0VBQXdFLHlCQUF5QixHQUFHLE1BQU0sdUJBQXVCO0FBQy9TLHlCQUF5QixTQUFTLDhHQUE4Ryx1QkFBdUI7QUFDdksseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxvQ0FBb0MsMENBQTBDLDRDQUE0QyxrREFBa0Qsc0ZBQXNGLDBDQUEwQyxrREFBa0Qsd0VBQXdFO0FBQ3RhO0FBQ0EsdUZBQXVGO0FBQ3ZGLHlEQUF5RCxtREFBbUQseUVBQXlFLDBFQUEwRTtBQUMvUCwyQkFBMkIsY0FBYyxrQkFBa0IseUVBQXlFLHVDQUF1QyxZQUFZLHFDQUFxQyxNQUFNLHdDQUF3QyxNQUFNLGdDQUFnQztBQUNoVDtBQUNBLHVCQUF1QjtBQUN2Qix1Q0FBdUMsT0FBTyxxQ0FBcUMsR0FBRyxHQUFHO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpQ0FBaUMsOENBQThDLDRCQUE0Qiw0REFBNEQsNENBQTRDLHdIQUF3SCxzQ0FBc0MsMERBQTBELE1BQU0sMERBQTBELGtEQUFrRDtBQUNubEI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDREQUE0RCw4Q0FBOEMseURBQXlEO0FBQ2hNLDBGQUEwRix3REFBd0QsbUNBQW1DO0FBQ3JMLG1IQUFtSCw4Q0FBOEMsNkVBQTZFLHdDQUF3QywwQkFBMEIsMENBQTBDLDRDQUE0QyxrREFBa0Qsb0ZBQW9GO0FBQzVnQjtBQUNBO0FBQ0Esa0RBQWtELDBDQUEwQyxxQ0FBcUMsYUFBYSx3Q0FBd0MscURBQXFELDZCQUE2Qix5Q0FBeUMsYUFBYTtBQUM5VDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyx3REFBd0Qsd0NBQXdDO0FBQ2hHLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsaUJBQWlCLDJDQUEyQztBQUM1RDtBQUNBO0FBQ0EscUJBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0QztBQUM5RDtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFnRDtBQUN0RTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFvRDtBQUM5RTtBQUNBO0FBQ0EsaUNBQWlDLDJEQUEyRDtBQUM1RjtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFnRDtBQUN0RTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUE4QztBQUNsRTtBQUNBO0FBQ0Esb0JBQW9CLGlGQUFpRixvRkFBb0YsNkJBQTZCLGFBQWE7QUFDbk87QUFDQTtBQUNBLHNCQUFzQiwrRUFBK0UsbURBQW1ELDBCQUEwQiwyQ0FBMkMsNkNBQTZDO0FBQzFRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhLG1DQUFtQyxrQ0FBa0MsYUFBYSxxQ0FBcUM7QUFDN0ssNENBQTRDLG1EQUFtRDtBQUMvRjtBQUNBLHlDQUF5QywwQkFBMEIsNEJBQTRCLE1BQU0scUNBQXFDLDJCQUEyQixjQUFjLG1CQUFtQixvREFBb0QsV0FBVyxvQkFBb0Isa0RBQWtELHNDQUFzQywwREFBMEQscUJBQXFCLHFDQUFxQztBQUNyZTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTSxRQUFRLE9BQU8seUNBQXlDLE9BQU8sdURBQXVELHlCQUF5Qix3Q0FBd0MsUUFBUSxZQUFZLHlDQUF5QyxNQUFNLGtEQUFrRCxNQUFNLGtGQUFrRixRQUFRLEdBQUcsR0FBRztBQUM1YTtBQUNBO0FBQ0EsdUJBQXVCLGlJQUFpSTtBQUN4SjtBQUNBO0FBQ0EsMkJBQTJCLCtQQUErUDtBQUMxUjtBQUNBO0FBQ0EseUJBQXlCLHNJQUFzSTtBQUMvSjtBQUNBO0FBQ0EsNEJBQTRCLG9RQUFvUTtBQUNoUztBQUNBO0FBQ0Esa0NBQWtDLGdLQUFnSztBQUNsTTtBQUNBLGFBQWEsUUFBUTtBQUNyQixnREFBZ0QsbU1BQW1NO0FBQ25QO0FBQ0EsMkNBQTJDLGlDQUFpQyxtQ0FBbUMsMkRBQTJELE1BQU0sMkJBQTJCLGtDQUFrQztBQUM3Tyw4Q0FBOEM7QUFDOUMsMkNBQTJDLDZDQUE2QztBQUN4Riw0QkFBNEIsNEVBQTRFLG1EQUFtRDtBQUMzSixrREFBa0Q7QUFDbEQ7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLCtFQUErRTtBQUM5RjtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0Q7QUFDQSxXQUFXLHlFQUF5RTtBQUNwRjtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFO0FBQ2hFLDRDQUE0QyxrREFBa0QsOENBQThDLG1EQUFtRCxzRUFBc0UsNkNBQTZDLDZIQUE2SCx3SkFBd0osZ0RBQWdELGlFQUFpRSw2Q0FBNkMsMEZBQTBGLCtDQUErQyx1REFBdUQsa01BQWtNLHNMQUFzTCxzSUFBc0kscUpBQXFKLHNEQUFzRCxrREFBa0QsOEdBQThHLHNJQUFzSSxrREFBa0Qsc0NBQXNDLE1BQU0sdUlBQXVJLDhGQUE4RixzR0FBc0cscUZBQXFGLGtIQUFrSCwwRkFBMEYsOEpBQThKLCtJQUErSSwrREFBK0QsMkRBQTJELHNHQUFzRyxzRkFBc0Ysd0hBQXdILDhHQUE4Rzs7QUFFdjZHLCtEQUErRCxvRUFBb0U7O0FBRW5JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5TkFBeU4sd0JBQXdCLGlDQUFpQyxlQUFlLEdBQUcsRUFBRTtBQUN0UztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4QkFBOEI7QUFDckU7QUFDQSwrRUFBK0Usb0dBQW9HLGtGQUFrRixvQkFBb0I7O0FBRXpSLDREQUE0RCx5QkFBeUIsUUFBUSx5QkFBeUIsSUFBSSxtQkFBbUIsYUFBYSxxREFBcUQsTUFBTTs7QUFFck47QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLG1DQUFtQywrQkFBK0IsMkJBQTJCLG1CQUFtQixnQ0FBZ0M7QUFDN047QUFDQSxZQUFZLDhEQUE4RCxrQ0FBa0MsOEVBQThFLHdEQUF3RCxxQkFBcUIsa0dBQWtHLGlFQUFpRSxvQ0FBb0Msc0dBQXNHO0FBQ3BqQixPQUFPLGtFQUFrRSxzQ0FBc0MsK0JBQStCLEVBQUUsdUVBQXVFO0FBQ3ZOO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTywwSkFBMEosa0hBQWtILGlKQUFpSixtQ0FBbUMscUNBQXFDLEVBQUU7QUFDNWYsbUVBQW1FLHFDQUFxQyw0REFBNEQscUNBQXFDLHlEQUF5RCxTQUFTLDREQUE0RCw2REFBNkQsbUNBQW1DLHVDQUF1QyxxQ0FBcUM7QUFDbmY7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBDQUEwQyxvQ0FBb0Msa0NBQWtDLGtGQUFrRiwyQkFBMkIsb0NBQW9DLG9DQUFvQyxvRkFBb0Y7QUFDdFosaUJBQWlCLG1DQUFtQyxFQUFFLG9CQUFvQixFQUFFLFdBQVcsRUFBRTs7QUFFekYsK0JBQStCLHlDQUF5QyxRQUFRLDZDQUE2Qyw0Q0FBNEMsRUFBRSxpREFBaUQsNkVBQTZFOztBQUV6UztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CLHFDQUFxQyx1QkFBdUIsc0NBQXNDLDBCQUEwQiwwREFBMEQsa0NBQWtDLHdDQUF3QyxpR0FBaUc7QUFDcFg7QUFDQSw4Q0FBOEMsRUFBRSxpQ0FBaUMsUUFBUSwrQkFBK0IsdUVBQXVFLFFBQVEsdUNBQXVDLGdGQUFnRixRQUFRO0FBQ3RVLE9BQU8sK0NBQStDLHVEQUF1RCxrRkFBa0Ysd0NBQXdDLEVBQUU7QUFDek8sa0ZBQWtGO0FBQ2xGLHlDQUF5QztBQUN6QztBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esc0JBQXNCLE9BQU8sSUFBSSxxQ0FBcUMsZ0NBQWdDLE1BQU0sa0VBQWtFLE1BQU0sc0NBQXNDLE1BQU0sNEJBQTRCLDBDQUEwQyxNQUFNLHdDQUF3QyxNQUFNLDhCQUE4QixNQUFNLGlDQUFpQyxvREFBb0QsTUFBTSw0QkFBNEIsTUFBTSxxQ0FBcUMsV0FBVyxxQ0FBcUMsMkJBQTJCLHdFQUF3RSxJQUFJLEdBQUcsNkJBQTZCO0FBQ3Z0QixrQ0FBa0MsK0JBQStCLG1CQUFtQixXQUFXLDZCQUE2QjtBQUM1SCxtREFBbUQsc0NBQXNDLE1BQU0sMEJBQTBCO0FBQ3pIO0FBQ0EsaUJBQWlCLGlDQUFpQztBQUNsRDtBQUNBLGdEQUFnRCxrQ0FBa0MsMEZBQTBGO0FBQzVLO0FBQ0Esa0NBQWtDLG1DQUFtQyxrREFBa0QsbUJBQW1CLHlEQUF5RCwwQkFBMEIsMEZBQTBGLHNGQUFzRixvRkFBb0Ysb0lBQW9JLDhIQUE4SCxnSEFBZ0g7QUFDbjFCO0FBQ0Esa0JBQWtCLG1DQUFtQywrREFBK0QsNEJBQTRCO0FBQ2hKO0FBQ0Esc0JBQXNCO0FBQ3RCLDBCQUEwQixnQ0FBZ0M7QUFDMUQsb0VBQW9FLDJFQUEyRSxvREFBb0QsNkdBQTZHO0FBQ2hULDBCQUEwQjtBQUMxQiw0Q0FBNEM7QUFDNUM7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCO0FBQ3JCLGtDQUFrQztBQUNsQyxPQUFPLGtDQUFrQyx1Q0FBdUMsRUFBRSxzQkFBc0I7QUFDeEcsMERBQTBEO0FBQzFEO0FBQ0EsMkZBQTJGO0FBQzNGLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsVUFBVSw2Q0FBNkMsK0RBQStELHlEQUF5RCxFQUFFO0FBQ2pMLCtCQUErQjtBQUMvQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsOERBQThELCtCQUErQiwyQ0FBMkMsMERBQTBELGtCQUFrQixrQ0FBa0MsaUNBQWlDO0FBQ3ZSLG1EQUFtRCw0REFBNEQ7QUFDL0c7QUFDQSx3QkFBd0I7QUFDeEIsNkdBQTZHLFFBQVE7QUFDckgsc0lBQXNJLHVGQUF1RixnQ0FBZ0MsaURBQWlELFFBQVE7QUFDdFQsbURBQW1ELHdIQUF3SDtBQUMzSyxPQUFPLDRNQUE0TSw0QkFBNEIsT0FBTyxpREFBaUQsNkRBQTZELElBQUksR0FBRztBQUMzVztBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsMkNBQTJDLHVDQUF1QztBQUNsRjtBQUNBLDJDQUEyQyxtQkFBbUIsa0NBQWtDLDJHQUEyRyxRQUFRLHlDQUF5QyxNQUFNLGFBQWEsMEJBQTBCLHdEQUF3RCxRQUFRO0FBQ3pXO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5REFBeUQsTUFBTSx3R0FBd0cseUNBQXlDLGtCQUFrQixrQ0FBa0MsMEdBQTBHLFFBQVEseUNBQXlDLE1BQU0sUUFBUSxpQ0FBaUMsNkJBQTZCLHdJQUF3SSxFQUFFO0FBQy9xQjtBQUNBO0FBQ0EsMEZBQTBGLDhFQUE4RTtBQUN4SztBQUNBLHVCQUF1QixvREFBb0QsMENBQTBDLG1CQUFtQixrQ0FBa0MsMEdBQTBHLFFBQVEseUNBQXlDLE1BQU0sVUFBVSxhQUFhLEdBQUcsaUNBQWlDLDZCQUE2QixrSEFBa0gsR0FBRyw2Q0FBNkMsc0JBQXNCLGtDQUFrQywwR0FBMEcsUUFBUSx5Q0FBeUMsTUFBTSxRQUFRLGlDQUFpQywwSEFBMEgsdUJBQXVCLGNBQWM7QUFDdCtCLDRCQUE0QixvREFBb0QsdURBQXVELDZCQUE2QixtR0FBbUcsR0FBRywwQ0FBMEMsbUJBQW1CLGtDQUFrQywwR0FBMEcsUUFBUSx5Q0FBeUMsTUFBTSxRQUFRLGlDQUFpQyw2RkFBNkYsNkJBQTZCLHFGQUFxRixHQUFHLDBDQUEwQyxtQkFBbUIsa0NBQWtDLDBHQUEwRyxRQUFRLHlDQUF5QyxNQUFNLFFBQVEsaUNBQWlDO0FBQzlpQyw2QkFBNkIsc0RBQXNELHdEQUF3RCw2QkFBNkIscUdBQXFHLEdBQUcsMENBQTBDLG1CQUFtQixrQ0FBa0MsMEdBQTBHLFFBQVEseUNBQXlDLE1BQU0sYUFBYSx5Q0FBeUMsd0JBQXdCLHlEQUF5RCw0RUFBNEUsNEJBQTRCO0FBQy92QixrQ0FBa0MsbUlBQW1JLFFBQVEseUNBQXlDLE1BQU0sYUFBYSwyRUFBMkU7QUFDcFQsWUFBWSxtQ0FBbUM7QUFDL0MsZ0JBQWdCLHVDQUF1QztBQUN2RCxhQUFhLG9DQUFvQztBQUNqRCxpQkFBaUIsd0NBQXdDLG1EQUFtRCwwQkFBMEIsa0NBQWtDLDRHQUE0RyxRQUFRLHlDQUF5QyxNQUFNLGFBQWEsMkNBQTJDLHVDQUF1Qyx3QkFBd0Isa0NBQWtDLGtHQUFrRyxRQUFRLHlDQUF5QyxNQUFNLGFBQWEsZ0NBQWdDO0FBQzFxQixlQUFlLHdEQUF3RCx3QkFBd0IsNENBQTRDLHFCQUFxQixrQ0FBa0MsMEdBQTBHLFFBQVEsNERBQTRELE9BQU8saUNBQWlDLGtEQUFrRCxxRUFBcUUsTUFBTSx5QkFBeUIsMEZBQTBGLDZDQUE2Qyx3Q0FBd0MsRUFBRTtBQUMvdEIsb0VBQW9FLDRHQUE0RztBQUNoTCw0Q0FBNEM7QUFDNUMsa0RBQWtEO0FBQ2xELDRCQUE0Qix3QkFBd0IsK0NBQStDLHlDQUF5QztBQUM1STtBQUNBLGtEQUFrRCx5RUFBeUUseUJBQXlCLG1IQUFtSCxNQUFNLDJCQUEyQixtREFBbUQsK0NBQStDLHlCQUF5QixpSEFBaUgsTUFBTSwwQkFBMEIsb0JBQW9CLDhDQUE4QztBQUN0bkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysa0NBQWtDLHlCQUF5Qix5Q0FBeUMsTUFBTSxhQUFhLDBIQUEwSCxNQUFNLGlDQUFpQywwRkFBMEYsUUFBUSw4SEFBOEg7QUFDeGtCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSw0QkFBNEI7QUFDNUIsc0JBQXNCLHVCQUF1QixxQkFBcUI7QUFDbEUsY0FBYyxJQUFJLG9DQUFvQztBQUN0RDtBQUNBLHVDQUF1QztBQUN2QyxDQUFDLDRDQUE0QyxpRUFBaUUsK0RBQStELCtCQUErQixpQ0FBaUMsdUVBQXVFLCtCQUErQixpQ0FBaUMsdUNBQXVDLGlDQUFpQyxpQ0FBaUMsaUNBQWlDLG1EQUFtRCxtREFBbUQseUNBQXlDLGlEQUFpRCwyQ0FBMkMsbURBQW1ELCtDQUErQywyQ0FBMkMsK0NBQStDLCtDQUErQyxxQ0FBcUMsK0RBQStELG1DQUFtQyxxQ0FBcUMsOERBQThELG1FQUFtRTtBQUNqd0MsZ0NBQWdDO0FBQ2hDO0FBQ0EsaUNBQWlDLGFBQWEsNEJBQTRCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2Q0FBNkMsOFlBQThZLG1DQUFtQztBQUNqZ0IsMkJBQTJCO0FBQzNCLGlDQUFpQyxnQ0FBZ0Msa0NBQWtDLG9DQUFvQztBQUN2STtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9DQUFvQztBQUNyRTtBQUNBLG9DQUFvQyxJQUFJLHdCQUF3Qix1Q0FBdUMscUNBQXFDLDJFQUEyRSw2QkFBNkIscURBQXFELDRDQUE0QyxhQUFhLDBCQUEwQixtQkFBbUI7QUFDL1k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxJQUFJLHNDQUFzQyxRQUFRLHFDQUFxQztBQUNwSSwyQ0FBMkM7QUFDM0M7QUFDQSxtRUFBbUU7QUFDbkUseURBQXlELG9FQUFvRSxpR0FBaUcsYUFBYSw0QkFBNEI7QUFDdlE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU0sb0JBQW9CLGlCQUFpQixNQUFNLDBEQUEwRCxlQUFlLGVBQWUsTUFBTSw2R0FBNkcsbUJBQW1CLGlFQUFpRTtBQUMzWDtBQUNBO0FBQ0EscUVBQXFFLDBCQUEwQixRQUFRLHdEQUF3RDtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxxRUFBcUUscUJBQXFCLDJCQUEyQix1REFBdUQsdUNBQXVDLCtGQUErRix5Q0FBeUMsV0FBVyxFQUFFLG9GQUFvRixJQUFJLFFBQVEsTUFBTTtBQUNyZ0IsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSxnQ0FBZ0MsbUdBQW1HO0FBQ25JO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQseUVBQXlFO0FBQ3pFLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxxQkFBcUIsSUFBSSxpRUFBaUUsYUFBYSw0QkFBNEI7QUFDbkk7QUFDQTtBQUNBLGdEQUFnRCxJQUFJLHlNQUF5TSxhQUFhLDRCQUE0QjtBQUN0UztBQUNBO0FBQ0EseUNBQXlDLElBQUksZ0xBQWdMLGFBQWEsNEJBQTRCO0FBQ3RRO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSSxtTEFBbUwsYUFBYSw0QkFBNEI7QUFDelE7QUFDQTtBQUNBLGdDQUFnQyxJQUFJLHVLQUF1SyxhQUFhLDRCQUE0QjtBQUNwUDtBQUNBO0FBQ0EsdUNBQXVDLElBQUksOEtBQThLLGFBQWEsNEJBQTRCO0FBQ2xRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUksZ0VBQWdFLGFBQWEsNEJBQTRCLHdCQUF3QixJQUFJLGdGQUFnRixhQUFhLDBCQUEwQixtQkFBbUIsaURBQWlELElBQUkscUhBQXFILGFBQWEsNEJBQTRCLFlBQVksSUFBSSxpREFBaUQsYUFBYSwwQkFBMEIsbUJBQW1CLGdCQUFnQixJQUFJLHFEQUFxRCxhQUFhLDBCQUEwQixtQkFBbUIsYUFBYSxJQUFJLGtEQUFrRCxhQUFhLDBCQUEwQixtQkFBbUIsaUJBQWlCLElBQUksc0RBQXNELGFBQWEsMEJBQTBCLG1CQUFtQix3QkFBd0IsSUFBSSx5RUFBeUUsYUFBYSw0QkFBNEIsYUFBYSxJQUFJLDJDQUEyQyxhQUFhLDRCQUE0QixlQUFlLElBQUksb0RBQW9ELGFBQWEsMEJBQTBCLG1CQUFtQixvQkFBb0IsSUFBSSxxRUFBcUUsYUFBYSw0QkFBNEIsaUJBQWlCLElBQUksa0VBQWtFLGFBQWEsNEJBQTRCLGdEQUFnRCxJQUFJLG9IQUFvSCxhQUFhOztBQUU5d0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BydWRkZXJzdGFjay9hbmFseXRpY3MtanMvZGlzdC9ucG0vbW9kZXJuL2VzbS9pbmRleC5tanM/N2ZiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfaXNQbGFjZWhvbGRlcihhKXtyZXR1cm4gYSE9bnVsbCYmdHlwZW9mIGE9PT0nb2JqZWN0JyYmYVsnQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJ109PT10cnVlO31cblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgb25lLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL2Z1bmN0aW9uIF9jdXJyeTEoZm4pe3JldHVybiBmdW5jdGlvbiBmMShhKXtpZihhcmd1bWVudHMubGVuZ3RoPT09MHx8X2lzUGxhY2Vob2xkZXIoYSkpe3JldHVybiBmMTt9ZWxzZSB7cmV0dXJuIGZuLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt9fTt9XG5cbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIHR3by1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9mdW5jdGlvbiBfY3VycnkyKGZuKXtyZXR1cm4gZnVuY3Rpb24gZjIoYSxiKXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBmMjtjYXNlIDE6cmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpP2YyOl9jdXJyeTEoZnVuY3Rpb24oX2Ipe3JldHVybiBmbihhLF9iKTt9KTtkZWZhdWx0OnJldHVybiBfaXNQbGFjZWhvbGRlcihhKSYmX2lzUGxhY2Vob2xkZXIoYik/ZjI6X2lzUGxhY2Vob2xkZXIoYSk/X2N1cnJ5MShmdW5jdGlvbihfYSl7cmV0dXJuIGZuKF9hLGIpO30pOl9pc1BsYWNlaG9sZGVyKGIpP19jdXJyeTEoZnVuY3Rpb24oX2Ipe3JldHVybiBmbihhLF9iKTt9KTpmbihhLGIpO319O31cblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgdGhyZWUtYXJpdHkgY3VycnkgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICovZnVuY3Rpb24gX2N1cnJ5Myhmbil7cmV0dXJuIGZ1bmN0aW9uIGYzKGEsYixjKXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBmMztjYXNlIDE6cmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpP2YzOl9jdXJyeTIoZnVuY3Rpb24oX2IsX2Mpe3JldHVybiBmbihhLF9iLF9jKTt9KTtjYXNlIDI6cmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpJiZfaXNQbGFjZWhvbGRlcihiKT9mMzpfaXNQbGFjZWhvbGRlcihhKT9fY3VycnkyKGZ1bmN0aW9uKF9hLF9jKXtyZXR1cm4gZm4oX2EsYixfYyk7fSk6X2lzUGxhY2Vob2xkZXIoYik/X2N1cnJ5MihmdW5jdGlvbihfYixfYyl7cmV0dXJuIGZuKGEsX2IsX2MpO30pOl9jdXJyeTEoZnVuY3Rpb24oX2Mpe3JldHVybiBmbihhLGIsX2MpO30pO2RlZmF1bHQ6cmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpJiZfaXNQbGFjZWhvbGRlcihiKSYmX2lzUGxhY2Vob2xkZXIoYyk/ZjM6X2lzUGxhY2Vob2xkZXIoYSkmJl9pc1BsYWNlaG9sZGVyKGIpP19jdXJyeTIoZnVuY3Rpb24oX2EsX2Ipe3JldHVybiBmbihfYSxfYixjKTt9KTpfaXNQbGFjZWhvbGRlcihhKSYmX2lzUGxhY2Vob2xkZXIoYyk/X2N1cnJ5MihmdW5jdGlvbihfYSxfYyl7cmV0dXJuIGZuKF9hLGIsX2MpO30pOl9pc1BsYWNlaG9sZGVyKGIpJiZfaXNQbGFjZWhvbGRlcihjKT9fY3VycnkyKGZ1bmN0aW9uKF9iLF9jKXtyZXR1cm4gZm4oYSxfYixfYyk7fSk6X2lzUGxhY2Vob2xkZXIoYSk/X2N1cnJ5MShmdW5jdGlvbihfYSl7cmV0dXJuIGZuKF9hLGIsYyk7fSk6X2lzUGxhY2Vob2xkZXIoYik/X2N1cnJ5MShmdW5jdGlvbihfYil7cmV0dXJuIGZuKGEsX2IsYyk7fSk6X2lzUGxhY2Vob2xkZXIoYyk/X2N1cnJ5MShmdW5jdGlvbihfYyl7cmV0dXJuIGZuKGEsYixfYyk7fSk6Zm4oYSxiLGMpO319O31cblxuZnVuY3Rpb24gX2hhcyhwcm9wLG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmoscHJvcCk7fVxuXG4vKipcbiAqIEdpdmVzIGEgc2luZ2xlLXdvcmQgc3RyaW5nIGRlc2NyaXB0aW9uIG9mIHRoZSAobmF0aXZlKSB0eXBlIG9mIGEgdmFsdWUsXG4gKiByZXR1cm5pbmcgc3VjaCBhbnN3ZXJzIGFzICdPYmplY3QnLCAnTnVtYmVyJywgJ0FycmF5Jywgb3IgJ051bGwnLiBEb2VzIG5vdFxuICogYXR0ZW1wdCB0byBkaXN0aW5ndWlzaCB1c2VyIE9iamVjdCB0eXBlcyBhbnkgZnVydGhlciwgcmVwb3J0aW5nIHRoZW0gYWxsIGFzXG4gKiAnT2JqZWN0Jy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAc2lnICogLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudHlwZSh7fSk7IC8vPT4gXCJPYmplY3RcIlxuICogICAgICBSLnR5cGUobmV3IE1hcCk7IC8vPT4gXCJNYXBcIlxuICogICAgICBSLnR5cGUobmV3IFNldCk7IC8vPT4gXCJTZXRcIlxuICogICAgICBSLnR5cGUoMSk7IC8vPT4gXCJOdW1iZXJcIlxuICogICAgICBSLnR5cGUoZmFsc2UpOyAvLz0+IFwiQm9vbGVhblwiXG4gKiAgICAgIFIudHlwZSgncycpOyAvLz0+IFwiU3RyaW5nXCJcbiAqICAgICAgUi50eXBlKG51bGwpOyAvLz0+IFwiTnVsbFwiXG4gKiAgICAgIFIudHlwZShbXSk7IC8vPT4gXCJBcnJheVwiXG4gKiAgICAgIFIudHlwZSgvW0Etel0vKTsgLy89PiBcIlJlZ0V4cFwiXG4gKiAgICAgIFIudHlwZSgoKSA9PiB7fSk7IC8vPT4gXCJGdW5jdGlvblwiXG4gKiAgICAgIFIudHlwZShhc3luYyAoKSA9PiB7fSk7IC8vPT4gXCJBc3luY0Z1bmN0aW9uXCJcbiAqICAgICAgUi50eXBlKHVuZGVmaW5lZCk7IC8vPT4gXCJVbmRlZmluZWRcIlxuICogICAgICBSLnR5cGUoQmlnSW50KDEyMykpOyAvLz0+IFwiQmlnSW50XCJcbiAqL3ZhciB0eXBlPS8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIHR5cGUodmFsKXtyZXR1cm4gdmFsPT09bnVsbD8nTnVsbCc6dmFsPT09dW5kZWZpbmVkPydVbmRlZmluZWQnOk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsLTEpO30pO1xuXG5mdW5jdGlvbiBfaXNPYmplY3QoeCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KT09PSdbb2JqZWN0IE9iamVjdF0nO31cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIHBhc3NlZCBhcmd1bWVudCBpcyBhbiBpbnRlZ2VyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG5cbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovY29uc3QgX2lzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXJ8fGZ1bmN0aW9uIF9pc0ludGVnZXIobil7cmV0dXJuIG48PDA9PT1uO307XG5cbmZ1bmN0aW9uIF9udGgob2Zmc2V0LGxpc3Qpe3ZhciBpZHg9b2Zmc2V0PDA/bGlzdC5sZW5ndGgrb2Zmc2V0Om9mZnNldDtyZXR1cm4gbGlzdFtpZHhdO31cblxuZnVuY3Rpb24gX2Nsb25lUmVnRXhwKHBhdHRlcm4pe3JldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLHBhdHRlcm4uZmxhZ3M/cGF0dGVybi5mbGFnczoocGF0dGVybi5nbG9iYWw/J2cnOicnKSsocGF0dGVybi5pZ25vcmVDYXNlPydpJzonJykrKHBhdHRlcm4ubXVsdGlsaW5lPydtJzonJykrKHBhdHRlcm4uc3RpY2t5Pyd5JzonJykrKHBhdHRlcm4udW5pY29kZT8ndSc6JycpKyhwYXR0ZXJuLmRvdEFsbD8ncyc6JycpKTt9XG5cbi8qKlxuICogQ29waWVzIGFuIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY29waWVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXAgV2hldGhlciBvciBub3QgdG8gcGVyZm9ybSBkZWVwIGNsb25pbmcuXG4gKiBAcmV0dXJuIHsqfSBUaGUgY29waWVkIHZhbHVlLlxuICovZnVuY3Rpb24gX2Nsb25lKHZhbHVlLGRlZXAsbWFwKXttYXB8fChtYXA9bmV3IF9PYmplY3RNYXAoKSk7Ly8gdGhpcyBhdm9pZHMgdGhlIHNsb3dlciBzd2l0Y2ggd2l0aCBhIHF1aWNrIGlmIGRlY2lzaW9uIHJlbW92aW5nIHNvbWUgbWlsbGlzZWNvbmRzIGluIGVhY2ggcnVuLlxuaWYoX2lzUHJpbWl0aXZlKHZhbHVlKSl7cmV0dXJuIHZhbHVlO312YXIgY29weT1mdW5jdGlvbiBjb3B5KGNvcGllZFZhbHVlKXsvLyBDaGVjayBmb3IgY2lyY3VsYXIgYW5kIHNhbWUgcmVmZXJlbmNlcyBvbiB0aGUgb2JqZWN0IGdyYXBoIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG52YXIgY2FjaGVkQ29weT1tYXAuZ2V0KHZhbHVlKTtpZihjYWNoZWRDb3B5KXtyZXR1cm4gY2FjaGVkQ29weTt9bWFwLnNldCh2YWx1ZSxjb3BpZWRWYWx1ZSk7Zm9yKHZhciBrZXkgaW4gdmFsdWUpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSxrZXkpKXtjb3BpZWRWYWx1ZVtrZXldPV9jbG9uZSh2YWx1ZVtrZXldLHRydWUsbWFwKTt9fXJldHVybiBjb3BpZWRWYWx1ZTt9O3N3aXRjaCh0eXBlKHZhbHVlKSl7Y2FzZSAnT2JqZWN0JzpyZXR1cm4gY29weShPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkpKTtjYXNlICdBcnJheSc6cmV0dXJuIGNvcHkoQXJyYXkodmFsdWUubGVuZ3RoKSk7Y2FzZSAnRGF0ZSc6cmV0dXJuIG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSk7Y2FzZSAnUmVnRXhwJzpyZXR1cm4gX2Nsb25lUmVnRXhwKHZhbHVlKTtjYXNlICdJbnQ4QXJyYXknOmNhc2UgJ1VpbnQ4QXJyYXknOmNhc2UgJ1VpbnQ4Q2xhbXBlZEFycmF5JzpjYXNlICdJbnQxNkFycmF5JzpjYXNlICdVaW50MTZBcnJheSc6Y2FzZSAnSW50MzJBcnJheSc6Y2FzZSAnVWludDMyQXJyYXknOmNhc2UgJ0Zsb2F0MzJBcnJheSc6Y2FzZSAnRmxvYXQ2NEFycmF5JzpjYXNlICdCaWdJbnQ2NEFycmF5JzpjYXNlICdCaWdVaW50NjRBcnJheSc6cmV0dXJuIHZhbHVlLnNsaWNlKCk7ZGVmYXVsdDpyZXR1cm4gdmFsdWU7fX1mdW5jdGlvbiBfaXNQcmltaXRpdmUocGFyYW0pe3ZhciB0eXBlPXR5cGVvZiBwYXJhbTtyZXR1cm4gcGFyYW09PW51bGx8fHR5cGUhPSdvYmplY3QnJiZ0eXBlIT0nZnVuY3Rpb24nO312YXIgX09iamVjdE1hcD0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXtmdW5jdGlvbiBfT2JqZWN0TWFwKCl7dGhpcy5tYXA9e307dGhpcy5sZW5ndGg9MDt9X09iamVjdE1hcC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGtleSx2YWx1ZSl7dmFyIGhhc2hlZEtleT10aGlzLmhhc2goa2V5KTt2YXIgYnVja2V0PXRoaXMubWFwW2hhc2hlZEtleV07aWYoIWJ1Y2tldCl7dGhpcy5tYXBbaGFzaGVkS2V5XT1idWNrZXQ9W107fWJ1Y2tldC5wdXNoKFtrZXksdmFsdWVdKTt0aGlzLmxlbmd0aCs9MTt9O19PYmplY3RNYXAucHJvdG90eXBlLmhhc2g9ZnVuY3Rpb24oa2V5KXt2YXIgaGFzaGVkS2V5PVtdO2Zvcih2YXIgdmFsdWUgaW4ga2V5KXtoYXNoZWRLZXkucHVzaChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoa2V5W3ZhbHVlXSkpO31yZXR1cm4gaGFzaGVkS2V5LmpvaW4oKTt9O19PYmplY3RNYXAucHJvdG90eXBlLmdldD1mdW5jdGlvbihrZXkpey8qKlxuICAgICAqIGRlcGVuZGluZyBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgY2xvbmVkIGlzIGZhc3RlciB0byBqdXN0IGl0ZXJhdGUgb3ZlciB0aGUgaXRlbXMgaW4gdGhlIG1hcCBqdXN0IGJlY2F1c2UgdGhlIGhhc2ggZnVuY3Rpb24gaXMgc28gY29zdGx5LFxuICAgICAqIG9uIG15IHRlc3RzIHRoaXMgbnVtYmVyIGlzIDE4MCwgYW55dGhpbmcgYWJvdmUgdGhhdCB1c2luZyB0aGUgaGFzaCBmdW5jdGlvbiBpcyBmYXN0ZXIuXG4gICAgICovaWYodGhpcy5sZW5ndGg8PTE4MCl7Zm9yKHZhciBwIGluIHRoaXMubWFwKXt2YXIgYnVja2V0PXRoaXMubWFwW3BdO2Zvcih2YXIgaT0wO2k8YnVja2V0Lmxlbmd0aDtpKz0xKXt2YXIgZWxlbWVudD1idWNrZXRbaV07aWYoZWxlbWVudFswXT09PWtleSl7cmV0dXJuIGVsZW1lbnRbMV07fX19cmV0dXJuO312YXIgaGFzaGVkS2V5PXRoaXMuaGFzaChrZXkpO3ZhciBidWNrZXQ9dGhpcy5tYXBbaGFzaGVkS2V5XTtpZighYnVja2V0KXtyZXR1cm47fWZvcih2YXIgaT0wO2k8YnVja2V0Lmxlbmd0aDtpKz0xKXt2YXIgZWxlbWVudD1idWNrZXRbaV07aWYoZWxlbWVudFswXT09PWtleSl7cmV0dXJuIGVsZW1lbnRbMV07fX19O3JldHVybiBfT2JqZWN0TWFwO30oKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSBzb3VyY2UgdGhhdCBjYW4gYmUgdXNlZCBpbiBwbGFjZSBvZiB0aGUgc291cmNlXG4gKiBvYmplY3Qgd2l0aG91dCByZXRhaW5pbmcgYW55IHJlZmVyZW5jZXMgdG8gaXQuXG4gKiBUaGUgc291cmNlIG9iamVjdCBtYXkgY29udGFpbiAobmVzdGVkKSBgQXJyYXlgcyBhbmQgYE9iamVjdGBzLFxuICogYE51bWJlcmBzLCBgU3RyaW5nYHMsIGBCb29sZWFuYHMgYW5kIGBEYXRlYHMuXG4gKiBgRnVuY3Rpb25gcyBhcmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlIHJhdGhlciB0aGFuIGNvcGllZC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIGEgYGNsb25lYCBtZXRob2QgaWYgcHJlc2VudC5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgdGhlIHNvdXJjZSBvYmplY3QgaGFzIG11bHRpcGxlIG5vZGVzIHRoYXQgc2hhcmUgYSByZWZlcmVuY2UsXG4gKiB0aGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmUsIGJ1dCB0aGUgcmVmZXJlbmNlcyB3aWxsXG4gKiBiZSBwb2ludGVkIHRvIHRoZSBsb2NhdGlvbiB3aXRoaW4gdGhlIGNsb25lZCB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgeyp9IC0+IHsqfVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGNsb25lXG4gKiBAcmV0dXJuIHsqfSBBIGRlZXBseSBjbG9uZWQgY29weSBvZiBgdmFsYFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IG9iamVjdHMgPSBbe30sIHt9LCB7fV07XG4gKiAgICAgIGNvbnN0IG9iamVjdHNDbG9uZSA9IFIuY2xvbmUob2JqZWN0cyk7XG4gKiAgICAgIG9iamVjdHMgPT09IG9iamVjdHNDbG9uZTsgLy89PiBmYWxzZVxuICogICAgICBvYmplY3RzWzBdID09PSBvYmplY3RzQ2xvbmVbMF07IC8vPT4gZmFsc2VcbiAqL3ZhciBjbG9uZT0vKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBjbG9uZSh2YWx1ZSl7cmV0dXJuIHZhbHVlIT1udWxsJiZ0eXBlb2YgdmFsdWUuY2xvbmU9PT0nZnVuY3Rpb24nP3ZhbHVlLmNsb25lKCk6X2Nsb25lKHZhbHVlKTt9KTtcblxuZnVuY3Rpb24gX3BhdGgocGF0aEFyLG9iail7dmFyIHZhbD1vYmo7Zm9yKHZhciBpPTA7aTxwYXRoQXIubGVuZ3RoO2krPTEpe2lmKHZhbD09bnVsbCl7cmV0dXJuIHVuZGVmaW5lZDt9dmFyIHA9cGF0aEFyW2ldO2lmKF9pc0ludGVnZXIocCkpe3ZhbD1fbnRoKHAsdmFsKTt9ZWxzZSB7dmFsPXZhbFtwXTt9fXJldHVybiB2YWw7fVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSB0d28gcHJvdmlkZWQgb2JqZWN0cy4gSWZcbiAqIGEga2V5IGV4aXN0cyBpbiBib3RoIG9iamVjdHMsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBrZXlcbiAqIGFuZCB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IGluIGVhY2ggb2JqZWN0LCB3aXRoIHRoZSByZXN1bHQgYmVpbmdcbiAqIHVzZWQgYXMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IGluIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKFN0cmluZywgYSwgYSkgLT4gYSkgLT4ge2F9IC0+IHthfSAtPiB7YX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gbFxuICogQHBhcmFtIHtPYmplY3R9IHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZURlZXBXaXRoS2V5LCBSLm1lcmdlV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGxldCBjb25jYXRWYWx1ZXMgPSAoaywgbCwgcikgPT4gayA9PSAndmFsdWVzJyA/IFIuY29uY2F0KGwsIHIpIDogclxuICogICAgICBSLm1lcmdlV2l0aEtleShjb25jYXRWYWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgICAgIHsgYTogdHJ1ZSwgdGhpbmc6ICdmb28nLCB2YWx1ZXM6IFsxMCwgMjBdIH0sXG4gKiAgICAgICAgICAgICAgICAgICAgIHsgYjogdHJ1ZSwgdGhpbmc6ICdiYXInLCB2YWx1ZXM6IFsxNSwgMzVdIH0pO1xuICogICAgICAvLz0+IHsgYTogdHJ1ZSwgYjogdHJ1ZSwgdGhpbmc6ICdiYXInLCB2YWx1ZXM6IFsxMCwgMjAsIDE1LCAzNV0gfVxuICogQHN5bWIgUi5tZXJnZVdpdGhLZXkoZiwgeyB4OiAxLCB5OiAyIH0sIHsgeTogNSwgejogMyB9KSA9IHsgeDogMSwgeTogZigneScsIDIsIDUpLCB6OiAzIH1cbiAqL3ZhciBtZXJnZVdpdGhLZXk9LyojX19QVVJFX18qL19jdXJyeTMoZnVuY3Rpb24gbWVyZ2VXaXRoS2V5KGZuLGwscil7dmFyIHJlc3VsdD17fTt2YXIgaztsPWx8fHt9O3I9cnx8e307Zm9yKGsgaW4gbCl7aWYoX2hhcyhrLGwpKXtyZXN1bHRba109X2hhcyhrLHIpP2ZuKGssbFtrXSxyW2tdKTpsW2tdO319Zm9yKGsgaW4gcil7aWYoX2hhcyhrLHIpJiYhX2hhcyhrLHJlc3VsdCkpe3Jlc3VsdFtrXT1yW2tdO319cmV0dXJuIHJlc3VsdDt9KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgdHdvIHByb3ZpZGVkIG9iamVjdHMuXG4gKiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzOlxuICogLSBhbmQgYm90aCBhc3NvY2lhdGVkIHZhbHVlcyBhcmUgYWxzbyBvYmplY3RzIHRoZW4gdGhlIHZhbHVlcyB3aWxsIGJlXG4gKiAgIHJlY3Vyc2l2ZWx5IG1lcmdlZC5cbiAqIC0gb3RoZXJ3aXNlIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBrZXkgYW5kIGFzc29jaWF0ZWQgdmFsdWVzXG4gKiAgIHVzaW5nIHRoZSByZXN1bHRpbmcgdmFsdWUgYXMgdGhlIG5ldyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS5cbiAqIElmIGEga2V5IG9ubHkgZXhpc3RzIGluIG9uZSBvYmplY3QsIHRoZSB2YWx1ZSB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XG4gKiBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgoU3RyaW5nLCBhLCBhKSAtPiBhKSAtPiB7YX0gLT4ge2F9IC0+IHthfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsT2JqXG4gKiBAcGFyYW0ge09iamVjdH0gck9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLm1lcmdlV2l0aEtleSwgUi5tZXJnZURlZXBXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgbGV0IGNvbmNhdFZhbHVlcyA9IChrLCBsLCByKSA9PiBrID09ICd2YWx1ZXMnID8gUi5jb25jYXQobCwgcikgOiByXG4gKiAgICAgIFIubWVyZ2VEZWVwV2l0aEtleShjb25jYXRWYWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB7IGE6IHRydWUsIGM6IHsgdGhpbmc6ICdmb28nLCB2YWx1ZXM6IFsxMCwgMjBdIH19LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgeyBiOiB0cnVlLCBjOiB7IHRoaW5nOiAnYmFyJywgdmFsdWVzOiBbMTUsIDM1XSB9fSk7XG4gKiAgICAgIC8vPT4geyBhOiB0cnVlLCBiOiB0cnVlLCBjOiB7IHRoaW5nOiAnYmFyJywgdmFsdWVzOiBbMTAsIDIwLCAxNSwgMzVdIH19XG4gKi92YXIgbWVyZ2VEZWVwV2l0aEtleT0vKiNfX1BVUkVfXyovX2N1cnJ5MyhmdW5jdGlvbiBtZXJnZURlZXBXaXRoS2V5KGZuLGxPYmosck9iail7cmV0dXJuIG1lcmdlV2l0aEtleShmdW5jdGlvbihrLGxWYWwsclZhbCl7aWYoX2lzT2JqZWN0KGxWYWwpJiZfaXNPYmplY3QoclZhbCkpe3JldHVybiBtZXJnZURlZXBXaXRoS2V5KGZuLGxWYWwsclZhbCk7fWVsc2Uge3JldHVybiBmbihrLGxWYWwsclZhbCk7fX0sbE9iaixyT2JqKTt9KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgdHdvIHByb3ZpZGVkIG9iamVjdHMuXG4gKiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzOlxuICogLSBhbmQgYm90aCBhc3NvY2lhdGVkIHZhbHVlcyBhcmUgYWxzbyBvYmplY3RzIHRoZW4gdGhlIHZhbHVlcyB3aWxsIGJlXG4gKiAgIHJlY3Vyc2l2ZWx5IG1lcmdlZC5cbiAqIC0gb3RoZXJ3aXNlIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIGFzc29jaWF0ZWQgdmFsdWVzIHVzaW5nIHRoZVxuICogICByZXN1bHRpbmcgdmFsdWUgYXMgdGhlIG5ldyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS5cbiAqIElmIGEga2V5IG9ubHkgZXhpc3RzIGluIG9uZSBvYmplY3QsIHRoZSB2YWx1ZSB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XG4gKiBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgoYSwgYSkgLT4gYSkgLT4ge2F9IC0+IHthfSAtPiB7YX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gbE9ialxuICogQHBhcmFtIHtPYmplY3R9IHJPYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZVdpdGgsIFIubWVyZ2VEZWVwV2l0aEtleVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVyZ2VEZWVwV2l0aChSLmNvbmNhdCxcbiAqICAgICAgICAgICAgICAgICAgICAgIHsgYTogdHJ1ZSwgYzogeyB2YWx1ZXM6IFsxMCwgMjBdIH19LFxuICogICAgICAgICAgICAgICAgICAgICAgeyBiOiB0cnVlLCBjOiB7IHZhbHVlczogWzE1LCAzNV0gfX0pO1xuICogICAgICAvLz0+IHsgYTogdHJ1ZSwgYjogdHJ1ZSwgYzogeyB2YWx1ZXM6IFsxMCwgMjAsIDE1LCAzNV0gfX1cbiAqL3ZhciBtZXJnZURlZXBXaXRoPS8qI19fUFVSRV9fKi9fY3VycnkzKGZ1bmN0aW9uIG1lcmdlRGVlcFdpdGgoZm4sbE9iaixyT2JqKXtyZXR1cm4gbWVyZ2VEZWVwV2l0aEtleShmdW5jdGlvbihrLGxWYWwsclZhbCl7cmV0dXJuIGZuKGxWYWwsclZhbCk7fSxsT2JqLHJPYmopO30pO1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoLiBUaGUgbm9kZXMgb2YgdGhlIHBhdGggY2FuIGJlIGFyYml0cmFyeSBzdHJpbmdzIG9yIG5vbi1uZWdhdGl2ZSBpbnRlZ2Vycy5cbiAqIEZvciBhbnl0aGluZyBlbHNlLCB0aGUgdmFsdWUgaXMgdW5zcGVjaWZpZWQuIEludGVnZXIgcGF0aHMgYXJlIG1lYW50IHRvIGluZGV4IGFycmF5cywgc3RyaW5ncyBhcmUgbWVhbnQgZm9yIG9iamVjdHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50IHwgU3ltYm9sXG4gKiBAc2lnIFtJZHhdIC0+IHthfSAtPiBhIHwgVW5kZWZpbmVkXG4gKiBAc2lnIElkeCA9IFN0cmluZyB8IE5vbk5lZ2F0aXZlSW50XG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCBvciBhcnJheSB0byByZXRyaWV2ZSB0aGUgbmVzdGVkIHByb3BlcnR5IGZyb20uXG4gKiBAcmV0dXJuIHsqfSBUaGUgZGF0YSBhdCBgcGF0aGAuXG4gKiBAc2VlIFIucHJvcCwgUi5udGgsIFIuYXNzb2NQYXRoLCBSLmRpc3NvY1BhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhdGgoWydhJywgJ2InXSwge2E6IHtiOiAyfX0pOyAvLz0+IDJcbiAqICAgICAgUi5wYXRoKFsnYScsICdiJ10sIHtjOiB7YjogMn19KTsgLy89PiB1bmRlZmluZWRcbiAqICAgICAgUi5wYXRoKFsnYScsICdiJywgMF0sIHthOiB7YjogWzEsIDIsIDNdfX0pOyAvLz0+IDFcbiAqICAgICAgUi5wYXRoKFsnYScsICdiJywgLTJdLCB7YToge2I6IFsxLCAyLCAzXX19KTsgLy89PiAyXG4gKiAgICAgIFIucGF0aChbMl0sIHsnMic6IDJ9KTsgLy89PiAyXG4gKiAgICAgIFIucGF0aChbLTJdLCB7Jy0yJzogJ2EnfSk7IC8vPT4gdW5kZWZpbmVkXG4gKi92YXIgcGF0aD0vKiNfX1BVUkVfXyovX2N1cnJ5MihfcGF0aCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHBhcnRpYWwgY29weSBvZiBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IHRoZSBrZXlzIHRoYXQgc2F0aXNmeVxuICogdGhlIHN1cHBsaWVkIHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgKCh2LCBrKSAtPiBCb29sZWFuKSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGtleVxuICogICAgICAgIHNob3VsZCBiZSBpbmNsdWRlZCBvbiB0aGUgb3V0cHV0IG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjb3B5IGZyb21cbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggb25seSBwcm9wZXJ0aWVzIHRoYXQgc2F0aXNmeSBgcHJlZGBcbiAqICAgICAgICAgb24gaXQuXG4gKiBAc2VlIFIucGljaywgUi5maWx0ZXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBpc1VwcGVyQ2FzZSA9ICh2YWwsIGtleSkgPT4ga2V5LnRvVXBwZXJDYXNlKCkgPT09IGtleTtcbiAqICAgICAgUi5waWNrQnkoaXNVcHBlckNhc2UsIHthOiAxLCBiOiAyLCBBOiAzLCBCOiA0fSk7IC8vPT4ge0E6IDMsIEI6IDR9XG4gKi92YXIgcGlja0J5PS8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIHBpY2tCeSh0ZXN0LG9iail7dmFyIHJlc3VsdD17fTtmb3IodmFyIHByb3AgaW4gb2JqKXtpZih0ZXN0KG9ialtwcm9wXSxwcm9wLG9iaikpe3Jlc3VsdFtwcm9wXT1vYmpbcHJvcF07fX1yZXR1cm4gcmVzdWx0O30pO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gY2hlY2sgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvblxuICogQHBhcmFtIHZhbHVlIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9jb25zdCBpc0Z1bmN0aW9uPXZhbHVlPT50eXBlb2YgdmFsdWU9PT0nZnVuY3Rpb24nJiZCb29sZWFuKHZhbHVlLmNvbnN0cnVjdG9yJiZ2YWx1ZS5jYWxsJiZ2YWx1ZS5hcHBseSk7LyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNoZWNrIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nXG4gKiBAcGFyYW0gdmFsdWUgaW5wdXQgdmFsdWVcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL2NvbnN0IGlzU3RyaW5nPXZhbHVlPT50eXBlb2YgdmFsdWU9PT0nc3RyaW5nJzsvKipcbiAqIEEgZnVuY3Rpb24gdG8gY2hlY2sgZ2l2ZW4gdmFsdWUgaXMgbnVsbCBvciBub3RcbiAqIEBwYXJhbSB2YWx1ZSBpbnB1dCB2YWx1ZVxuICogQHJldHVybnMgYm9vbGVhblxuICovY29uc3QgaXNOdWxsPXZhbHVlPT52YWx1ZT09PW51bGw7LyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNoZWNrIGdpdmVuIHZhbHVlIGlzIHVuZGVmaW5lZFxuICogQHBhcmFtIHZhbHVlIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9jb25zdCBpc1VuZGVmaW5lZD12YWx1ZT0+dHlwZW9mIHZhbHVlPT09J3VuZGVmaW5lZCc7LyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNoZWNrIGdpdmVuIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkXG4gKiBAcGFyYW0gdmFsdWUgaW5wdXQgdmFsdWVcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL2NvbnN0IGlzTnVsbE9yVW5kZWZpbmVkPXZhbHVlPT5pc051bGwodmFsdWUpfHxpc1VuZGVmaW5lZCh2YWx1ZSk7LyoqXG4gKiBDaGVja3MgaWYgdGhlIGlucHV0IGlzIGEgQmlnSW50XG4gKiBAcGFyYW0gdmFsdWUgaW5wdXQgdmFsdWVcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGlucHV0IGlzIGEgQmlnSW50XG4gKi9jb25zdCBpc0JpZ0ludD12YWx1ZT0+dHlwZW9mIHZhbHVlPT09J2JpZ2ludCc7LyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNoZWNrIGdpdmVuIHZhbHVlIGlzIGRlZmluZWRcbiAqIEBwYXJhbSB2YWx1ZSBpbnB1dCB2YWx1ZVxuICogQHJldHVybnMgYm9vbGVhblxuICovY29uc3QgaXNEZWZpbmVkPXZhbHVlPT4haXNVbmRlZmluZWQodmFsdWUpOy8qKlxuICogQSBmdW5jdGlvbiB0byBjaGVjayBnaXZlbiB2YWx1ZSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbFxuICogQHBhcmFtIHZhbHVlIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9jb25zdCBpc0RlZmluZWRBbmROb3ROdWxsPXZhbHVlPT4haXNOdWxsT3JVbmRlZmluZWQodmFsdWUpOy8qKlxuICogQSBmdW5jdGlvbiB0byBjaGVjayBnaXZlbiB2YWx1ZSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbFxuICogQHBhcmFtIHZhbHVlIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9jb25zdCBpc0RlZmluZWROb3ROdWxsQW5kTm90RW1wdHlTdHJpbmc9dmFsdWU9PmlzRGVmaW5lZEFuZE5vdE51bGwodmFsdWUpJiZ2YWx1ZSE9PScnOy8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgb2YgdHlwZSBlcnJvclxuICogQHBhcmFtIHZhbHVlIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBpbnB1dCBpcyBvZiB0eXBlIGVycm9yIGVsc2UgZmFsc2VcbiAqL2NvbnN0IGlzVHlwZU9mRXJyb3I9dmFsdWU9Pntzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSl7Y2FzZSAnW29iamVjdCBFcnJvcl0nOmNhc2UgJ1tvYmplY3QgRXhjZXB0aW9uXSc6Y2FzZSAnW29iamVjdCBET01FeGNlcHRpb25dJzpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO319Oy8qKlxuICogQSBmdW5jdGlvbiB0byBjaGVjayBnaXZlbiB2YWx1ZSBpcyBhIGJvb2xlYW5cbiAqIEBwYXJhbSB2YWx1ZSBpbnB1dCB2YWx1ZVxuICogQHJldHVybnMgYm9vbGVhblxuICovY29uc3QgaXNCb29sZWFuPXZhbHVlPT50eXBlb2YgdmFsdWU9PT0nYm9vbGVhbic7XG5cbmNvbnN0IGdldFZhbHVlQnlQYXRoPShvYmosa2V5UGF0aCk9Pntjb25zdCBwYXRoUGFydHM9a2V5UGF0aC5zcGxpdCgnLicpO3JldHVybiBwYXRoKHBhdGhQYXJ0cyxvYmopO307Y29uc3QgaGFzVmFsdWVCeVBhdGg9KG9iaixwYXRoKT0+Qm9vbGVhbihnZXRWYWx1ZUJ5UGF0aChvYmoscGF0aCkpO2NvbnN0IGlzT2JqZWN0PXZhbHVlPT50eXBlb2YgdmFsdWU9PT0nb2JqZWN0JzsvKipcbiAqIENoZWNrcyBpZiB0aGUgaW5wdXQgaXMgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYnVpbHQtaW4gb2JqZWN0IHR5cGUgYW5kIG5vdCBudWxsXG4gKiBAcGFyYW0gdmFsdWUgSW5wdXQgdmFsdWVcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGlzIGFuIG9iamVjdCBhbmQgbm90IG51bGxcbiAqL2NvbnN0IGlzT2JqZWN0QW5kTm90TnVsbD12YWx1ZT0+IWlzTnVsbCh2YWx1ZSkmJmlzT2JqZWN0KHZhbHVlKSYmIUFycmF5LmlzQXJyYXkodmFsdWUpOy8qKlxuICogQ2hlY2tzIGlmIHRoZSBpbnB1dCBpcyBhbiBvYmplY3QgbGl0ZXJhbCBhbmQgbm90IG51bGxcbiAqIEBwYXJhbSB2YWx1ZSBJbnB1dCB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgaXMgYW4gb2JqZWN0IGFuZCBub3QgbnVsbFxuICovY29uc3QgaXNPYmplY3RMaXRlcmFsQW5kTm90TnVsbD12YWx1ZT0+IWlzTnVsbCh2YWx1ZSkmJk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk9PT0nW29iamVjdCBPYmplY3RdJzsvKipcbiAqIE1lcmdlcyB0d28gYXJyYXlzIGRlZXBseSwgcmlnaHQtdG8tbGVmdFxuICogSW4gdGhlIGNhc2Ugb2YgY29uZmxpY3RzLCB0aGUgcmlnaHQgYXJyYXkncyB2YWx1ZXMgcmVwbGFjZSB0aGUgbGVmdCBhcnJheSdzIHZhbHVlcyBpbiB0aGVcbiAqIHNhbWUgaW5kZXggcG9zaXRpb25cbiAqIEBwYXJhbSBsZWZ0VmFsdWUgLSBUaGUgbGVmdCBhcnJheVxuICogQHBhcmFtIHJpZ2h0VmFsdWUgLSBUaGUgcmlnaHQgYXJyYXlcbiAqIEByZXR1cm5zIFRoZSBtZXJnZWQgYXJyYXlcbiAqL2NvbnN0IG1lcmdlRGVlcFJpZ2h0T2JqZWN0QXJyYXlzPShsZWZ0VmFsdWUscmlnaHRWYWx1ZSk9PntpZighQXJyYXkuaXNBcnJheShsZWZ0VmFsdWUpfHwhQXJyYXkuaXNBcnJheShyaWdodFZhbHVlKSl7cmV0dXJuIGNsb25lKHJpZ2h0VmFsdWUpO31jb25zdCBtZXJnZWRBcnJheT1jbG9uZShsZWZ0VmFsdWUpO3JpZ2h0VmFsdWUuZm9yRWFjaCgodmFsdWUsaW5kZXgpPT57bWVyZ2VkQXJyYXlbaW5kZXhdPUFycmF5LmlzQXJyYXkodmFsdWUpfHxpc09iamVjdEFuZE5vdE51bGwodmFsdWUpPy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbm1lcmdlRGVlcFJpZ2h0KG1lcmdlZEFycmF5W2luZGV4XSx2YWx1ZSk6dmFsdWU7fSk7cmV0dXJuIG1lcmdlZEFycmF5O307LyoqXG4gKiBNZXJnZXMgdHdvIG9iamVjdHMgZGVlcGx5LCByaWdodC10by1sZWZ0LlxuICogSW4gdGhlIGNhc2Ugb2YgY29uZmxpY3RzLCB0aGUgcmlnaHQgb2JqZWN0J3MgdmFsdWVzIHRha2UgcHJlY2VkZW5jZS5cbiAqIEZvciBhcnJheXMsIHRoZSByaWdodCBhcnJheSdzIHZhbHVlcyByZXBsYWNlIHRoZSBsZWZ0IGFycmF5J3MgdmFsdWVzIGluIHRoZVxuICogc2FtZSBpbmRleCBwb3NpdGlvbiBrZWVwaW5nIHRoZSByZW1haW5pbmcgbGVmdCBhcnJheSdzIHZhbHVlcyBpbiB0aGUgcmVzdWx0YW50IGFycmF5LlxuICogQHBhcmFtIGxlZnRPYmplY3QgLSBUaGUgbGVmdCBvYmplY3RcbiAqIEBwYXJhbSByaWdodE9iamVjdCAtIFRoZSByaWdodCBvYmplY3RcbiAqIEByZXR1cm5zIFRoZSBtZXJnZWQgb2JqZWN0XG4gKi9jb25zdCBtZXJnZURlZXBSaWdodD0obGVmdE9iamVjdCxyaWdodE9iamVjdCk9Pm1lcmdlRGVlcFdpdGgobWVyZ2VEZWVwUmlnaHRPYmplY3RBcnJheXMsbGVmdE9iamVjdCxyaWdodE9iamVjdCk7LyoqXG4gQ2hlY2tzIGlmIHRoZSBpbnB1dCBpcyBhIG5vbi1lbXB0eSBvYmplY3QgbGl0ZXJhbCB0eXBlIGFuZCBub3QgdW5kZWZpbmVkIG9yIG51bGxcbiAqIEBwYXJhbSB2YWx1ZSBpbnB1dCBhbnlcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL2NvbnN0IGlzTm9uRW1wdHlPYmplY3Q9dmFsdWU9PmlzT2JqZWN0TGl0ZXJhbEFuZE5vdE51bGwodmFsdWUpJiZPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoPjA7LyoqXG4gKiBBIHV0aWxpdHkgdG8gcmVjdXJzaXZlbHkgcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSBvYmogaW5wdXQgb2JqZWN0XG4gKiBAcmV0dXJucyBhIG5ldyBvYmplY3RcbiAqL2NvbnN0IHJlbW92ZVVuZGVmaW5lZFZhbHVlcz1vYmo9Pntjb25zdCByZXN1bHQ9cGlja0J5KGlzRGVmaW5lZCxvYmopO09iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChrZXk9Pntjb25zdCB2YWx1ZT1yZXN1bHRba2V5XTtpZihpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKHZhbHVlKSl7cmVzdWx0W2tleV09cmVtb3ZlVW5kZWZpbmVkVmFsdWVzKHZhbHVlKTt9fSk7cmV0dXJuIHJlc3VsdDt9Oy8qKlxuICogQSB1dGlsaXR5IHRvIHJlY3Vyc2l2ZWx5IHJlbW92ZSB1bmRlZmluZWQgYW5kIG51bGwgdmFsdWVzIGZyb20gYW4gb2JqZWN0XG4gKiBAcGFyYW0gb2JqIGlucHV0IG9iamVjdFxuICogQHJldHVybnMgYSBuZXcgb2JqZWN0XG4gKi9jb25zdCByZW1vdmVVbmRlZmluZWRBbmROdWxsVmFsdWVzPW9iaj0+e2NvbnN0IHJlc3VsdD1waWNrQnkoaXNEZWZpbmVkQW5kTm90TnVsbCxvYmopO09iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChrZXk9Pntjb25zdCB2YWx1ZT1yZXN1bHRba2V5XTtpZihpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKHZhbHVlKSl7cmVzdWx0W2tleV09cmVtb3ZlVW5kZWZpbmVkQW5kTnVsbFZhbHVlcyh2YWx1ZSk7fX0pO3JldHVybiByZXN1bHQ7fTsvKipcbiAqIE5vcm1hbGl6ZXMgYW4gb2JqZWN0IGJ5IHJlbW92aW5nIHVuZGVmaW5lZCBhbmQgbnVsbCB2YWx1ZXMuXG4gKiBAcGFyYW0gdmFsIC0gVGhlIHZhbHVlIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgb2JqZWN0LCBvciB1bmRlZmluZWQgaWYgaW5wdXQgaXMgbm90IGEgbm9uLWVtcHR5IG9iamVjdFxuICogQGV4YW1wbGVcbiAqIGdldE5vcm1hbGl6ZWRPYmplY3RWYWx1ZSh7IGE6IDEsIGI6IG51bGwsIGM6IHVuZGVmaW5lZCB9KSAvLyByZXR1cm5zIHsgYTogMSB9XG4gKiBnZXROb3JtYWxpemVkT2JqZWN0VmFsdWUoe30pIC8vIHJldHVybnMgdW5kZWZpbmVkXG4gKiBnZXROb3JtYWxpemVkT2JqZWN0VmFsdWUobnVsbCkgLy8gcmV0dXJucyB1bmRlZmluZWRcbiAqL2NvbnN0IGdldE5vcm1hbGl6ZWRPYmplY3RWYWx1ZT12YWw9PntpZighaXNOb25FbXB0eU9iamVjdCh2YWwpKXtyZXR1cm4gdW5kZWZpbmVkO31yZXR1cm4gcmVtb3ZlVW5kZWZpbmVkQW5kTnVsbFZhbHVlcyh2YWwpO307LyoqXG4gKiBOb3JtYWxpemVzIGEgdmFsdWUgdG8gYSBib29sZWFuLCB3aXRoIHN1cHBvcnQgZm9yIGEgZGVmYXVsdCB2YWx1ZVxuICogQHBhcmFtIHZhbCBJbnB1dCB2YWx1ZVxuICogQHBhcmFtIGRlZlZhbCBEZWZhdWx0IHZhbHVlXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBpbnB1dCB2YWx1ZSBpZiBpdCBpcyBhIGJvb2xlYW4sIG90aGVyd2lzZSByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlXG4gKiBAZXhhbXBsZVxuICogZ2V0Tm9ybWFsaXplZEJvb2xlYW5WYWx1ZSh0cnVlLCBmYWxzZSkgLy8gcmV0dXJucyB0cnVlXG4gKi9jb25zdCBnZXROb3JtYWxpemVkQm9vbGVhblZhbHVlPSh2YWwsZGVmVmFsKT0+dHlwZW9mIHZhbD09PSdib29sZWFuJz92YWw6ZGVmVmFsO2NvbnN0IGRlZXBGcmVlemU9b2JqPT57T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3Ape2lmKG9ialtwcm9wXSYmdHlwZW9mIG9ialtwcm9wXT09PSdvYmplY3QnKXtkZWVwRnJlZXplKG9ialtwcm9wXSk7fX0pO3JldHVybiBPYmplY3QuZnJlZXplKG9iaik7fTtcblxuY29uc3QgdHJpbT12YWx1ZT0+dmFsdWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZ20sJycpO2NvbnN0IHJlbW92ZUxlYWRpbmdQZXJpb2Q9dmFsdWU9PnZhbHVlLnJlcGxhY2UoL15cXC4rLywnJyk7LyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNvbnZlcnQgdmFsdWVzIHRvIHN0cmluZ1xuICogQHBhcmFtIHZhbCBpbnB1dCB2YWx1ZVxuICogQHJldHVybnMgc3RyaW5naWZpZWQgdmFsdWVcbiAqL2NvbnN0IHRyeVN0cmluZ2lmeT12YWw9PntsZXQgcmV0VmFsPXZhbDtpZighaXNTdHJpbmcodmFsKSYmIWlzTnVsbE9yVW5kZWZpbmVkKHZhbCkpe3RyeXtyZXRWYWw9SlNPTi5zdHJpbmdpZnkodmFsKTt9Y2F0Y2goZSl7cmV0VmFsPW51bGw7fX1yZXR1cm4gcmV0VmFsO307Ly8gVGhlIGZvbGxvd2luZyB0ZXh0IGVuY29kaW5nIGFuZCBkZWNvZGluZyBpcyBkb25lIGJlZm9yZSBiYXNlNjQgZW5jb2RpbmcgdG8gcHJldmVudFxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ5dGVzIGFycmF5IHRvIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICogQHBhcmFtIGJ5dGVzIGJ5dGVzIGFycmF5IHRvIGJlIGNvbnZlcnRlZCB0byBiYXNlNjRcbiAqIEByZXR1cm5zIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICovY29uc3QgYnl0ZXNUb0Jhc2U2ND1ieXRlcz0+e2NvbnN0IGJpblN0cmluZz1BcnJheS5mcm9tKGJ5dGVzLHg9PlN0cmluZy5mcm9tQ29kZVBvaW50KHgpKS5qb2luKCcnKTtyZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpblN0cmluZyk7fTsvKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgdG8gYmFzZTY0IGV2ZW4gd2l0aCB1bmljb2RlIGNoYXJhY3RlcnNcbiAqIEBwYXJhbSB2YWx1ZSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICovY29uc3QgdG9CYXNlNjQ9dmFsdWU9PmJ5dGVzVG9CYXNlNjQobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKSk7XG5cbi8vICAgaWYgeWVzIG1ha2UgdGhlbSBudWxsIGluc3RlYWQgb2Ygb21pdHRpbmcgaW4gb3ZlcmxvYWRlZCBjYXNlc1xuLypcbiAqIE5vcm1hbGlzZSB0aGUgb3ZlcmxvYWRlZCBhcmd1bWVudHMgb2YgdGhlIHBhZ2UgY2FsbCBmYWNhZGVcbiAqL2NvbnN0IHBhZ2VBcmd1bWVudHNUb0NhbGxPcHRpb25zPShjYXRlZ29yeSxuYW1lLHByb3BlcnRpZXMsb3B0aW9ucyxjYWxsYmFjayk9Pntjb25zdCBwYXlsb2FkPXtjYXRlZ29yeTpjYXRlZ29yeSxuYW1lOm5hbWUscHJvcGVydGllczpwcm9wZXJ0aWVzLG9wdGlvbnM6b3B0aW9ucyxjYWxsYmFjazp1bmRlZmluZWR9O2lmKGlzRnVuY3Rpb24oY2FsbGJhY2spKXtwYXlsb2FkLmNhbGxiYWNrPWNhbGxiYWNrO31pZihpc0Z1bmN0aW9uKG9wdGlvbnMpKXtwYXlsb2FkLmNhdGVnb3J5PWNhdGVnb3J5O3BheWxvYWQubmFtZT1uYW1lO3BheWxvYWQucHJvcGVydGllcz1wcm9wZXJ0aWVzO3BheWxvYWQub3B0aW9ucz11bmRlZmluZWQ7cGF5bG9hZC5jYWxsYmFjaz1vcHRpb25zO31pZihpc0Z1bmN0aW9uKHByb3BlcnRpZXMpKXtwYXlsb2FkLmNhdGVnb3J5PWNhdGVnb3J5O3BheWxvYWQubmFtZT1uYW1lO3BheWxvYWQucHJvcGVydGllcz11bmRlZmluZWQ7cGF5bG9hZC5vcHRpb25zPXVuZGVmaW5lZDtwYXlsb2FkLmNhbGxiYWNrPXByb3BlcnRpZXM7fWlmKGlzRnVuY3Rpb24obmFtZSkpe3BheWxvYWQuY2F0ZWdvcnk9Y2F0ZWdvcnk7cGF5bG9hZC5uYW1lPXVuZGVmaW5lZDtwYXlsb2FkLnByb3BlcnRpZXM9dW5kZWZpbmVkO3BheWxvYWQub3B0aW9ucz11bmRlZmluZWQ7cGF5bG9hZC5jYWxsYmFjaz1uYW1lO31pZihpc0Z1bmN0aW9uKGNhdGVnb3J5KSl7cGF5bG9hZC5jYXRlZ29yeT11bmRlZmluZWQ7cGF5bG9hZC5uYW1lPXVuZGVmaW5lZDtwYXlsb2FkLnByb3BlcnRpZXM9dW5kZWZpbmVkO3BheWxvYWQub3B0aW9ucz11bmRlZmluZWQ7cGF5bG9hZC5jYWxsYmFjaz1jYXRlZ29yeTt9aWYoaXNPYmplY3RMaXRlcmFsQW5kTm90TnVsbChjYXRlZ29yeSkpe3BheWxvYWQubmFtZT11bmRlZmluZWQ7cGF5bG9hZC5jYXRlZ29yeT11bmRlZmluZWQ7cGF5bG9hZC5wcm9wZXJ0aWVzPWNhdGVnb3J5O2lmKCFpc0Z1bmN0aW9uKG5hbWUpKXtwYXlsb2FkLm9wdGlvbnM9bmFtZTt9ZWxzZSB7cGF5bG9hZC5vcHRpb25zPXVuZGVmaW5lZDt9fWVsc2UgaWYoaXNPYmplY3RMaXRlcmFsQW5kTm90TnVsbChuYW1lKSl7cGF5bG9hZC5uYW1lPXVuZGVmaW5lZDtwYXlsb2FkLnByb3BlcnRpZXM9bmFtZTtpZighaXNGdW5jdGlvbihwcm9wZXJ0aWVzKSl7cGF5bG9hZC5vcHRpb25zPXByb3BlcnRpZXM7fWVsc2Uge3BheWxvYWQub3B0aW9ucz11bmRlZmluZWQ7fX0vLyBpZiB0aGUgY2F0ZWdvcnkgYXJndW1lbnQgYWxvbmUgaXMgcHJvdmlkZWQgYi93IGNhdGVnb3J5IGFuZCBuYW1lLFxuLy8gdXNlIGl0IGFzIG5hbWUgYW5kIHNldCBjYXRlZ29yeSB0byB1bmRlZmluZWRcbmlmKGlzU3RyaW5nKGNhdGVnb3J5KSYmIWlzU3RyaW5nKG5hbWUpKXtwYXlsb2FkLmNhdGVnb3J5PXVuZGVmaW5lZDtwYXlsb2FkLm5hbWU9Y2F0ZWdvcnk7fS8vIFJlc3Qgb2YgdGhlIGNvZGUgaXMganVzdCB0byBjbGVhbiB1cCB1bmRlZmluZWQgdmFsdWVzXG4vLyBhbmQgc2V0IHNvbWUgcHJvcGVyIGRlZmF1bHRzXG4vLyBBbHNvLCB0byBjbG9uZSB0aGUgaW5jb21pbmcgb2JqZWN0IHR5cGUgYXJndW1lbnRzXG5pZighaXNEZWZpbmVkKHBheWxvYWQuY2F0ZWdvcnkpKXtwYXlsb2FkLmNhdGVnb3J5PXVuZGVmaW5lZDt9aWYoIWlzRGVmaW5lZChwYXlsb2FkLm5hbWUpKXtwYXlsb2FkLm5hbWU9dW5kZWZpbmVkO31wYXlsb2FkLnByb3BlcnRpZXM9cGF5bG9hZC5wcm9wZXJ0aWVzP2Nsb25lKHBheWxvYWQucHJvcGVydGllcyk6e307aWYoaXNEZWZpbmVkKHBheWxvYWQub3B0aW9ucykpe3BheWxvYWQub3B0aW9ucz1jbG9uZShwYXlsb2FkLm9wdGlvbnMpO31lbHNlIHtwYXlsb2FkLm9wdGlvbnM9dW5kZWZpbmVkO31jb25zdCBuYW1lRm9yUHJvcGVydGllcz1pc1N0cmluZyhwYXlsb2FkLm5hbWUpP3BheWxvYWQubmFtZTpwYXlsb2FkLnByb3BlcnRpZXMubmFtZTtjb25zdCBjYXRlZ29yeUZvclByb3BlcnRpZXM9aXNTdHJpbmcocGF5bG9hZC5jYXRlZ29yeSk/cGF5bG9hZC5jYXRlZ29yeTpwYXlsb2FkLnByb3BlcnRpZXMuY2F0ZWdvcnk7Ly8gYWRkIG5hbWUgYW5kIGNhdGVnb3J5IHRvIHByb3BlcnRpZXNcbnBheWxvYWQucHJvcGVydGllcz1tZXJnZURlZXBSaWdodChpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKHBheWxvYWQucHJvcGVydGllcyk/cGF5bG9hZC5wcm9wZXJ0aWVzOnt9LHsuLi4obmFtZUZvclByb3BlcnRpZXMmJntuYW1lOm5hbWVGb3JQcm9wZXJ0aWVzfSksLi4uKGNhdGVnb3J5Rm9yUHJvcGVydGllcyYme2NhdGVnb3J5OmNhdGVnb3J5Rm9yUHJvcGVydGllc30pfSk7cmV0dXJuIHBheWxvYWQ7fTsvKlxuICogTm9ybWFsaXNlIHRoZSBvdmVybG9hZGVkIGFyZ3VtZW50cyBvZiB0aGUgdHJhY2sgY2FsbCBmYWNhZGVcbiAqL2NvbnN0IHRyYWNrQXJndW1lbnRzVG9DYWxsT3B0aW9ucz0oZXZlbnQscHJvcGVydGllcyxvcHRpb25zLGNhbGxiYWNrKT0+e2NvbnN0IHBheWxvYWQ9e25hbWU6ZXZlbnQscHJvcGVydGllczpwcm9wZXJ0aWVzLG9wdGlvbnM6b3B0aW9ucyxjYWxsYmFjazp1bmRlZmluZWR9O2lmKGlzRnVuY3Rpb24oY2FsbGJhY2spKXtwYXlsb2FkLmNhbGxiYWNrPWNhbGxiYWNrO31pZihpc0Z1bmN0aW9uKG9wdGlvbnMpKXtwYXlsb2FkLnByb3BlcnRpZXM9cHJvcGVydGllcztwYXlsb2FkLm9wdGlvbnM9dW5kZWZpbmVkO3BheWxvYWQuY2FsbGJhY2s9b3B0aW9uczt9aWYoaXNGdW5jdGlvbihwcm9wZXJ0aWVzKSl7cGF5bG9hZC5wcm9wZXJ0aWVzPXVuZGVmaW5lZDtwYXlsb2FkLm9wdGlvbnM9dW5kZWZpbmVkO3BheWxvYWQuY2FsbGJhY2s9cHJvcGVydGllczt9Ly8gUmVzdCBvZiB0aGUgY29kZSBpcyBqdXN0IHRvIGNsZWFuIHVwIHVuZGVmaW5lZCB2YWx1ZXNcbi8vIGFuZCBzZXQgc29tZSBwcm9wZXIgZGVmYXVsdHNcbi8vIEFsc28sIHRvIGNsb25lIHRoZSBpbmNvbWluZyBvYmplY3QgdHlwZSBhcmd1bWVudHNcbnBheWxvYWQucHJvcGVydGllcz1pc0RlZmluZWRBbmROb3ROdWxsKHBheWxvYWQucHJvcGVydGllcyk/Y2xvbmUocGF5bG9hZC5wcm9wZXJ0aWVzKTp7fTtpZihpc0RlZmluZWQocGF5bG9hZC5vcHRpb25zKSl7cGF5bG9hZC5vcHRpb25zPWNsb25lKHBheWxvYWQub3B0aW9ucyk7fWVsc2Uge3BheWxvYWQub3B0aW9ucz11bmRlZmluZWQ7fXJldHVybiBwYXlsb2FkO307LypcbiAqIE5vcm1hbGlzZSB0aGUgb3ZlcmxvYWRlZCBhcmd1bWVudHMgb2YgdGhlIGlkZW50aWZ5IGNhbGwgZmFjYWRlXG4gKi9jb25zdCBpZGVudGlmeUFyZ3VtZW50c1RvQ2FsbE9wdGlvbnM9KHVzZXJJZCx0cmFpdHMsb3B0aW9ucyxjYWxsYmFjayk9Pntjb25zdCBwYXlsb2FkPXt1c2VySWQ6dXNlcklkLHRyYWl0czp0cmFpdHMsb3B0aW9uczpvcHRpb25zLGNhbGxiYWNrOnVuZGVmaW5lZH07aWYoaXNGdW5jdGlvbihjYWxsYmFjaykpe3BheWxvYWQuY2FsbGJhY2s9Y2FsbGJhY2s7fWlmKGlzRnVuY3Rpb24ob3B0aW9ucykpe3BheWxvYWQudXNlcklkPXVzZXJJZDtwYXlsb2FkLnRyYWl0cz10cmFpdHM7cGF5bG9hZC5vcHRpb25zPXVuZGVmaW5lZDtwYXlsb2FkLmNhbGxiYWNrPW9wdGlvbnM7fWlmKGlzRnVuY3Rpb24odHJhaXRzKSl7cGF5bG9hZC51c2VySWQ9dXNlcklkO3BheWxvYWQudHJhaXRzPXVuZGVmaW5lZDtwYXlsb2FkLm9wdGlvbnM9dW5kZWZpbmVkO3BheWxvYWQuY2FsbGJhY2s9dHJhaXRzO31pZihpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKHVzZXJJZCl8fGlzTnVsbCh1c2VySWQpKXsvLyBFeHBsaWNpdGx5IHNldCBudWxsIHRvIHByZXZlbnQgcmVzZXR0aW5nIHRoZSBleGlzdGluZyB2YWx1ZVxuLy8gaW4gdGhlIEFuYWx5dGljcyBjbGFzc1xucGF5bG9hZC51c2VySWQ9bnVsbDtwYXlsb2FkLnRyYWl0cz11c2VySWQ7aWYoIWlzRnVuY3Rpb24odHJhaXRzKSl7cGF5bG9hZC5vcHRpb25zPXRyYWl0czt9ZWxzZSB7cGF5bG9hZC5vcHRpb25zPXVuZGVmaW5lZDt9fS8vIFJlc3Qgb2YgdGhlIGNvZGUgaXMganVzdCB0byBjbGVhbiB1cCB1bmRlZmluZWQgdmFsdWVzXG4vLyBhbmQgc2V0IHNvbWUgcHJvcGVyIGRlZmF1bHRzXG4vLyBBbHNvLCB0byBjbG9uZSB0aGUgaW5jb21pbmcgb2JqZWN0IHR5cGUgYXJndW1lbnRzXG5wYXlsb2FkLnVzZXJJZD10cnlTdHJpbmdpZnkocGF5bG9hZC51c2VySWQpO2lmKGlzT2JqZWN0TGl0ZXJhbEFuZE5vdE51bGwocGF5bG9hZC50cmFpdHMpKXtwYXlsb2FkLnRyYWl0cz1jbG9uZShwYXlsb2FkLnRyYWl0cyk7fWVsc2Uge3BheWxvYWQudHJhaXRzPXVuZGVmaW5lZDt9aWYoaXNEZWZpbmVkKHBheWxvYWQub3B0aW9ucykpe3BheWxvYWQub3B0aW9ucz1jbG9uZShwYXlsb2FkLm9wdGlvbnMpO31lbHNlIHtwYXlsb2FkLm9wdGlvbnM9dW5kZWZpbmVkO31yZXR1cm4gcGF5bG9hZDt9Oy8qXG4gKiBOb3JtYWxpc2UgdGhlIG92ZXJsb2FkZWQgYXJndW1lbnRzIG9mIHRoZSBhbGlhcyBjYWxsIGZhY2FkZVxuICovY29uc3QgYWxpYXNBcmd1bWVudHNUb0NhbGxPcHRpb25zPSh0byxmcm9tLG9wdGlvbnMsY2FsbGJhY2spPT57Y29uc3QgcGF5bG9hZD17dG8sZnJvbTpmcm9tLG9wdGlvbnM6b3B0aW9ucyxjYWxsYmFjazp1bmRlZmluZWR9O2lmKGlzRnVuY3Rpb24oY2FsbGJhY2spKXtwYXlsb2FkLmNhbGxiYWNrPWNhbGxiYWNrO31pZihpc0Z1bmN0aW9uKG9wdGlvbnMpKXtwYXlsb2FkLnRvPXRvO3BheWxvYWQuZnJvbT1mcm9tO3BheWxvYWQub3B0aW9ucz11bmRlZmluZWQ7cGF5bG9hZC5jYWxsYmFjaz1vcHRpb25zO31pZihpc0Z1bmN0aW9uKGZyb20pKXtwYXlsb2FkLnRvPXRvO3BheWxvYWQuZnJvbT11bmRlZmluZWQ7cGF5bG9hZC5vcHRpb25zPXVuZGVmaW5lZDtwYXlsb2FkLmNhbGxiYWNrPWZyb207fWVsc2UgaWYoaXNPYmplY3RMaXRlcmFsQW5kTm90TnVsbChmcm9tKXx8aXNOdWxsKGZyb20pKXtwYXlsb2FkLnRvPXRvO3BheWxvYWQuZnJvbT11bmRlZmluZWQ7cGF5bG9hZC5vcHRpb25zPWZyb207fS8vIFJlc3Qgb2YgdGhlIGNvZGUgaXMganVzdCB0byBjbGVhbiB1cCB1bmRlZmluZWQgdmFsdWVzXG4vLyBhbmQgc2V0IHNvbWUgcHJvcGVyIGRlZmF1bHRzXG4vLyBBbHNvLCB0byBjbG9uZSB0aGUgaW5jb21pbmcgb2JqZWN0IHR5cGUgYXJndW1lbnRzXG5pZihpc0RlZmluZWQocGF5bG9hZC50bykpe3BheWxvYWQudG89dHJ5U3RyaW5naWZ5KHBheWxvYWQudG8pO31pZihpc0RlZmluZWQocGF5bG9hZC5mcm9tKSl7cGF5bG9hZC5mcm9tPXRyeVN0cmluZ2lmeShwYXlsb2FkLmZyb20pO31lbHNlIHtwYXlsb2FkLmZyb209dW5kZWZpbmVkO31pZihpc0RlZmluZWQocGF5bG9hZC5vcHRpb25zKSl7cGF5bG9hZC5vcHRpb25zPWNsb25lKHBheWxvYWQub3B0aW9ucyk7fWVsc2Uge3BheWxvYWQub3B0aW9ucz11bmRlZmluZWQ7fXJldHVybiBwYXlsb2FkO307LypcbiAqIE5vcm1hbGlzZSB0aGUgb3ZlcmxvYWRlZCBhcmd1bWVudHMgb2YgdGhlIGdyb3VwIGNhbGwgZmFjYWRlXG4gKi9jb25zdCBncm91cEFyZ3VtZW50c1RvQ2FsbE9wdGlvbnM9KGdyb3VwSWQsdHJhaXRzLG9wdGlvbnMsY2FsbGJhY2spPT57Y29uc3QgcGF5bG9hZD17Z3JvdXBJZDpncm91cElkLHRyYWl0czp0cmFpdHMsb3B0aW9uczpvcHRpb25zLGNhbGxiYWNrOnVuZGVmaW5lZH07aWYoaXNGdW5jdGlvbihjYWxsYmFjaykpe3BheWxvYWQuY2FsbGJhY2s9Y2FsbGJhY2s7fWlmKGlzRnVuY3Rpb24ob3B0aW9ucykpe3BheWxvYWQuZ3JvdXBJZD1ncm91cElkO3BheWxvYWQudHJhaXRzPXRyYWl0cztwYXlsb2FkLm9wdGlvbnM9dW5kZWZpbmVkO3BheWxvYWQuY2FsbGJhY2s9b3B0aW9uczt9aWYoaXNGdW5jdGlvbih0cmFpdHMpKXtwYXlsb2FkLmdyb3VwSWQ9Z3JvdXBJZDtwYXlsb2FkLnRyYWl0cz11bmRlZmluZWQ7cGF5bG9hZC5vcHRpb25zPXVuZGVmaW5lZDtwYXlsb2FkLmNhbGxiYWNrPXRyYWl0czt9aWYoaXNPYmplY3RMaXRlcmFsQW5kTm90TnVsbChncm91cElkKXx8aXNOdWxsKGdyb3VwSWQpKXsvLyBFeHBsaWNpdGx5IHNldCBudWxsIHRvIHByZXZlbnQgcmVzZXR0aW5nIHRoZSBleGlzdGluZyB2YWx1ZVxuLy8gaW4gdGhlIEFuYWx5dGljcyBjbGFzc1xucGF5bG9hZC5ncm91cElkPW51bGw7cGF5bG9hZC50cmFpdHM9Z3JvdXBJZDtpZighaXNGdW5jdGlvbih0cmFpdHMpKXtwYXlsb2FkLm9wdGlvbnM9dHJhaXRzO31lbHNlIHtwYXlsb2FkLm9wdGlvbnM9dW5kZWZpbmVkO319Ly8gUmVzdCBvZiB0aGUgY29kZSBpcyBqdXN0IHRvIGNsZWFuIHVwIHVuZGVmaW5lZCB2YWx1ZXNcbi8vIGFuZCBzZXQgc29tZSBwcm9wZXIgZGVmYXVsdHNcbi8vIEFsc28sIHRvIGNsb25lIHRoZSBpbmNvbWluZyBvYmplY3QgdHlwZSBhcmd1bWVudHNcbnBheWxvYWQuZ3JvdXBJZD10cnlTdHJpbmdpZnkocGF5bG9hZC5ncm91cElkKTtpZihpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKHBheWxvYWQudHJhaXRzKSl7cGF5bG9hZC50cmFpdHM9Y2xvbmUocGF5bG9hZC50cmFpdHMpO31lbHNlIHtwYXlsb2FkLnRyYWl0cz11bmRlZmluZWQ7fWlmKGlzRGVmaW5lZChwYXlsb2FkLm9wdGlvbnMpKXtwYXlsb2FkLm9wdGlvbnM9Y2xvbmUocGF5bG9hZC5vcHRpb25zKTt9ZWxzZSB7cGF5bG9hZC5vcHRpb25zPXVuZGVmaW5lZDt9cmV0dXJuIHBheWxvYWQ7fTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBvcHRpb25zIHBhcmFtZXRlciBmb3IgYW5vbnltb3VzSWRcbiAqLy8qKlxuICogUmVwcmVzZW50cyB0aGUgYmVhY29uIHF1ZXVlIG9wdGlvbnMgcGFyYW1ldGVyIGluIGxvYWRPcHRpb25zIHR5cGVcbiAqLy8qKlxuICogUmVwcmVzZW50cyB0aGUgcXVldWUgb3B0aW9ucyBwYXJhbWV0ZXIgaW4gbG9hZE9wdGlvbnMgdHlwZVxuICovLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkZXN0aW5hdGlvbnMgcXVldWUgb3B0aW9ucyBwYXJhbWV0ZXIgaW4gbG9hZE9wdGlvbnMgdHlwZVxuICovbGV0IFBhZ2VMaWZlY3ljbGVFdmVudHM9LyojX19QVVJFX18qL2Z1bmN0aW9uKFBhZ2VMaWZlY3ljbGVFdmVudHMpe1BhZ2VMaWZlY3ljbGVFdmVudHNbXCJVTkxPQURFRFwiXT1cIlBhZ2UgVW5sb2FkZWRcIjtyZXR1cm4gUGFnZUxpZmVjeWNsZUV2ZW50czt9KHt9KTsvKipcbiAqIFJlcHJlc2VudHMgdGhlIHNvdXJjZSBjb25maWd1cmF0aW9uIG92ZXJyaWRlIG9wdGlvbnMgZm9yIGRlc3RpbmF0aW9uc1xuICovLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBvcHRpb25zIHBhcmFtZXRlciBpbiB0aGUgbG9hZCBBUElcbiAqL1xuXG5jb25zdCBBUElfU1VGRklYPSdBUEknO2NvbnN0IENBUEFCSUxJVElFU19NQU5BR0VSPSdDYXBhYmlsaXRpZXNNYW5hZ2VyJztjb25zdCBDT05GSUdfTUFOQUdFUj0nQ29uZmlnTWFuYWdlcic7Y29uc3QgRVZFTlRfTUFOQUdFUj0nRXZlbnRNYW5hZ2VyJztjb25zdCBQTFVHSU5TX01BTkFHRVI9J1BsdWdpbnNNYW5hZ2VyJztjb25zdCBVU0VSX1NFU1NJT05fTUFOQUdFUj0nVXNlclNlc3Npb25NYW5hZ2VyJztjb25zdCBFUlJPUl9IQU5ETEVSPSdFcnJvckhhbmRsZXInO2NvbnN0IFBMVUdJTl9FTkdJTkU9J1BsdWdpbkVuZ2luZSc7Y29uc3QgU1RPUkVfTUFOQUdFUj0nU3RvcmVNYW5hZ2VyJztjb25zdCBSRUFEWV9BUEk9YFJlYWR5JHtBUElfU1VGRklYfWA7Y29uc3QgTE9BRF9BUEk9YExvYWQke0FQSV9TVUZGSVh9YDtjb25zdCBIVFRQX0NMSUVOVD0nSHR0cENsaWVudCc7Y29uc3QgUlNBPSdSdWRkZXJTdGFja0FuYWx5dGljcyc7Y29uc3QgQU5BTFlUSUNTX0NPUkU9J0FuYWx5dGljc0NvcmUnO1xuXG5mdW5jdGlvbiByYW5kb20obGVuKXtyZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShsZW4pKTt9XG5cbnZhciBTSVpFPTQwOTYsSEVYJDE9W10sSURYJDE9MCxCVUZGRVIkMTtmb3IoO0lEWCQxPDI1NjtJRFgkMSsrKXtIRVgkMVtJRFgkMV09KElEWCQxKzI1NikudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTt9ZnVuY3Rpb24gdjQkMSgpe2lmKCFCVUZGRVIkMXx8SURYJDErMTY+U0laRSl7QlVGRkVSJDE9cmFuZG9tKFNJWkUpO0lEWCQxPTA7fXZhciBpPTAsdG1wLG91dD0nJztmb3IoO2k8MTY7aSsrKXt0bXA9QlVGRkVSJDFbSURYJDEraV07aWYoaT09NilvdXQrPUhFWCQxW3RtcCYxNXw2NF07ZWxzZSBpZihpPT04KW91dCs9SEVYJDFbdG1wJjYzfDEyOF07ZWxzZSBvdXQrPUhFWCQxW3RtcF07aWYoaSYxJiZpPjEmJmk8MTEpb3V0Kz0nLSc7fUlEWCQxKz0xNjtyZXR1cm4gb3V0O31cblxudmFyIElEWD0yNTYsSEVYPVtdLEJVRkZFUjt3aGlsZShJRFgtLSlIRVhbSURYXT0oSURYKzI1NikudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtmdW5jdGlvbiB2NCgpe3ZhciBpPTAsbnVtLG91dD0nJztpZighQlVGRkVSfHxJRFgrMTY+MjU2KXtCVUZGRVI9QXJyYXkoaT0yNTYpO3doaWxlKGktLSlCVUZGRVJbaV09MjU2Kk1hdGgucmFuZG9tKCl8MDtpPUlEWD0wO31mb3IoO2k8MTY7aSsrKXtudW09QlVGRkVSW0lEWCtpXTtpZihpPT02KW91dCs9SEVYW251bSYxNXw2NF07ZWxzZSBpZihpPT04KW91dCs9SEVYW251bSY2M3wxMjhdO2Vsc2Ugb3V0Kz1IRVhbbnVtXTtpZihpJjEmJmk+MSYmaTwxMSlvdXQrPSctJzt9SURYKys7cmV0dXJuIG91dDt9XG5cbmNvbnN0IGhhc0NyeXB0byQxPSgpPT4haXNOdWxsT3JVbmRlZmluZWQoZ2xvYmFsVGhpcy5jcnlwdG8pJiZpc0Z1bmN0aW9uKGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyk7XG5cbmNvbnN0IGdlbmVyYXRlVVVJRD0oKT0+e2lmKGhhc0NyeXB0byQxKCkpe3JldHVybiB2NCQxKCk7fXJldHVybiB2NCgpO307XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgU0RLIGlzIHJ1bm5pbmcgaW5zaWRlIGEgY2hyb21lIGV4dGVuc2lvblxuICogQHJldHVybnMgYm9vbGVhblxuICovY29uc3QgaXNTREtSdW5uaW5nSW5DaHJvbWVFeHRlbnNpb249KCk9PiEhd2luZG93LmNocm9tZT8ucnVudGltZT8uaWQ7Y29uc3QgaXNJRTExPSgpPT5pc1N0cmluZyhnbG9iYWxUaGlzLm5hdmlnYXRvci51c2VyQWdlbnQpJiYvVHJpZGVudC4qcnY6MTFcXC4vLnRlc3QoZ2xvYmFsVGhpcy5uYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgZXZlbnRzIHRvIGRldGVjdCBwYWdlIGxlYXZlIHNjZW5hcmlvc1xuICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0gYXZvaWRCZkNhY2hlT3B0aW1pemF0aW9uIFdoZW4gYHRydWVgLCBmb3JjZWZ1bGx5IHN1YnNjcmliZXMgdG8gYmVmb3JldW5sb2FkIGV2ZW50LCBjb21wcm9taXNpbmcgb24gdGhlIGJmY2FjaGUgb3B0aW1pemF0aW9uXG4gKi9jb25zdCBvblBhZ2VMZWF2ZT0oY2FsbGJhY2ssYXZvaWRCZkNhY2hlT3B0aW1pemF0aW9uPWZhbHNlKT0+ey8vIFRvIGVuc3VyZSB0aGUgY2FsbGJhY2sgaXMgb25seSBjYWxsZWQgb25jZSBldmVuIGlmIG1vcmUgdGhhbiBvbmUgZXZlbnRzXG4vLyBhcmUgZmlyZWQgYXQgb25jZS5cbmxldCBwYWdlTGVmdD1mYWxzZTtsZXQgaXNBY2Nlc3NpYmxlPWZhbHNlO2Z1bmN0aW9uIGhhbmRsZU9uTGVhdmUoKXtpZihwYWdlTGVmdCl7cmV0dXJuO31wYWdlTGVmdD10cnVlO2NhbGxiYWNrKGlzQWNjZXNzaWJsZSk7Ly8gUmVzZXQgcGFnZUxlZnQgb24gdGhlIG5leHQgdGlja1xuLy8gdG8gZW5zdXJlIGNhbGxiYWNrIGV4ZWN1dGVzIGZvciBvdGhlciBsaXN0ZW5lcnNcbi8vIHdoZW4gY2xvc2luZyBhbiBpbmFjdGl2ZSBicm93c2VyIHRhYi5cbnNldFRpbWVvdXQoKCk9PntwYWdlTGVmdD1mYWxzZTt9LDApO30vLyBDYXRjaGVzIHRoZSB1bmxvYWRpbmcgb2YgdGhlIHBhZ2UgKGUuZy4sIGNsb3NpbmcgdGhlIHRhYiBvciBuYXZpZ2F0aW5nIGF3YXkpLlxuLy8gSW5jbHVkZXMgdXNlciBhY3Rpb25zIGxpa2UgY2xpY2tpbmcgYSBsaW5rLCBlbnRlcmluZyBhIG5ldyBVUkwsXG4vLyByZWZyZXNoaW5nIHRoZSBwYWdlLCBvciBjbG9zaW5nIHRoZSBicm93c2VyIHRhYlxuLy8gTm90ZSB0aGF0ICdwYWdlaGlkZScgaXMgbm90IHN1cHBvcnRlZCBpbiBJRS5cbi8vIFJlZ2lzdGVyaW5nIHRoaXMgZXZlbnQgY29uZGl0aW9uYWxseSBmb3IgSUUxMSBhbHNvIGJlY2F1c2Vcbi8vIGl0IGFmZmVjdHMgYmZjYWNoZSBvcHRpbWl6YXRpb24gb24gbW9kZXJuIGJyb3dzZXJzIG90aGVyd2lzZS5cbi8vIEhvd2V2ZXIsIGlmIG9wdGltaXphdGlvbiBpcyBkaXNhYmxlZCwgZm9yY2Ugc3Vic2NyaWJlIHRoZSBldmVudFxuaWYoYXZvaWRCZkNhY2hlT3B0aW1pemF0aW9ufHxpc0lFMTEoKSl7Z2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCgpPT57aXNBY2Nlc3NpYmxlPWZhbHNlO2hhbmRsZU9uTGVhdmUoKTt9KTt9Ly8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIGlPUyBTYWZhcmkgYnJvd3NlciBhcyBpdCBkb2VzIG5vdFxuLy8gZmlyZSB0aGUgcmVndWxhciBwYWdlaGlkZSBhbmQgdmlzaWJpbGl0eWNoYW5nZSBldmVudHNcbi8vIHdoZW4gdXNlciBnb2VzIHRvIHRhYmxpc3QgdmlldyBhbmQgY2xvc2VzIHRoZSB0YWIuXG5nbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCgpPT57aXNBY2Nlc3NpYmxlPXRydWU7aGFuZGxlT25MZWF2ZSgpO30pO2dsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCgpPT57cGFnZUxlZnQ9ZmFsc2U7fSk7Ly8gQ2F0Y2hlcyB0aGUgcGFnZSBiZWluZyBoaWRkZW4sIGluY2x1ZGluZyBzY2VuYXJpb3MgbGlrZSBjbG9zaW5nIHRoZSB0YWIuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsKCk9Pntpc0FjY2Vzc2libGU9ZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlPT09J2hpZGRlbic7aGFuZGxlT25MZWF2ZSgpO30pOy8vIENhdGNoZXMgdmlzaWJpbGl0eSBjaGFuZ2VzLCBzdWNoIGFzIHN3aXRjaGluZyB0YWJzIG9yIG1pbmltaXppbmcgdGhlIGJyb3dzZXIuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywoKT0+e2lzQWNjZXNzaWJsZT10cnVlO2lmKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZT09PSdoaWRkZW4nKXtoYW5kbGVPbkxlYXZlKCk7fWVsc2Uge3BhZ2VMZWZ0PWZhbHNlO319KTt9O1xuXG5jb25zdCBnZXRGb3JtYXR0ZWRUaW1lc3RhbXA9ZGF0ZT0+ZGF0ZS50b0lTT1N0cmluZygpOy8qKlxuICogVG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBpbiBJU08gc3RyaW5nIGZvcm1hdFxuICogQHJldHVybnMgSVNPIGZvcm1hdHRlZCB0aW1lc3RhbXAgc3RyaW5nXG4gKi9jb25zdCBnZXRDdXJyZW50VGltZUZvcm1hdHRlZD0oKT0+Z2V0Rm9ybWF0dGVkVGltZXN0YW1wKG5ldyBEYXRlKCkpO1xuXG5jb25zdCBMT0dfQ09OVEVYVF9TRVBBUkFUT1I9Jzo6ICc7Y29uc3QgU0NSSVBUX0FMUkVBRFlfRVhJU1RTX0VSUk9SPWlkPT5gQSBzY3JpcHQgd2l0aCB0aGUgaWQgXCIke2lkfVwiIGlzIGFscmVhZHkgbG9hZGVkLiBTa2lwcGluZyB0aGUgbG9hZGluZyBvZiB0aGlzIHNjcmlwdCB0byBwcmV2ZW50IGNvbmZsaWN0c2A7Y29uc3QgU0NSSVBUX0xPQURfRVJST1I9KGlkLHVybCxldik9PmBVbmFibGUgdG8gbG9hZCAoJHtpc1N0cmluZyhldik/ZXY6ZXYudHlwZX0pIHRoZSBzY3JpcHQgd2l0aCB0aGUgaWQgXCIke2lkfVwiIGZyb20gVVJMIFwiJHt1cmx9XCJgO2NvbnN0IFNDUklQVF9MT0FEX1RJTUVPVVRfRVJST1I9KGlkLHVybCx0aW1lb3V0KT0+YEEgdGltZW91dCBvZiAke3RpbWVvdXR9IG1zIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb2FkIHRoZSBzY3JpcHQgd2l0aCBpZCBcIiR7aWR9XCIgZnJvbSBVUkwgXCIke3VybH1cImA7Y29uc3QgQ0lSQ1VMQVJfUkVGRVJFTkNFX1dBUk5JTkc9KGNvbnRleHQsa2V5KT0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1BIGNpcmN1bGFyIHJlZmVyZW5jZSBoYXMgYmVlbiBkZXRlY3RlZCBpbiB0aGUgb2JqZWN0IGFuZCB0aGUgcHJvcGVydHkgXCIke2tleX1cIiBoYXMgYmVlbiBkcm9wcGVkIGZyb20gdGhlIG91dHB1dC5gO2NvbnN0IEpTT05fU1RSSU5HSUZZX1dBUk5JTkc9YEZhaWxlZCB0byBjb252ZXJ0IHRoZSB2YWx1ZSB0byBhIEpTT04gc3RyaW5nLmA7Y29uc3QgQ09PS0lFX0RBVEFfRU5DT0RJTkdfRVJST1I9YEZhaWxlZCB0byBlbmNvZGUgdGhlIGNvb2tpZSBkYXRhLmA7Y29uc3QgU1RPUkFHRV9VTkFWQUlMQUJJTElUWV9FUlJPUl9QUkVGSVg9KGNvbnRleHQsc3RvcmFnZVR5cGUpPT5gJHtjb250ZXh0fSR7TE9HX0NPTlRFWFRfU0VQQVJBVE9SfVRoZSBcIiR7c3RvcmFnZVR5cGV9XCIgc3RvcmFnZSB0eXBlIGlzIGA7XG5cbmNvbnN0IEpTT05fU1RSSU5HSUZZPSdKU09OU3RyaW5naWZ5Jztjb25zdCBCSUdfSU5UX1BMQUNFSE9MREVSPSdbQmlnSW50XSc7Y29uc3QgQ0lSQ1VMQVJfUkVGRVJFTkNFX1BMQUNFSE9MREVSPSdbQ2lyY3VsYXIgUmVmZXJlbmNlXSc7Y29uc3QgZ2V0Q2lyY3VsYXJSZXBsYWNlcj0oZXhjbHVkZU51bGwsZXhjbHVkZUtleXMsbG9nZ2VyKT0+e2NvbnN0IGFuY2VzdG9ycz1bXTsvLyBIZXJlIHdlIGRvIG5vdCB3YW50IHRvIHVzZSBhcnJvdyBmdW5jdGlvbiB0byB1c2UgXCJ0aGlzXCIgaW4gZnVuY3Rpb24gY29udGV4dFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbnJldHVybiBmdW5jdGlvbihrZXksdmFsdWUpe2lmKGV4Y2x1ZGVLZXlzPy5pbmNsdWRlcyhrZXkpKXtyZXR1cm4gdW5kZWZpbmVkO31pZihleGNsdWRlTnVsbCYmaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpKXtyZXR1cm4gdW5kZWZpbmVkO31pZih0eXBlb2YgdmFsdWUhPT0nb2JqZWN0J3x8aXNOdWxsKHZhbHVlKSl7cmV0dXJuIHZhbHVlO30vLyBgdGhpc2AgaXMgdGhlIG9iamVjdCB0aGF0IHZhbHVlIGlzIGNvbnRhaW5lZCBpbiwgaS5lLiwgaXRzIGRpcmVjdCBwYXJlbnQuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlLW5leHQtbGluZVxud2hpbGUoYW5jZXN0b3JzLmxlbmd0aD4wJiZhbmNlc3RvcnNbYW5jZXN0b3JzLmxlbmd0aC0xXSE9PXRoaXMpe2FuY2VzdG9ycy5wb3AoKTt9aWYoYW5jZXN0b3JzLmluY2x1ZGVzKHZhbHVlKSl7bG9nZ2VyPy53YXJuKENJUkNVTEFSX1JFRkVSRU5DRV9XQVJOSU5HKEpTT05fU1RSSU5HSUZZLGtleSkpO3JldHVybiBDSVJDVUxBUl9SRUZFUkVOQ0VfUExBQ0VIT0xERVI7fWFuY2VzdG9ycy5wdXNoKHZhbHVlKTtyZXR1cm4gdmFsdWU7fTt9Oy8qKlxuICogVXRpbGl0eSBtZXRob2QgZm9yIEpTT04gc3RyaW5naWZ5IG9iamVjdCBleGNsdWRpbmcgbnVsbCB2YWx1ZXMgJiBjaXJjdWxhciByZWZlcmVuY2VzXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBpbnB1dFxuICogQHBhcmFtIHtib29sZWFufSBleGNsdWRlTnVsbCBpZiBpdCBzaG91bGQgZXhjbHVkZSBudWwgb3Igbm90XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsb2dnZXIgb3B0aW9uYWwgbG9nZ2VyIG1ldGhvZHMgZm9yIHdhcm5pbmdcbiAqIEByZXR1cm5zIHN0cmluZ1xuICovY29uc3Qgc3RyaW5naWZ5V2l0aG91dENpcmN1bGFyPSh2YWx1ZSxleGNsdWRlTnVsbCxleGNsdWRlS2V5cyxsb2dnZXIpPT57dHJ5e3JldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSxnZXRDaXJjdWxhclJlcGxhY2VyKGV4Y2x1ZGVOdWxsLGV4Y2x1ZGVLZXlzLGxvZ2dlcikpO31jYXRjaChlcnIpe2xvZ2dlcj8ud2FybihKU09OX1NUUklOR0lGWV9XQVJOSU5HLGVycik7cmV0dXJuIG51bGw7fX07Y29uc3QgZ2V0UmVwbGFjZXI9bG9nZ2VyPT57Y29uc3QgYW5jZXN0b3JzPVtdOy8vIEFycmF5IHRvIHRyYWNrIGFuY2VzdG9yIG9iamVjdHNcbi8vIFVzaW5nIGEgcmVndWxhciBmdW5jdGlvbiB0byB1c2UgYHRoaXNgIGZvciB0aGUgcGFyZW50IGNvbnRleHRcbnJldHVybiBmdW5jdGlvbiByZXBsYWNlcihrZXksdmFsdWUpe2lmKGlzQmlnSW50KHZhbHVlKSl7cmV0dXJuIEJJR19JTlRfUExBQ0VIT0xERVI7Ly8gUmVwbGFjZSBCaWdJbnQgdmFsdWVzXG59Ly8gYHRoaXNgIGlzIHRoZSBvYmplY3QgdGhhdCB2YWx1ZSBpcyBjb250YWluZWQgaW4sIGkuZS4sIGl0cyBkaXJlY3QgcGFyZW50LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuLy8gQHRzLWlnbm9yZS1uZXh0LWxpbmVcbndoaWxlKGFuY2VzdG9ycy5sZW5ndGg+MCYmYW5jZXN0b3JzW2FuY2VzdG9ycy5sZW5ndGgtMV0hPT10aGlzKXthbmNlc3RvcnMucG9wKCk7Ly8gUmVtb3ZlIGFuY2VzdG9ycyB0aGF0IGFyZSBubyBsb25nZXIgcGFydCBvZiB0aGUgY2hhaW5cbn0vLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyAoaWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgaW4gdGhlIGFuY2VzdG9ycylcbmlmKGFuY2VzdG9ycy5pbmNsdWRlcyh2YWx1ZSkpe3JldHVybiBDSVJDVUxBUl9SRUZFUkVOQ0VfUExBQ0VIT0xERVI7fS8vIEFkZCBjdXJyZW50IHZhbHVlIHRvIGFuY2VzdG9yc1xuYW5jZXN0b3JzLnB1c2godmFsdWUpO3JldHVybiB2YWx1ZTt9O307Y29uc3QgdHJhdmVyc2VXaXRoVGhpcz0ob2JqLHJlcGxhY2VyKT0+ey8vIENyZWF0ZSBhIG5ldyByZXN1bHQgb2JqZWN0IG9yIGFycmF5XG5jb25zdCByZXN1bHQ9QXJyYXkuaXNBcnJheShvYmopP1tdOnt9Oy8vIFRyYXZlcnNlIG9iamVjdCBwcm9wZXJ0aWVzIG9yIGFycmF5IGVsZW1lbnRzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbmZvcihjb25zdCBrZXkgaW4gb2JqKXtpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmosa2V5KSl7Y29uc3QgdmFsdWU9b2JqW2tleV07Ly8gUmVjdXJzaXZlbHkgYXBwbHkgdGhlIHJlcGxhY2VyIGFuZCB0cmF2ZXJzYWxcbmNvbnN0IHNhbml0aXplZFZhbHVlPXJlcGxhY2VyLmNhbGwob2JqLGtleSx2YWx1ZSk7Ly8gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCBvciBhcnJheSwgY29udGludWUgdHJhdmVyc2FsXG5pZihpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKHNhbml0aXplZFZhbHVlKXx8QXJyYXkuaXNBcnJheShzYW5pdGl6ZWRWYWx1ZSkpe3Jlc3VsdFtrZXldPXRyYXZlcnNlV2l0aFRoaXMoc2FuaXRpemVkVmFsdWUscmVwbGFjZXIpO31lbHNlIHtyZXN1bHRba2V5XT1zYW5pdGl6ZWRWYWx1ZTt9fX1yZXR1cm4gcmVzdWx0O307LyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYW4gb2JqZWN0IHNpbWlsYXIgdG8gSlNPTi5zdHJpbmdpZnksXG4gKiBzYW5pdGl6aW5nIEJpZ0ludHMgYW5kIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAqIEBwYXJhbSB2YWx1ZSBJbnB1dCBvYmplY3RcbiAqIEBwYXJhbSBsb2dnZXIgTG9nZ2VyIGluc3RhbmNlXG4gKiBAcmV0dXJucyBTYW5pdGl6ZWQgdmFsdWVcbiAqL2NvbnN0IGdldFNhbml0aXplZFZhbHVlPSh2YWx1ZSxsb2dnZXIpPT57Y29uc3QgcmVwbGFjZXI9Z2V0UmVwbGFjZXIoKTsvLyBUaGlzIGlzIG5lZWRlZCBmb3IgcmVnaXN0ZXJpbmcgdGhlIGZpcnN0IGFuY2VzdG9yXG5jb25zdCBuZXdWYWx1ZT1yZXBsYWNlci5jYWxsKHZhbHVlLCcnLHZhbHVlKTtpZihpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKHZhbHVlKXx8QXJyYXkuaXNBcnJheSh2YWx1ZSkpe3JldHVybiB0cmF2ZXJzZVdpdGhUaGlzKHZhbHVlLHJlcGxhY2VyKTt9cmV0dXJuIG5ld1ZhbHVlO307XG5cbmNvbnN0IE1BTlVBTF9FUlJPUl9JREVOVElGSUVSPSdbU0RLIERJU1BBVENIRUQgRVJST1JdJztjb25zdCBnZXRTdGFja3RyYWNlPWVycj0+e2NvbnN0e3N0YWNrLHN0YWNrdHJhY2UsJ29wZXJhI3NvdXJjZWxvYyc6b3BlcmFTb3VyY2Vsb2N9PWVycjtjb25zdCBzdGFja1N0cmluZz1zdGFjaz8/c3RhY2t0cmFjZT8/b3BlcmFTb3VyY2Vsb2M7aWYoISFzdGFja1N0cmluZyYmdHlwZW9mIHN0YWNrU3RyaW5nPT09J3N0cmluZycpe3JldHVybiBzdGFja1N0cmluZzt9cmV0dXJuIHVuZGVmaW5lZDt9Oy8qKlxuICogR2V0IG11dGF0ZWQgZXJyb3Igd2l0aCBpc3N1ZSBwcmVwZW5kZWQgdG8gZXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIGVyciBPcmlnaW5hbCBlcnJvclxuICogQHBhcmFtIGlzc3VlIElzc3VlIHRvIHByZXBlbmQgdG8gZXJyb3IgbWVzc2FnZVxuICogQHJldHVybnMgSW5zdGFuY2Ugb2YgRXJyb3Igd2l0aCBtZXNzYWdlIHByZXBlbmRlZCB3aXRoIGlzc3VlXG4gKi9jb25zdCBnZXRNdXRhdGVkRXJyb3I9KGVycixpc3N1ZSk9PntpZighaXNUeXBlT2ZFcnJvcihlcnIpKXtyZXR1cm4gbmV3IEVycm9yKGAke2lzc3VlfTogJHtzdHJpbmdpZnlXaXRob3V0Q2lyY3VsYXIoZXJyKX1gKTt9dHJ5ey8vIFByZXNlcnZlIHRoZSBzcGVjaWZpYyBlcnJvciB0eXBlIChUeXBlRXJyb3IsIFJlZmVyZW5jZUVycm9yLCBldGMuKVxuY29uc3QgRXJyb3JDb25zdHJ1Y3Rvcj1lcnIuY29uc3RydWN0b3I7Y29uc3QgbmV3RXJyb3I9bmV3IEVycm9yQ29uc3RydWN0b3IoYCR7aXNzdWV9OiAke2Vyci5tZXNzYWdlfWApOy8vIFByZXNlcnZlIHN0YWNrIHRyYWNlXG5jb25zdCBzdGFjaz1nZXRTdGFja3RyYWNlKGVycik7aWYoc3RhY2spe25ld0Vycm9yLnN0YWNrPXN0YWNrO30vLyBQcmVzZXJ2ZSBhbnkgb3RoZXIgZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIpLmZvckVhY2goa2V5PT57aWYoa2V5IT09J21lc3NhZ2UnJiZrZXkhPT0nc3RhY2snJiZrZXkhPT0nbmFtZScpe3RyeXtuZXdFcnJvcltrZXldPWVycltrZXldO31jYXRjaHsvLyBJZ25vcmUgaWYgcHJvcGVydHkgaXMgbm90IHdyaXRhYmxlXG59fX0pO3JldHVybiBuZXdFcnJvcjt9Y2F0Y2h7cmV0dXJuIG5ldyBFcnJvcihgJHtpc3N1ZX06ICR7c3RyaW5naWZ5V2l0aG91dENpcmN1bGFyKGVycil9YCk7fX07Y29uc3QgZGlzcGF0Y2hFcnJvckV2ZW50PWVycm9yPT57aWYoaXNUeXBlT2ZFcnJvcihlcnJvcikpe2NvbnN0IGVyclN0YWNrPWdldFN0YWNrdHJhY2UoZXJyb3IpO2lmKGVyclN0YWNrKXtjb25zdHtzdGFjayxzdGFja3RyYWNlLCdvcGVyYSNzb3VyY2Vsb2MnOm9wZXJhU291cmNlbG9jfT1lcnJvcjtzd2l0Y2goZXJyU3RhY2spe2Nhc2Ugc3RhY2s6Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5lcnJvci5zdGFjaz1gJHtzdGFja31cXG4ke01BTlVBTF9FUlJPUl9JREVOVElGSUVSfWA7YnJlYWs7Y2FzZSBzdGFja3RyYWNlOi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuZXJyb3Iuc3RhY2t0cmFjZT1gJHtzdGFja3RyYWNlfVxcbiR7TUFOVUFMX0VSUk9SX0lERU5USUZJRVJ9YDticmVhaztjYXNlIG9wZXJhU291cmNlbG9jOmRlZmF1bHQ6Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5lcnJvclsnb3BlcmEjc291cmNlbG9jJ109YCR7b3BlcmFTb3VyY2Vsb2N9XFxuJHtNQU5VQUxfRVJST1JfSURFTlRJRklFUn1gO2JyZWFrO319fWdsb2JhbFRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXJyb3JFdmVudCgnZXJyb3InLHtlcnJvcixidWJibGVzOnRydWUsY2FuY2VsYWJsZTp0cnVlLGNvbXBvc2VkOnRydWV9KSk7fTtcblxuY29uc3QgQVBQX05BTUU9J1J1ZGRlckxhYnMgSmF2YVNjcmlwdCBTREsnO2NvbnN0IEFQUF9WRVJTSU9OPSczLjI3LjAnO2NvbnN0IEFQUF9OQU1FU1BBQ0U9J2NvbS5ydWRkZXJsYWJzLmphdmFzY3JpcHQnO2NvbnN0IE1PRFVMRV9UWVBFPSducG0nO2NvbnN0IEFEQkxPQ0tfUEFHRV9DQVRFR09SWT0nUnVkZGVySlMtSW5pdGlhdGVkJztjb25zdCBBREJMT0NLX1BBR0VfTkFNRT0nYWQtYmxvY2sgcGFnZSByZXF1ZXN0Jztjb25zdCBBREJMT0NLX1BBR0VfUEFUSD0nL2FkLWJsb2NrZWQnO2NvbnN0IEdMT0JBTF9QUkVMT0FEX0JVRkZFUj0ncHJlbG9hZGVkRXZlbnRzQnVmZmVyJztjb25zdCBDT05TRU5UX1RSQUNLX0VWRU5UX05BTUU9J0NvbnNlbnQgTWFuYWdlbWVudCBJbnRlcmFjdGlvbic7XG5cbmNvbnN0IFFVRVJZX1BBUkFNX1RSQUlUX1BSRUZJWD0nYWpzX3RyYWl0Xyc7Y29uc3QgUVVFUllfUEFSQU1fUFJPUEVSVFlfUFJFRklYPSdhanNfcHJvcF8nO2NvbnN0IFFVRVJZX1BBUkFNX0FOT05ZTU9VU19JRF9LRVk9J2Fqc19haWQnO2NvbnN0IFFVRVJZX1BBUkFNX1VTRVJfSURfS0VZPSdhanNfdWlkJztjb25zdCBRVUVSWV9QQVJBTV9UUkFDS19FVkVOVF9OQU1FX0tFWT0nYWpzX2V2ZW50JztcblxuY29uc3QgREVGQVVMVF9YSFJfVElNRU9VVF9NUz0xMCoxMDAwOy8vIDEwIHNlY29uZHNcbmNvbnN0IERFRkFVTFRfQ09PS0lFX01BWF9BR0VfTVM9MzE1MzYwMDAqMTAwMDsvLyAxIHllYXJcbmNvbnN0IERFRkFVTFRfU0VTU0lPTl9DVVRfT0ZGX0RVUkFUSU9OX01TPTEyKjYwKjYwKjEwMDA7Ly8gMTIgaG91cnNcbmNvbnN0IERFRkFVTFRfU0VTU0lPTl9USU1FT1VUX01TPTMwKjYwKjEwMDA7Ly8gMzAgbWludXRlc1xuY29uc3QgTUlOX1NFU1NJT05fVElNRU9VVF9NUz0xMCoxMDAwOy8vIDEwIHNlY29uZHNcbmNvbnN0IERFRkFVTFRfREFUQV9QTEFORV9FVkVOVFNfQlVGRkVSX1RJTUVPVVRfTVM9MTAqMTAwMDsvLyAxMCBzZWNvbmRzXG5jb25zdCBERUJPVU5DRURfVElNRU9VVF9NUz0yNTA7Ly8gMjUwIG1pbGxpc2Vjb25kc1xuXG4vKipcbiAqIENyZWF0ZSBnbG9iYWxseSBhY2Nlc3NpYmxlIFJ1ZGRlclN0YWNrR2xvYmFscyBvYmplY3RcbiAqL2NvbnN0IGNyZWF0ZUV4cG9zZWRHbG9iYWxzPShhbmFseXRpY3NJbnN0YW5jZUlkPSdhcHAnKT0+e2lmKCFnbG9iYWxUaGlzLlJ1ZGRlclN0YWNrR2xvYmFscyl7Z2xvYmFsVGhpcy5SdWRkZXJTdGFja0dsb2JhbHM9e307fWlmKCFnbG9iYWxUaGlzLlJ1ZGRlclN0YWNrR2xvYmFsc1thbmFseXRpY3NJbnN0YW5jZUlkXSl7Z2xvYmFsVGhpcy5SdWRkZXJTdGFja0dsb2JhbHNbYW5hbHl0aWNzSW5zdGFuY2VJZF09e307fX07LyoqXG4gKiBBZGQgbW92ZSB2YWx1ZXMgdG8gZ2xvYmFsbHkgYWNjZXNzaWJsZSBSdWRkZXJTdGFja0dsb2JhbHMgb2JqZWN0IHBlciBhbmFseXRpY3MgaW5zdGFuY2VcbiAqL2NvbnN0IHNldEV4cG9zZWRHbG9iYWw9KGtleU5hbWUsdmFsdWUsYW5hbHl0aWNzSW5zdGFuY2VJZD0nYXBwJyk9PntjcmVhdGVFeHBvc2VkR2xvYmFscyhhbmFseXRpY3NJbnN0YW5jZUlkKTtnbG9iYWxUaGlzLlJ1ZGRlclN0YWNrR2xvYmFsc1thbmFseXRpY3NJbnN0YW5jZUlkXVtrZXlOYW1lXT12YWx1ZTt9Oy8qKlxuICogR2V0IHZhbHVlcyBmcm9tIGdsb2JhbGx5IGFjY2Vzc2libGUgUnVkZGVyU3RhY2tHbG9iYWxzIG9iamVjdCBieSBhbmFseXRpY3MgaW5zdGFuY2VcbiAqL2NvbnN0IGdldEV4cG9zZWRHbG9iYWw9KGtleU5hbWUsYW5hbHl0aWNzSW5zdGFuY2VJZD0nYXBwJyk9PntjcmVhdGVFeHBvc2VkR2xvYmFscyhhbmFseXRpY3NJbnN0YW5jZUlkKTtyZXR1cm4gZ2xvYmFsVGhpcy5SdWRkZXJTdGFja0dsb2JhbHNbYW5hbHl0aWNzSW5zdGFuY2VJZF1ba2V5TmFtZV07fTtmdW5jdGlvbiBkZWJvdW5jZShmdW5jLHRoaXNBcmcsZGVsYXk9REVCT1VOQ0VEX1RJTUVPVVRfTVMpe2xldCB0aW1lb3V0SWQ7cmV0dXJuICguLi5hcmdzKT0+e2dsb2JhbFRoaXMuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7dGltZW91dElkPWdsb2JhbFRoaXMuc2V0VGltZW91dCgoKT0+e2Z1bmMuYXBwbHkodGhpc0FyZyxhcmdzKTt9LGRlbGF5KTt9O31cblxuLyoqXG4gKiBQYXJzZSBxdWVyeSBzdHJpbmcgcGFyYW1zIGludG8gb2JqZWN0IHZhbHVlcyBmb3Iga2V5cyB0aGF0IHN0YXJ0IHdpdGggYSBkZWZpbmVkIHByZWZpeFxuICovY29uc3QgZ2V0RXZlbnREYXRhRnJvbVF1ZXJ5U3RyaW5nPShwYXJhbXMsZGF0YVR5cGVOYW1lUHJlZml4KT0+e2NvbnN0IGRhdGE9e307cGFyYW1zLmZvckVhY2goKHZhbHVlLGtleSk9PntpZihrZXkuc3RhcnRzV2l0aChkYXRhVHlwZU5hbWVQcmVmaXgpKXsvLyByZW1vdmUgcHJlZml4IGZyb20ga2V5IG5hbWVcbmNvbnN0IGRhdGFLZXk9a2V5LnN1YnN0cmluZyhkYXRhVHlwZU5hbWVQcmVmaXgubGVuZ3RoKTsvLyBhZGQgbmV3IGtleSB2YWx1ZSBwYWlyIGluIGdlbmVyYXRlZCBvYmplY3RcbmRhdGFbZGF0YUtleV09cGFyYW1zLmdldChrZXkpO319KTtyZXR1cm4gZGF0YTt9Oy8qKlxuICogUGFyc2UgcXVlcnkgc3RyaW5nIGludG8gcHJlbG9hZCBidWZmZXIgZXZlbnRzICYgcHVzaCBpbnRvIGV4aXN0aW5nIGFycmF5IGJlZm9yZSBhbnkgb3RoZXIgZXZlbnRzXG4gKi9jb25zdCByZXRyaWV2ZUV2ZW50c0Zyb21RdWVyeVN0cmluZz0oYXJndW1lbnRzQXJyYXk9W10pPT57Ly8gTWFwcGluZyBmb3IgdHJhaXQgYW5kIHByb3BlcnRpZXMgdmFsdWVzIGJhc2VkIG9uIGtleSBwcmVmaXhcbmNvbnN0IGV2ZW50QXJndW1lbnRUb1F1ZXJ5UGFyYW1NYXA9e3RyYWl0OlFVRVJZX1BBUkFNX1RSQUlUX1BSRUZJWCxwcm9wZXJ0aWVzOlFVRVJZX1BBUkFNX1BST1BFUlRZX1BSRUZJWH07Y29uc3QgcXVlcnlPYmplY3Q9bmV3IFVSTFNlYXJjaFBhcmFtcyhnbG9iYWxUaGlzLmxvY2F0aW9uLnNlYXJjaCk7Ly8gQWRkIHRyYWNrIGV2ZW50cyB3aXRoIG5hbWUgYW5kIHByb3BlcnRpZXNcbmlmKHF1ZXJ5T2JqZWN0LmdldChRVUVSWV9QQVJBTV9UUkFDS19FVkVOVF9OQU1FX0tFWSkpe2FyZ3VtZW50c0FycmF5LnVuc2hpZnQoWyd0cmFjaycscXVlcnlPYmplY3QuZ2V0KFFVRVJZX1BBUkFNX1RSQUNLX0VWRU5UX05BTUVfS0VZKSxnZXRFdmVudERhdGFGcm9tUXVlcnlTdHJpbmcocXVlcnlPYmplY3QsZXZlbnRBcmd1bWVudFRvUXVlcnlQYXJhbU1hcC5wcm9wZXJ0aWVzKV0pO30vLyBTZW5kIGlkZW50aWZ5IGV2ZW50XG5jb25zdCB1c2VySWQ9cXVlcnlPYmplY3QuZ2V0KFFVRVJZX1BBUkFNX1VTRVJfSURfS0VZKTtjb25zdCB1c2VyVHJhaXRzPWdldEV2ZW50RGF0YUZyb21RdWVyeVN0cmluZyhxdWVyeU9iamVjdCxldmVudEFyZ3VtZW50VG9RdWVyeVBhcmFtTWFwLnRyYWl0KTtpZih1c2VySWR8fGlzTm9uRW1wdHlPYmplY3QodXNlclRyYWl0cykpey8vIEluIGlkZW50aWZ5IEFQSSwgdXNlciBJRCBpcyBvcHRpb25hbFxuY29uc3QgaWRlbnRpZnlBcGlBcmdzPVsuLi4odXNlcklkP1t1c2VySWRdOltdKSx1c2VyVHJhaXRzXTthcmd1bWVudHNBcnJheS51bnNoaWZ0KFsnaWRlbnRpZnknLC4uLmlkZW50aWZ5QXBpQXJnc10pO30vLyBTZXQgYW5vbnltb3VzSURcbmlmKHF1ZXJ5T2JqZWN0LmdldChRVUVSWV9QQVJBTV9BTk9OWU1PVVNfSURfS0VZKSl7YXJndW1lbnRzQXJyYXkudW5zaGlmdChbJ3NldEFub255bW91c0lkJyxxdWVyeU9iamVjdC5nZXQoUVVFUllfUEFSQU1fQU5PTllNT1VTX0lEX0tFWSldKTt9fTsvKipcbiAqIFJldHJpZXZlIGFuIGV4aXN0aW5nIGJ1ZmZlcmVkIGxvYWQgbWV0aG9kIGNhbGwgYW5kIHJlbW92ZSBmcm9tIHRoZSBleGlzdGluZyBhcnJheVxuICovY29uc3QgZ2V0UHJlbG9hZGVkTG9hZEV2ZW50PXByZWxvYWRlZEV2ZW50c0FycmF5PT57Y29uc3QgbG9hZE1ldGhvZE5hbWU9J2xvYWQnO2xldCBsb2FkRXZlbnQ9W107LyoqXG4gICAqIEl0ZXJhdGUgdGhlIGJ1ZmZlcmVkIEFQSSBjYWxscyB1bnRpbCB3ZSBmaW5kIGxvYWQgY2FsbCBhbmQgcHJvY2VzcyBpdCBzZXBhcmF0ZWx5XG4gICAqL2xldCBpPTA7d2hpbGUoaTxwcmVsb2FkZWRFdmVudHNBcnJheS5sZW5ndGgpe2lmKHByZWxvYWRlZEV2ZW50c0FycmF5W2ldJiZwcmVsb2FkZWRFdmVudHNBcnJheVtpXVswXT09PWxvYWRNZXRob2ROYW1lKXtsb2FkRXZlbnQ9Y2xvbmUocHJlbG9hZGVkRXZlbnRzQXJyYXlbaV0pO3ByZWxvYWRlZEV2ZW50c0FycmF5LnNwbGljZShpLDEpO2JyZWFrO31pKz0xO31yZXR1cm4gbG9hZEV2ZW50O307LyoqXG4gKiBQcm9tb3RlIGNvbnNlbnQgZXZlbnRzIHRvIHRoZSB0b3Agb2YgdGhlIHByZWxvYWRlZCBldmVudHMgYXJyYXlcbiAqIEBwYXJhbSBwcmVsb2FkZWRFdmVudHNBcnJheSBQcmVsb2FkZWQgZXZlbnRzIGFycmF5XG4gKiBAcmV0dXJucyBOb25lXG4gKi9jb25zdCBwcm9tb3RlUHJlbG9hZGVkQ29uc2VudEV2ZW50c1RvVG9wPXByZWxvYWRlZEV2ZW50c0FycmF5PT57Y29uc3QgY29uc2VudE1ldGhvZE5hbWU9J2NvbnNlbnQnO2NvbnN0IGNvbnNlbnRFdmVudHM9cHJlbG9hZGVkRXZlbnRzQXJyYXkuZmlsdGVyKGJ1ZmZlcmVkRXZlbnQ9PmJ1ZmZlcmVkRXZlbnRbMF09PT1jb25zZW50TWV0aG9kTmFtZSk7Y29uc3Qgbm9uQ29uc2VudEV2ZW50cz1wcmVsb2FkZWRFdmVudHNBcnJheS5maWx0ZXIoYnVmZmVyZWRFdmVudD0+YnVmZmVyZWRFdmVudFswXSE9PWNvbnNlbnRNZXRob2ROYW1lKTsvLyBSZW1vdmUgYWxsIGVsZW1lbnRzIGFuZCBhZGQgY29uc2VudCBldmVudHMgZmlyc3QgZm9sbG93ZWQgYnkgbm9uIGNvbnNlbnQgZXZlbnRzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby11c2VsZXNzLXNwcmVhZFxucHJlbG9hZGVkRXZlbnRzQXJyYXkuc3BsaWNlKDAscHJlbG9hZGVkRXZlbnRzQXJyYXkubGVuZ3RoLC4uLmNvbnNlbnRFdmVudHMsLi4ubm9uQ29uc2VudEV2ZW50cyk7fTsvKipcbiAqIFJldHJpZXZlIGFueSBleGlzdGluZyBldmVudHMgdGhhdCB3ZXJlIHRyaWdnZXJlZCBiZWZvcmUgU0RLIGxvYWQgYW5kIGVucXVldWUgaW4gYnVmZmVyXG4gKi9jb25zdCByZXRyaWV2ZVByZWxvYWRCdWZmZXJFdmVudHM9aW5zdGFuY2U9Pntjb25zdCBwcmVsb2FkZWRFdmVudHNBcnJheT1nZXRFeHBvc2VkR2xvYmFsKEdMT0JBTF9QUkVMT0FEX0JVRkZFUil8fFtdOy8vIEdldCBldmVudHMgdGhhdCBhcmUgcHJlLXBvcHVsYXRlZCB2aWEgcXVlcnkgc3RyaW5nIHBhcmFtc1xucmV0cmlldmVFdmVudHNGcm9tUXVlcnlTdHJpbmcocHJlbG9hZGVkRXZlbnRzQXJyYXkpOy8vIEVucXVldWUgdGhlIG5vbiBsb2FkIGV2ZW50cyBpbiB0aGUgYnVmZmVyIG9mIHRoZSBnbG9iYWwgcnVkZGVyIGFuYWx5dGljcyBzaW5nbGV0b25cbmlmKHByZWxvYWRlZEV2ZW50c0FycmF5Lmxlbmd0aD4wKXtpbnN0YW5jZS5lbnF1ZXVlUHJlbG9hZEJ1ZmZlckV2ZW50cyhwcmVsb2FkZWRFdmVudHNBcnJheSk7c2V0RXhwb3NlZEdsb2JhbChHTE9CQUxfUFJFTE9BRF9CVUZGRVIsW10pO319O2NvbnN0IGNvbnN1bWVQcmVsb2FkQnVmZmVyZWRFdmVudD0oZXZlbnQsYW5hbHl0aWNzSW5zdGFuY2UpPT57Y29uc3QgbWV0aG9kTmFtZT1ldmVudC5zaGlmdCgpO2xldCBjYWxsT3B0aW9ucztpZihpc0Z1bmN0aW9uKGFuYWx5dGljc0luc3RhbmNlW21ldGhvZE5hbWVdKSl7c3dpdGNoKG1ldGhvZE5hbWUpe2Nhc2UgJ3BhZ2UnOmNhbGxPcHRpb25zPXBhZ2VBcmd1bWVudHNUb0NhbGxPcHRpb25zKC4uLmV2ZW50KTticmVhaztjYXNlICd0cmFjayc6Y2FsbE9wdGlvbnM9dHJhY2tBcmd1bWVudHNUb0NhbGxPcHRpb25zKC4uLmV2ZW50KTticmVhaztjYXNlICdpZGVudGlmeSc6Y2FsbE9wdGlvbnM9aWRlbnRpZnlBcmd1bWVudHNUb0NhbGxPcHRpb25zKC4uLmV2ZW50KTticmVhaztjYXNlICdhbGlhcyc6Y2FsbE9wdGlvbnM9YWxpYXNBcmd1bWVudHNUb0NhbGxPcHRpb25zKC4uLmV2ZW50KTticmVhaztjYXNlICdncm91cCc6Y2FsbE9wdGlvbnM9Z3JvdXBBcmd1bWVudHNUb0NhbGxPcHRpb25zKC4uLmV2ZW50KTticmVhaztkZWZhdWx0OmFuYWx5dGljc0luc3RhbmNlW21ldGhvZE5hbWVdKC4uLmV2ZW50KTticmVhazt9aWYoY2FsbE9wdGlvbnMpe2FuYWx5dGljc0luc3RhbmNlW21ldGhvZE5hbWVdKGNhbGxPcHRpb25zKTt9fX07XG5cbmNvbnN0IERFRkFVTFRfRVhUX1NSQ19MT0FEX1RJTUVPVVRfTVM9MTAqMTAwMDsvLyAxMCBzZWNvbmRzXG5cbmNvbnN0IEVYVEVSTkFMX1NPVVJDRV9MT0FEX09SSUdJTj0nUlNfSlNfU0RLJztcblxuLyoqXG4gKiBDcmVhdGUgdGhlIERPTSBlbGVtZW50IHRvIGxvYWQgYSBzY3JpcHQgbWFya2VkIGFzIFJTIFNESyBvcmlnaW5hdGVkXG4gKlxuICogQHBhcmFtIHsqfSB1cmwgVGhlIFVSTCBvZiB0aGUgc2NyaXB0IHRvIGJlIGxvYWRlZFxuICogQHBhcmFtIHsqfSBpZCBJRCBmb3IgdGhlIHNjcmlwdCB0YWdcbiAqIEBwYXJhbSB7Kn0gYXN5bmMgV2hldGhlciB0byBsb2FkIHRoZSBzY3JpcHQgaW4gYXN5bmMgbW9kZS4gRGVmYXVsdHMgdG8gYHRydWVgIFtvcHRpb25hbF1cbiAqIEBwYXJhbSB7Kn0gb25sb2FkIGNhbGxiYWNrIHRvIGludm9rZSBvbmxvYWQgW29wdGlvbmFsXVxuICogQHBhcmFtIHsqfSBvbmVycm9yIGNhbGxiYWNrIHRvIGludm9rZSBvbmVycm9yIFtvcHRpb25hbF1cbiAqIEBwYXJhbSB7Kn0gZXh0cmFBdHRyaWJ1dGVzIGtleS92YWx1ZSBwYWlyIHdpdGggaHRtbCBhdHRyaWJ1dGVzIHRvIGFkZCBpbiBodG1sIHRhZyBbb3B0aW9uYWxdXG4gKlxuICogQHJldHVybnMgSFRNTFNjcmlwdEVsZW1lbnRcbiAqL2NvbnN0IGNyZWF0ZVNjcmlwdEVsZW1lbnQ9KHVybCxpZCxhc3luYz10cnVlLG9ubG9hZD1udWxsLG9uZXJyb3I9bnVsbCxleHRyYUF0dHJpYnV0ZXM9e30pPT57Y29uc3Qgc2NyaXB0RWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtzY3JpcHRFbGVtZW50LnR5cGU9J3RleHQvamF2YXNjcmlwdCc7c2NyaXB0RWxlbWVudC5vbmxvYWQ9b25sb2FkO3NjcmlwdEVsZW1lbnQub25lcnJvcj1vbmVycm9yO3NjcmlwdEVsZW1lbnQuc3JjPXVybDtzY3JpcHRFbGVtZW50LmlkPWlkO3NjcmlwdEVsZW1lbnQuYXN5bmM9YXN5bmM7T2JqZWN0LmtleXMoZXh0cmFBdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHJpYnV0ZU5hbWU9PntzY3JpcHRFbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLGV4dHJhQXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7fSk7c2NyaXB0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbG9hZGVyJyxFWFRFUk5BTF9TT1VSQ0VfTE9BRF9PUklHSU4pO3JldHVybiBzY3JpcHRFbGVtZW50O307LyoqXG4gKiBBZGQgc2NyaXB0IERPTSBlbGVtZW50IHRvIERPTVxuICpcbiAqIEBwYXJhbSB7Kn0gbmV3U2NyaXB0RWxlbWVudCB0aGUgc2NyaXB0IGVsZW1lbnQgdG8gYWRkXG4gKlxuICogQHJldHVybnNcbiAqL2NvbnN0IGluc2VydFNjcmlwdD1uZXdTY3JpcHRFbGVtZW50PT57Ly8gRmlyc3QgdHJ5IHRvIGFkZCBpdCB0byB0aGUgaGVhZFxuY29uc3QgaGVhZEVsZW1lbnRzPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJyk7aWYoaGVhZEVsZW1lbnRzLmxlbmd0aD4wKXtoZWFkRWxlbWVudHNbMF0/Lmluc2VydEJlZm9yZShuZXdTY3JpcHRFbGVtZW50LGhlYWRFbGVtZW50c1swXT8uZmlyc3RDaGlsZCk7cmV0dXJuO30vLyBFbHNlIHdpc2UgYWRkIGl0IGJlZm9yZSB0aGUgZmlyc3Qgc2NyaXB0IHRhZ1xuY29uc3Qgc2NyaXB0RWxlbWVudHM9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO2lmKHNjcmlwdEVsZW1lbnRzLmxlbmd0aD4wJiZzY3JpcHRFbGVtZW50c1swXT8ucGFyZW50Tm9kZSl7c2NyaXB0RWxlbWVudHNbMF0/LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld1NjcmlwdEVsZW1lbnQsc2NyaXB0RWxlbWVudHNbMF0pO3JldHVybjt9Ly8gQ3JlYXRlIGEgbmV3IGhlYWQgZWxlbWVudCBhbmQgYWRkIHRoZSBzY3JpcHQgYXMgZmFsbGJhY2tcbmNvbnN0IGhlYWRFbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2hlYWQnKTtoZWFkRWxlbWVudC5hcHBlbmRDaGlsZChuZXdTY3JpcHRFbGVtZW50KTtjb25zdCBodG1sRWxlbWVudD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaHRtbCcpWzBdO2h0bWxFbGVtZW50Py5pbnNlcnRCZWZvcmUoaGVhZEVsZW1lbnQsaHRtbEVsZW1lbnQuZmlyc3RDaGlsZCk7fTsvKipcbiAqIExvYWRzIGV4dGVybmFsIGpzIGZpbGUgYXMgYSBzY3JpcHQgaHRtbCB0YWdcbiAqXG4gKiBAcGFyYW0geyp9IHVybCBUaGUgVVJMIG9mIHRoZSBzY3JpcHQgdG8gYmUgbG9hZGVkXG4gKiBAcGFyYW0geyp9IGlkIElEIGZvciB0aGUgc2NyaXB0IHRhZ1xuICogQHBhcmFtIHsqfSB0aW1lb3V0IGxvYWRpbmcgdGltZW91dFxuICogQHBhcmFtIHsqfSBhc3luYyBXaGV0aGVyIHRvIGxvYWQgdGhlIHNjcmlwdCBpbiBhc3luYyBtb2RlLiBEZWZhdWx0cyB0byBgdHJ1ZWAgW29wdGlvbmFsXVxuICogQHBhcmFtIHsqfSBleHRyYUF0dHJpYnV0ZXMga2V5L3ZhbHVlIHBhaXIgd2l0aCBodG1sIGF0dHJpYnV0ZXMgdG8gYWRkIGluIGh0bWwgdGFnIFtvcHRpb25hbF1cbiAqXG4gKiBAcmV0dXJuc1xuICovY29uc3QganNGaWxlTG9hZGVyPSh1cmwsaWQsdGltZW91dCxhc3luYz10cnVlLGV4dHJhQXR0cmlidXRlcyk9Pm5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9Pntjb25zdCBzY3JpcHRFeGlzdHM9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO2lmKHNjcmlwdEV4aXN0cyl7cmVqZWN0KG5ldyBFcnJvcihTQ1JJUFRfQUxSRUFEWV9FWElTVFNfRVJST1IoaWQpKSk7fXRyeXtsZXQgdGltZW91dElEO2NvbnN0IG9ubG9hZD0oKT0+e2dsb2JhbFRoaXMuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7cmVzb2x2ZShpZCk7fTtjb25zdCBvbmVycm9yPWV2PT57Z2xvYmFsVGhpcy5jbGVhclRpbWVvdXQodGltZW91dElEKTtyZWplY3QobmV3IEVycm9yKFNDUklQVF9MT0FEX0VSUk9SKGlkLHVybCxldikpKTt9Oy8vIENyZWF0ZSB0aGUgRE9NIGVsZW1lbnQgdG8gbG9hZCB0aGUgc2NyaXB0IGFuZCBhZGQgaXQgdG8gdGhlIERPTVxuaW5zZXJ0U2NyaXB0KGNyZWF0ZVNjcmlwdEVsZW1lbnQodXJsLGlkLGFzeW5jLG9ubG9hZCxvbmVycm9yLGV4dHJhQXR0cmlidXRlcykpOy8vIFJlamVjdCBvbiB0aW1lb3V0XG50aW1lb3V0SUQ9Z2xvYmFsVGhpcy5zZXRUaW1lb3V0KCgpPT57cmVqZWN0KG5ldyBFcnJvcihTQ1JJUFRfTE9BRF9USU1FT1VUX0VSUk9SKGlkLHVybCx0aW1lb3V0KSkpO30sdGltZW91dCk7fWNhdGNoKGVycil7cmVqZWN0KGdldE11dGF0ZWRFcnJvcihlcnIsU0NSSVBUX0xPQURfRVJST1IoaWQsdXJsLCd1bmtub3duJykpKTt9fSk7XG5cbi8qKlxuICogU2VydmljZSB0byBsb2FkIGV4dGVybmFsIHJlc291cmNlcy9maWxlc1xuICovY2xhc3MgRXh0ZXJuYWxTcmNMb2FkZXJ7Y29uc3RydWN0b3IobG9nZ2VyLHRpbWVvdXQ9REVGQVVMVF9FWFRfU1JDX0xPQURfVElNRU9VVF9NUyl7dGhpcy5sb2dnZXI9bG9nZ2VyO3RoaXMudGltZW91dD10aW1lb3V0O30vKipcbiAgICogTG9hZCBleHRlcm5hbCByZXNvdXJjZSBvZiB0eXBlIGphdmFzY3JpcHRcbiAgICovbG9hZEpTRmlsZShjb25maWcpe2NvbnN0e3VybCxpZCx0aW1lb3V0LGFzeW5jLGNhbGxiYWNrLGV4dHJhQXR0cmlidXRlc309Y29uZmlnO2NvbnN0IGlzRmlyZUFuZEZvcmdldD0haXNGdW5jdGlvbihjYWxsYmFjayk7anNGaWxlTG9hZGVyKHVybCxpZCx0aW1lb3V0fHx0aGlzLnRpbWVvdXQsYXN5bmMsZXh0cmFBdHRyaWJ1dGVzKS50aGVuKGlkPT57aWYoIWlzRmlyZUFuZEZvcmdldCl7Y2FsbGJhY2soaWQpO319KS5jYXRjaChlcnI9PntpZighaXNGaXJlQW5kRm9yZ2V0KXtjYWxsYmFjayhpZCxlcnIpO319KTt9fVxuXG52YXIgaT1TeW1ib2wuZm9yKFwicHJlYWN0LXNpZ25hbHNcIik7ZnVuY3Rpb24gdCgpe2lmKCEocz4xKSl7dmFyIGksdD1mYWxzZTt3aGlsZSh2b2lkIDAhPT1oKXt2YXIgcj1oO2g9dm9pZCAwO2YrKzt3aGlsZSh2b2lkIDAhPT1yKXt2YXIgbz1yLm87ci5vPXZvaWQgMDtyLmYmPS0zO2lmKCEoOCZyLmYpJiZjKHIpKXRyeXtyLmMoKTt9Y2F0Y2gocil7aWYoIXQpe2k9cjt0PXRydWU7fX1yPW87fX1mPTA7cy0tO2lmKHQpdGhyb3cgaTt9ZWxzZSBzLS07fWZ1bmN0aW9uIHIoaSl7aWYocz4wKXJldHVybiBpKCk7cysrO3RyeXtyZXR1cm4gaSgpO31maW5hbGx5e3QoKTt9fXZhciBvPXZvaWQgMDtmdW5jdGlvbiBuKGkpe3ZhciB0PW87bz12b2lkIDA7dHJ5e3JldHVybiBpKCk7fWZpbmFsbHl7bz10O319dmFyIGg9dm9pZCAwLHM9MCxmPTAsdj0wO2Z1bmN0aW9uIGUoaSl7aWYodm9pZCAwIT09byl7dmFyIHQ9aS5uO2lmKHZvaWQgMD09PXR8fHQudCE9PW8pe3Q9e2k6MCxTOmkscDpvLnMsbjp2b2lkIDAsdDpvLGU6dm9pZCAwLHg6dm9pZCAwLHI6dH07aWYodm9pZCAwIT09by5zKW8ucy5uPXQ7by5zPXQ7aS5uPXQ7aWYoMzImby5mKWkuUyh0KTtyZXR1cm4gdDt9ZWxzZSBpZigtMT09PXQuaSl7dC5pPTA7aWYodm9pZCAwIT09dC5uKXt0Lm4ucD10LnA7aWYodm9pZCAwIT09dC5wKXQucC5uPXQubjt0LnA9by5zO3Qubj12b2lkIDA7by5zLm49dDtvLnM9dDt9cmV0dXJuIHQ7fX19ZnVuY3Rpb24gdShpLHQpe3RoaXMudj1pO3RoaXMuaT0wO3RoaXMubj12b2lkIDA7dGhpcy50PXZvaWQgMDt0aGlzLlc9bnVsbD09dD92b2lkIDA6dC53YXRjaGVkO3RoaXMuWj1udWxsPT10P3ZvaWQgMDp0LnVud2F0Y2hlZDt0aGlzLm5hbWU9bnVsbD09dD92b2lkIDA6dC5uYW1lO311LnByb3RvdHlwZS5icmFuZD1pO3UucHJvdG90eXBlLmg9ZnVuY3Rpb24oKXtyZXR1cm4gIHRydWU7fTt1LnByb3RvdHlwZS5TPWZ1bmN0aW9uKGkpe3ZhciB0PXRoaXMscj10aGlzLnQ7aWYociE9PWkmJnZvaWQgMD09PWkuZSl7aS54PXI7dGhpcy50PWk7aWYodm9pZCAwIT09cilyLmU9aTtlbHNlIG4oZnVuY3Rpb24oKXt2YXIgaTtudWxsPT0oaT10LlcpfHxpLmNhbGwodCk7fSk7fX07dS5wcm90b3R5cGUuVT1mdW5jdGlvbihpKXt2YXIgdD10aGlzO2lmKHZvaWQgMCE9PXRoaXMudCl7dmFyIHI9aS5lLG89aS54O2lmKHZvaWQgMCE9PXIpe3IueD1vO2kuZT12b2lkIDA7fWlmKHZvaWQgMCE9PW8pe28uZT1yO2kueD12b2lkIDA7fWlmKGk9PT10aGlzLnQpe3RoaXMudD1vO2lmKHZvaWQgMD09PW8pbihmdW5jdGlvbigpe3ZhciBpO251bGw9PShpPXQuWil8fGkuY2FsbCh0KTt9KTt9fX07dS5wcm90b3R5cGUuc3Vic2NyaWJlPWZ1bmN0aW9uKGkpe3ZhciB0PXRoaXM7cmV0dXJuIEUoZnVuY3Rpb24oKXt2YXIgcj10LnZhbHVlLG49bztvPXZvaWQgMDt0cnl7aShyKTt9ZmluYWxseXtvPW47fX0se25hbWU6XCJzdWJcIn0pO307dS5wcm90b3R5cGUudmFsdWVPZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlO307dS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZStcIlwiO307dS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWU7fTt1LnByb3RvdHlwZS5wZWVrPWZ1bmN0aW9uKCl7dmFyIGk9bztvPXZvaWQgMDt0cnl7cmV0dXJuIHRoaXMudmFsdWU7fWZpbmFsbHl7bz1pO319O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LnByb3RvdHlwZSxcInZhbHVlXCIse2dldDpmdW5jdGlvbigpe3ZhciBpPWUodGhpcyk7aWYodm9pZCAwIT09aSlpLmk9dGhpcy5pO3JldHVybiB0aGlzLnY7fSxzZXQ6ZnVuY3Rpb24oaSl7aWYoaSE9PXRoaXMudil7aWYoZj4xMDApdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGUgZGV0ZWN0ZWRcIik7dGhpcy52PWk7dGhpcy5pKys7disrO3MrKzt0cnl7Zm9yKHZhciByPXRoaXMudDt2b2lkIDAhPT1yO3I9ci54KXIudC5OKCk7fWZpbmFsbHl7dCgpO319fX0pO2Z1bmN0aW9uIGQoaSx0KXtyZXR1cm4gbmV3IHUoaSx0KTt9ZnVuY3Rpb24gYyhpKXtmb3IodmFyIHQ9aS5zO3ZvaWQgMCE9PXQ7dD10Lm4paWYodC5TLmkhPT10Lml8fCF0LlMuaCgpfHx0LlMuaSE9PXQuaSlyZXR1cm4gIHRydWU7cmV0dXJuICBmYWxzZTt9ZnVuY3Rpb24gYShpKXtmb3IodmFyIHQ9aS5zO3ZvaWQgMCE9PXQ7dD10Lm4pe3ZhciByPXQuUy5uO2lmKHZvaWQgMCE9PXIpdC5yPXI7dC5TLm49dDt0Lmk9LTE7aWYodm9pZCAwPT09dC5uKXtpLnM9dDticmVhazt9fX1mdW5jdGlvbiBsKGkpe3ZhciB0PWkucyxyPXZvaWQgMDt3aGlsZSh2b2lkIDAhPT10KXt2YXIgbz10LnA7aWYoLTE9PT10Lmkpe3QuUy5VKHQpO2lmKHZvaWQgMCE9PW8pby5uPXQubjtpZih2b2lkIDAhPT10Lm4pdC5uLnA9bzt9ZWxzZSByPXQ7dC5TLm49dC5yO2lmKHZvaWQgMCE9PXQucil0LnI9dm9pZCAwO3Q9bzt9aS5zPXI7fWZ1bmN0aW9uIHkoaSx0KXt1LmNhbGwodGhpcyx2b2lkIDApO3RoaXMueD1pO3RoaXMucz12b2lkIDA7dGhpcy5nPXYtMTt0aGlzLmY9NDt0aGlzLlc9bnVsbD09dD92b2lkIDA6dC53YXRjaGVkO3RoaXMuWj1udWxsPT10P3ZvaWQgMDp0LnVud2F0Y2hlZDt0aGlzLm5hbWU9bnVsbD09dD92b2lkIDA6dC5uYW1lO315LnByb3RvdHlwZT1uZXcgdSgpO3kucHJvdG90eXBlLmg9ZnVuY3Rpb24oKXt0aGlzLmYmPS0zO2lmKDEmdGhpcy5mKXJldHVybiAgZmFsc2U7aWYoMzI9PSgzNiZ0aGlzLmYpKXJldHVybiAgdHJ1ZTt0aGlzLmYmPS01O2lmKHRoaXMuZz09PXYpcmV0dXJuICB0cnVlO3RoaXMuZz12O3RoaXMuZnw9MTtpZih0aGlzLmk+MCYmIWModGhpcykpe3RoaXMuZiY9LTI7cmV0dXJuICB0cnVlO312YXIgaT1vO3RyeXthKHRoaXMpO289dGhpczt2YXIgdD10aGlzLngoKTtpZigxNiZ0aGlzLmZ8fHRoaXMudiE9PXR8fDA9PT10aGlzLmkpe3RoaXMudj10O3RoaXMuZiY9LTE3O3RoaXMuaSsrO319Y2F0Y2goaSl7dGhpcy52PWk7dGhpcy5mfD0xNjt0aGlzLmkrKzt9bz1pO2wodGhpcyk7dGhpcy5mJj0tMjtyZXR1cm4gIHRydWU7fTt5LnByb3RvdHlwZS5TPWZ1bmN0aW9uKGkpe2lmKHZvaWQgMD09PXRoaXMudCl7dGhpcy5mfD0zNjtmb3IodmFyIHQ9dGhpcy5zO3ZvaWQgMCE9PXQ7dD10Lm4pdC5TLlModCk7fXUucHJvdG90eXBlLlMuY2FsbCh0aGlzLGkpO307eS5wcm90b3R5cGUuVT1mdW5jdGlvbihpKXtpZih2b2lkIDAhPT10aGlzLnQpe3UucHJvdG90eXBlLlUuY2FsbCh0aGlzLGkpO2lmKHZvaWQgMD09PXRoaXMudCl7dGhpcy5mJj0tMzM7Zm9yKHZhciB0PXRoaXMuczt2b2lkIDAhPT10O3Q9dC5uKXQuUy5VKHQpO319fTt5LnByb3RvdHlwZS5OPWZ1bmN0aW9uKCl7aWYoISgyJnRoaXMuZikpe3RoaXMuZnw9Njtmb3IodmFyIGk9dGhpcy50O3ZvaWQgMCE9PWk7aT1pLngpaS50Lk4oKTt9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoeS5wcm90b3R5cGUsXCJ2YWx1ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtpZigxJnRoaXMuZil0aHJvdyBuZXcgRXJyb3IoXCJDeWNsZSBkZXRlY3RlZFwiKTt2YXIgaT1lKHRoaXMpO3RoaXMuaCgpO2lmKHZvaWQgMCE9PWkpaS5pPXRoaXMuaTtpZigxNiZ0aGlzLmYpdGhyb3cgdGhpcy52O3JldHVybiB0aGlzLnY7fX0pO2Z1bmN0aW9uIF8oaSl7dmFyIHI9aS51O2kudT12b2lkIDA7aWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygcil7cysrO3ZhciBuPW87bz12b2lkIDA7dHJ5e3IoKTt9Y2F0Y2godCl7aS5mJj0tMjtpLmZ8PTg7YihpKTt0aHJvdyB0O31maW5hbGx5e289bjt0KCk7fX19ZnVuY3Rpb24gYihpKXtmb3IodmFyIHQ9aS5zO3ZvaWQgMCE9PXQ7dD10Lm4pdC5TLlUodCk7aS54PXZvaWQgMDtpLnM9dm9pZCAwO18oaSk7fWZ1bmN0aW9uIGcoaSl7aWYobyE9PXRoaXMpdGhyb3cgbmV3IEVycm9yKFwiT3V0LW9mLW9yZGVyIGVmZmVjdFwiKTtsKHRoaXMpO289aTt0aGlzLmYmPS0yO2lmKDgmdGhpcy5mKWIodGhpcyk7dCgpO31mdW5jdGlvbiBwKGksdCl7dGhpcy54PWk7dGhpcy51PXZvaWQgMDt0aGlzLnM9dm9pZCAwO3RoaXMubz12b2lkIDA7dGhpcy5mPTMyO3RoaXMubmFtZT1udWxsPT10P3ZvaWQgMDp0Lm5hbWU7fXAucHJvdG90eXBlLmM9ZnVuY3Rpb24oKXt2YXIgaT10aGlzLlMoKTt0cnl7aWYoOCZ0aGlzLmYpcmV0dXJuO2lmKHZvaWQgMD09PXRoaXMueClyZXR1cm47dmFyIHQ9dGhpcy54KCk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdCl0aGlzLnU9dDt9ZmluYWxseXtpKCk7fX07cC5wcm90b3R5cGUuUz1mdW5jdGlvbigpe2lmKDEmdGhpcy5mKXRocm93IG5ldyBFcnJvcihcIkN5Y2xlIGRldGVjdGVkXCIpO3RoaXMuZnw9MTt0aGlzLmYmPS05O18odGhpcyk7YSh0aGlzKTtzKys7dmFyIGk9bztvPXRoaXM7cmV0dXJuIGcuYmluZCh0aGlzLGkpO307cC5wcm90b3R5cGUuTj1mdW5jdGlvbigpe2lmKCEoMiZ0aGlzLmYpKXt0aGlzLmZ8PTI7dGhpcy5vPWg7aD10aGlzO319O3AucHJvdG90eXBlLmQ9ZnVuY3Rpb24oKXt0aGlzLmZ8PTg7aWYoISgxJnRoaXMuZikpYih0aGlzKTt9O3AucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmQoKTt9O2Z1bmN0aW9uIEUoaSx0KXt2YXIgcj1uZXcgcChpLHQpO3RyeXtyLmMoKTt9Y2F0Y2goaSl7ci5kKCk7dGhyb3cgaTt9dmFyIG89ci5kLmJpbmQocik7b1tTeW1ib2wuZGlzcG9zZV09bztyZXR1cm4gbzt9XG5cbi8qKlxuICogQSBidWZmZXIgcXVldWUgdG8gc2VydmUgYXMgYSBzdG9yZSBmb3IgYW55IHR5cGUgb2YgZGF0YVxuICovY2xhc3MgQnVmZmVyUXVldWV7Y29uc3RydWN0b3IoKXt0aGlzLml0ZW1zPVtdO31lbnF1ZXVlKGl0ZW0pe3RoaXMuaXRlbXMucHVzaChpdGVtKTt9ZGVxdWV1ZSgpe2lmKHRoaXMuaXRlbXMubGVuZ3RoPT09MCl7cmV0dXJuIG51bGw7fXJldHVybiB0aGlzLml0ZW1zLnNoaWZ0KCk7fWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGg9PT0wO31zaXplKCl7cmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoO31jbGVhcigpe3RoaXMuaXRlbXM9W107fX1cblxuY29uc3QgTE9HX0xFVkVMX01BUD17TE9HOjAsSU5GTzoxLERFQlVHOjIsV0FSTjozLEVSUk9SOjQsTk9ORTo1fTtjb25zdCBERUZBVUxUX0xPR19MRVZFTD0nTE9HJztjb25zdCBQT1NUX0xPQURfTE9HX0xFVkVMPSdFUlJPUic7Y29uc3QgTE9HX01TR19QUkVGSVg9J1JTIFNESyc7Y29uc3QgTE9HX01TR19QUkVGSVhfU1RZTEU9J2ZvbnQtd2VpZ2h0OiBib2xkOyBiYWNrZ3JvdW5kOiBibGFjazsgY29sb3I6IHdoaXRlOyc7Y29uc3QgTE9HX01TR19TVFlMRT0nZm9udC13ZWlnaHQ6IG5vcm1hbDsnOy8qKlxuICogU2VydmljZSB0byBsb2cgbWVzc2FnZXMvZGF0YSB0byBvdXRwdXQgcHJvdmlkZXIsIGRlZmF1bHQgaXMgY29uc29sZVxuICovY2xhc3MgTG9nZ2Vye2NvbnN0cnVjdG9yKG1pbkxvZ0xldmVsPURFRkFVTFRfTE9HX0xFVkVMLHNjb3BlPScnLGxvZ1Byb3ZpZGVyPWNvbnNvbGUpe3RoaXMubWluTG9nTGV2ZWw9TE9HX0xFVkVMX01BUFttaW5Mb2dMZXZlbF07dGhpcy5zY29wZT1zY29wZTt0aGlzLmxvZ1Byb3ZpZGVyPWxvZ1Byb3ZpZGVyO31sb2coLi4uZGF0YSl7dGhpcy5vdXRwdXRMb2coJ0xPRycsZGF0YSk7fWluZm8oLi4uZGF0YSl7dGhpcy5vdXRwdXRMb2coJ0lORk8nLGRhdGEpO31kZWJ1ZyguLi5kYXRhKXt0aGlzLm91dHB1dExvZygnREVCVUcnLGRhdGEpO313YXJuKC4uLmRhdGEpe3RoaXMub3V0cHV0TG9nKCdXQVJOJyxkYXRhKTt9ZXJyb3IoLi4uZGF0YSl7dGhpcy5vdXRwdXRMb2coJ0VSUk9SJyxkYXRhKTt9b3V0cHV0TG9nKGxvZ01ldGhvZCxkYXRhKXtpZih0aGlzLm1pbkxvZ0xldmVsPD1MT0dfTEVWRUxfTUFQW2xvZ01ldGhvZF0pe3RoaXMubG9nUHJvdmlkZXJbbG9nTWV0aG9kLnRvTG93ZXJDYXNlKCldPy4oLi4udGhpcy5mb3JtYXRMb2dEYXRhKGRhdGEpKTt9fXNldFNjb3BlKHNjb3BlVmFsKXt0aGlzLnNjb3BlPXNjb3BlVmFsfHx0aGlzLnNjb3BlO30vLyBUT0RPOiBzaG91bGQgd2UgYWxsb3cgdG8gY2hhbmdlIHRoZSBsZXZlbCB2aWEgZ2xvYmFsIHZhcmlhYmxlIG9uIHJ1biB0aW1lXG4vLyAgdG8gYXNzaXN0IG9uIHRoZSBmbHkgZGVidWdnaW5nP1xuc2V0TWluTG9nTGV2ZWwobG9nTGV2ZWwpe3RoaXMubWluTG9nTGV2ZWw9TE9HX0xFVkVMX01BUFtsb2dMZXZlbF07aWYoaXNVbmRlZmluZWQodGhpcy5taW5Mb2dMZXZlbCkpe3RoaXMubWluTG9nTGV2ZWw9TE9HX0xFVkVMX01BUFtERUZBVUxUX0xPR19MRVZFTF07fX0vKipcbiAgICogRm9ybWF0cyB0aGUgY29uc29sZSBtZXNzYWdlIHVzaW5nIGBzY29wZWAgYW5kIHN0eWxlc1xuICAgKi9mb3JtYXRMb2dEYXRhKGRhdGEpe2lmKEFycmF5LmlzQXJyYXkoZGF0YSkmJmRhdGEubGVuZ3RoPjApey8vIHByZWZpeCBTREsgaWRlbnRpZmllclxubGV0IG1zZz1gJWMgJHtMT0dfTVNHX1BSRUZJWH1gOy8vIGZvcm1hdCB0aGUgbG9nIG1lc3NhZ2UgdXNpbmcgYHNjb3BlYFxuaWYodGhpcy5zY29wZSl7bXNnPWAke21zZ30gLSAke3RoaXMuc2NvcGV9YDt9Ly8gdHJpbSB3aGl0ZXNwYWNlcyBmb3Igb3JpZ2luYWwgbWVzc2FnZVxuY29uc3Qgb3JpZ2luYWxNc2c9aXNTdHJpbmcoZGF0YVswXSk/ZGF0YVswXS50cmltKCk6Jyc7Ly8gcHJlcGFyZSB0aGUgZmluYWwgbWVzc2FnZVxubXNnPWAke21zZ30gJWMgJHtvcmlnaW5hbE1zZ31gO2NvbnN0IHN0eWxlZExvZ0FyZ3M9W21zZyxMT0dfTVNHX1BSRUZJWF9TVFlMRSwvLyBhZGQgc3R5bGUgZm9yIHRoZSBwcmVmaXhcbkxPR19NU0dfU1RZTEUvLyByZXNldCB0aGUgc3R5bGUgZm9yIHRoZSBhY3R1YWwgbWVzc2FnZVxuXTsvLyBhZGQgZmlyc3QgaXQgaWYgaXQgd2FzIG5vdCBhIHN0cmluZyBtc2dcbmlmKCFpc1N0cmluZyhkYXRhWzBdKSl7c3R5bGVkTG9nQXJncy5wdXNoKGRhdGFbMF0pO30vLyBhcHBlbmQgcmVzdCBvZiB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5zdHlsZWRMb2dBcmdzLnB1c2goLi4uZGF0YS5zbGljZSgxKSk7cmV0dXJuIHN0eWxlZExvZ0FyZ3M7fXJldHVybiBkYXRhO319Y29uc3QgZGVmYXVsdExvZ2dlcj1uZXcgTG9nZ2VyKCk7XG5cbmxldCBFcnJvclR5cGU9LyojX19QVVJFX18qL2Z1bmN0aW9uKEVycm9yVHlwZSl7RXJyb3JUeXBlW1wiSEFORExFREVYQ0VQVElPTlwiXT1cImhhbmRsZWRFeGNlcHRpb25cIjtFcnJvclR5cGVbXCJVTkhBTkRMRURFWENFUFRJT05cIl09XCJ1bmhhbmRsZWRFeGNlcHRpb25cIjtFcnJvclR5cGVbXCJVTkhBTkRMRURSRUpFQ1RJT05cIl09XCJ1bmhhbmRsZWRQcm9taXNlUmVqZWN0aW9uXCI7cmV0dXJuIEVycm9yVHlwZTt9KHt9KTtcblxuLy8gZGVmYXVsdCBpcyB2M1xuY29uc3QgU1VQUE9SVEVEX1NUT1JBR0VfVFlQRVM9Wydsb2NhbFN0b3JhZ2UnLCdtZW1vcnlTdG9yYWdlJywnY29va2llU3RvcmFnZScsJ3Nlc3Npb25TdG9yYWdlJywnbm9uZSddO2NvbnN0IERFRkFVTFRfU1RPUkFHRV9UWVBFPSdjb29raWVTdG9yYWdlJztcblxuY29uc3QgU09VUkNFX0NPTkZJR19SRVNPTFVUSU9OX0VSUk9SPWBVbmFibGUgdG8gcHJvY2Vzcy9wYXJzZSBzb3VyY2UgY29uZmlndXJhdGlvbiByZXNwb25zZWA7Y29uc3QgU09VUkNFX0RJU0FCTEVEX0VSUk9SPWBUaGUgc291cmNlIGlzIGRpc2FibGVkLiBQbGVhc2UgZW5hYmxlIHRoZSBzb3VyY2UgaW4gdGhlIGRhc2hib2FyZCB0byBzZW5kIGV2ZW50cy5gO2NvbnN0IFhIUl9QQVlMT0FEX1BSRVBfRVJST1I9YEZhaWxlZCB0byBwcmVwYXJlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LmA7Y29uc3QgUExVR0lOX0VYVF9QT0lOVF9NSVNTSU5HX0VSUk9SPWBGYWlsZWQgdG8gaW52b2tlIHBsdWdpbiBiZWNhdXNlIHRoZSBleHRlbnNpb24gcG9pbnQgbmFtZSBpcyBtaXNzaW5nLmA7Y29uc3QgUExVR0lOX0VYVF9QT0lOVF9JTlZBTElEX0VSUk9SPWBGYWlsZWQgdG8gaW52b2tlIHBsdWdpbiBiZWNhdXNlIHRoZSBleHRlbnNpb24gcG9pbnQgbmFtZSBpcyBpbnZhbGlkLmA7Y29uc3QgU09VUkNFX0NPTkZJR19PUFRJT05fRVJST1I9Y29udGV4dD0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1UaGUgXCJnZXRTb3VyY2VDb25maWdcIiBsb2FkIEFQSSBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB2YWxpZCBzb3VyY2UgY29uZmlndXJhdGlvbiBkYXRhLmA7Y29uc3QgQ09NUE9ORU5UX0JBU0VfVVJMX0VSUk9SPShjb250ZXh0LGNvbXBvbmVudCx1cmwpPT5gJHtjb250ZXh0fSR7TE9HX0NPTlRFWFRfU0VQQVJBVE9SfVRoZSBiYXNlIFVSTCBcIiR7dXJsfVwiIGZvciAke2NvbXBvbmVudH0gaXMgbm90IHZhbGlkLmA7Ly8gRVJST1JcbmNvbnN0IFVOU1VQUE9SVEVEX0NPTlNFTlRfTUFOQUdFUl9FUlJPUj0oY29udGV4dCxzZWxlY3RlZENvbnNlbnRNYW5hZ2VyLGNvbnNlbnRNYW5hZ2Vyc1RvUGx1Z2luTmFtZU1hcCk9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9VGhlIGNvbnNlbnQgbWFuYWdlciBcIiR7c2VsZWN0ZWRDb25zZW50TWFuYWdlcn1cIiBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgY2hvb3NlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHN1cHBvcnRlZCBjb25zZW50IG1hbmFnZXJzOiBcIiR7T2JqZWN0LmtleXMoY29uc2VudE1hbmFnZXJzVG9QbHVnaW5OYW1lTWFwKX1cIi5gO2NvbnN0IE5PTl9FUlJPUl9XQVJOSU5HPShjb250ZXh0LGVyclN0cik9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9SWdub3JpbmcgYSBub24tZXJyb3I6ICR7ZXJyU3RyfS5gO2NvbnN0IEJSRUFEQ1JVTUJfRVJST1I9YEZhaWxlZCB0byBsb2cgYnJlYWRjcnVtYmA7Y29uc3QgSEFORExFX0VSUk9SX0ZBSUxVUkU9Y29udGV4dD0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1GYWlsZWQgdG8gaGFuZGxlIHRoZSBlcnJvci5gO2NvbnN0IFBMVUdJTl9OQU1FX01JU1NJTkdfRVJST1I9Y29udGV4dD0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1QbHVnaW4gbmFtZSBpcyBtaXNzaW5nLmA7Y29uc3QgUExVR0lOX0FMUkVBRFlfRVhJU1RTX0VSUk9SPShjb250ZXh0LHBsdWdpbk5hbWUpPT5gJHtjb250ZXh0fSR7TE9HX0NPTlRFWFRfU0VQQVJBVE9SfVBsdWdpbiBcIiR7cGx1Z2luTmFtZX1cIiBhbHJlYWR5IGV4aXN0cy5gO2NvbnN0IFBMVUdJTl9OT1RfRk9VTkRfRVJST1I9KGNvbnRleHQscGx1Z2luTmFtZSk9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9UGx1Z2luIFwiJHtwbHVnaW5OYW1lfVwiIG5vdCBmb3VuZC5gO2NvbnN0IFBMVUdJTl9FTkdJTkVfQlVHX0VSUk9SPShjb250ZXh0LHBsdWdpbk5hbWUpPT5gJHtjb250ZXh0fSR7TE9HX0NPTlRFWFRfU0VQQVJBVE9SfVBsdWdpbiBcIiR7cGx1Z2luTmFtZX1cIiBub3QgZm91bmQgaW4gcGx1Z2lucyBidXQgZm91bmQgaW4gYnlOYW1lLiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiB0aGUgcGx1Z2luIGVuZ2luZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGlzc3VlIHRvIHRoZSBkZXZlbG9wbWVudCB0ZWFtLmA7Y29uc3QgUExVR0lOX0RFUFNfRVJST1I9KGNvbnRleHQscGx1Z2luTmFtZSxub3RFeGlzdERlcHMpPT5gJHtjb250ZXh0fSR7TE9HX0NPTlRFWFRfU0VQQVJBVE9SfVBsdWdpbiBcIiR7cGx1Z2luTmFtZX1cIiBjb3VsZCBub3QgYmUgbG9hZGVkIGJlY2F1c2Ugc29tZSBvZiBpdHMgZGVwZW5kZW5jaWVzIFwiJHtub3RFeGlzdERlcHN9XCIgZG8gbm90IGV4aXN0LmA7Y29uc3QgUExVR0lOX0lOVk9DQVRJT05fRVJST1I9KGNvbnRleHQsZXh0UG9pbnQscGx1Z2luTmFtZSk9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9RmFpbGVkIHRvIGludm9rZSB0aGUgXCIke2V4dFBvaW50fVwiIGV4dGVuc2lvbiBwb2ludCBvZiBwbHVnaW4gXCIke3BsdWdpbk5hbWV9XCIuYDtjb25zdCBTT1VSQ0VfQ09ORklHX0ZFVENIX0VSUk9SPSdGYWlsZWQgdG8gZmV0Y2ggdGhlIHNvdXJjZSBjb25maWcnO2NvbnN0IFdSSVRFX0tFWV9WQUxJREFUSU9OX0VSUk9SPShjb250ZXh0LHdyaXRlS2V5KT0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1UaGUgd3JpdGUga2V5IFwiJHt3cml0ZUtleX1cIiBpcyBpbnZhbGlkLiBJdCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy4gUGxlYXNlIGNoZWNrIHRoYXQgdGhlIHdyaXRlIGtleSBpcyBjb3JyZWN0IGFuZCB0cnkgYWdhaW4uYDtjb25zdCBEQVRBX1BMQU5FX1VSTF9WQUxJREFUSU9OX0VSUk9SPShjb250ZXh0LGRhdGFQbGFuZVVybCk9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9VGhlIGRhdGEgcGxhbmUgVVJMIFwiJHtkYXRhUGxhbmVVcmx9XCIgaXMgaW52YWxpZC4gSXQgbXVzdCBiZSBhIHZhbGlkIFVSTCBzdHJpbmcuIFBsZWFzZSBjaGVjayB0aGF0IHRoZSBkYXRhIHBsYW5lIFVSTCBpcyBjb3JyZWN0IGFuZCB0cnkgYWdhaW4uYDtjb25zdCBJTlZBTElEX0NBTExCQUNLX0ZOX0VSUk9SPWNvbnRleHQ9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9VGhlIHByb3ZpZGVkIGNhbGxiYWNrIHBhcmFtZXRlciBpcyBub3QgYSBmdW5jdGlvbi5gO2NvbnN0IFhIUl9ERUxJVkVSWV9FUlJPUj0ocHJlZml4LHN0YXR1cyxzdGF0dXNUZXh0LHVybCxyZXNwb25zZSk9PmAke3ByZWZpeH0gd2l0aCBzdGF0dXMgJHtzdGF0dXN9ICgke3N0YXR1c1RleHR9KSBmb3IgVVJMOiAke3VybH0uIFJlc3BvbnNlOiAke3Jlc3BvbnNlLnRyaW0oKX1gO2NvbnN0IFhIUl9SRVFVRVNUX0VSUk9SPShwcmVmaXgsZSx1cmwpPT5gJHtwcmVmaXh9IGR1ZSB0byB0aW1lb3V0IG9yIG5vIGNvbm5lY3Rpb24gKCR7ZT9lLnR5cGU6Jyd9KSBhdCB0aGUgY2xpZW50IHNpZGUgZm9yIFVSTDogJHt1cmx9YDtjb25zdCBYSFJfU0VORF9FUlJPUj0ocHJlZml4LHVybCk9PmAke3ByZWZpeH0gZm9yIFVSTDogJHt1cmx9YDtjb25zdCBTVE9SRV9EQVRBX1NBVkVfRVJST1I9a2V5PT5gRmFpbGVkIHRvIHNhdmUgdGhlIHZhbHVlIGZvciBcIiR7a2V5fVwiIHRvIHN0b3JhZ2VgO2NvbnN0IFNUT1JFX0RBVEFfRkVUQ0hfRVJST1I9a2V5PT5gRmFpbGVkIHRvIHJldHJpZXZlIG9yIHBhcnNlIGRhdGEgZm9yIFwiJHtrZXl9XCIgZnJvbSBzdG9yYWdlYDtjb25zdCBEQVRBX1NFUlZFUl9SRVFVRVNUX0ZBSUxfRVJST1I9c3RhdHVzPT5gVGhlIHNlcnZlciByZXNwb25kZWQgd2l0aCBzdGF0dXMgJHtzdGF0dXN9IHdoaWxlIHNldHRpbmcgdGhlIGNvb2tpZXMuIEFzIGEgZmFsbGJhY2ssIHRoZSBjb29raWVzIHdpbGwgYmUgc2V0IGNsaWVudCBzaWRlLmA7Y29uc3QgRkFJTEVEX1NFVFRJTkdfQ09PS0lFX0ZST01fU0VSVkVSX0VSUk9SPWtleT0+YFRoZSBzZXJ2ZXIgZmFpbGVkIHRvIHNldCB0aGUgJHtrZXl9IGNvb2tpZS4gQXMgYSBmYWxsYmFjaywgdGhlIGNvb2tpZXMgd2lsbCBiZSBzZXQgY2xpZW50IHNpZGUuYDtjb25zdCBGQUlMRURfU0VUVElOR19DT09LSUVfRlJPTV9TRVJWRVJfR0xPQkFMX0VSUk9SPWBGYWlsZWQgdG8gc2V0L3JlbW92ZSBjb29raWVzIHZpYSBzZXJ2ZXIuIEFzIGEgZmFsbGJhY2ssIHRoZSBjb29raWVzIHdpbGwgYmUgbWFuYWdlZCBjbGllbnQgc2lkZS5gOy8vIFdBUk5JTkdcbmNvbnN0IFNUT1JBR0VfVFlQRV9WQUxJREFUSU9OX1dBUk5JTkc9KGNvbnRleHQsc3RvcmFnZVR5cGUsZGVmYXVsdFN0b3JhZ2VUeXBlKT0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1UaGUgc3RvcmFnZSB0eXBlIFwiJHtzdG9yYWdlVHlwZX1cIiBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgY2hvb3NlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHN1cHBvcnRlZCB0eXBlczogXCIke1NVUFBPUlRFRF9TVE9SQUdFX1RZUEVTfVwiLiBUaGUgZGVmYXVsdCB0eXBlIFwiJHtkZWZhdWx0U3RvcmFnZVR5cGV9XCIgd2lsbCBiZSB1c2VkIGluc3RlYWQuYDtjb25zdCBVTlNVUFBPUlRFRF9TVE9SQUdFX0VOQ1JZUFRJT05fVkVSU0lPTl9XQVJOSU5HPShjb250ZXh0LHNlbGVjdGVkU3RvcmFnZUVuY3J5cHRpb25WZXJzaW9uLHN0b3JhZ2VFbmNyeXB0aW9uVmVyc2lvbnNUb1BsdWdpbk5hbWVNYXAsZGVmYXVsdFZlcnNpb24pPT5gJHtjb250ZXh0fSR7TE9HX0NPTlRFWFRfU0VQQVJBVE9SfVRoZSBzdG9yYWdlIGVuY3J5cHRpb24gdmVyc2lvbiBcIiR7c2VsZWN0ZWRTdG9yYWdlRW5jcnlwdGlvblZlcnNpb259XCIgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIGNob29zZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBzdXBwb3J0ZWQgdmVyc2lvbnM6IFwiJHtPYmplY3Qua2V5cyhzdG9yYWdlRW5jcnlwdGlvblZlcnNpb25zVG9QbHVnaW5OYW1lTWFwKX1cIi4gVGhlIGRlZmF1bHQgdmVyc2lvbiBcIiR7ZGVmYXVsdFZlcnNpb259XCIgd2lsbCBiZSB1c2VkIGluc3RlYWQuYDtjb25zdCBTVE9SQUdFX0RBVEFfTUlHUkFUSU9OX09WRVJSSURFX1dBUk5JTkc9KGNvbnRleHQsc3RvcmFnZUVuY3J5cHRpb25WZXJzaW9uLGRlZmF1bHRWZXJzaW9uKT0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1UaGUgc3RvcmFnZSBkYXRhIG1pZ3JhdGlvbiBoYXMgYmVlbiBkaXNhYmxlZCBiZWNhdXNlIHRoZSBjb25maWd1cmVkIHN0b3JhZ2UgZW5jcnlwdGlvbiB2ZXJzaW9uICgke3N0b3JhZ2VFbmNyeXB0aW9uVmVyc2lvbn0pIGlzIG5vdCB0aGUgbGF0ZXN0ICgke2RlZmF1bHRWZXJzaW9ufSkuIFRvIGVuYWJsZSBzdG9yYWdlIGRhdGEgbWlncmF0aW9uLCBwbGVhc2UgdXBkYXRlIHRoZSBzdG9yYWdlIGVuY3J5cHRpb24gdmVyc2lvbiB0byB0aGUgbGF0ZXN0IHZlcnNpb24uYDtjb25zdCBTRVJWRVJfU0lERV9DT09LSUVfRkVBVFVSRV9PVkVSUklERV9XQVJOSU5HPShjb250ZXh0LHByb3ZpZGVkQ29va2llRG9tYWluLGN1cnJlbnRDb29raWVEb21haW4pPT5gJHtjb250ZXh0fSR7TE9HX0NPTlRFWFRfU0VQQVJBVE9SfVRoZSBwcm92aWRlZCBjb29raWUgZG9tYWluICgke3Byb3ZpZGVkQ29va2llRG9tYWlufSkgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgd2VicGFnZSdzIGRvbWFpbiAoJHtjdXJyZW50Q29va2llRG9tYWlufSkuIEhlbmNlLCB0aGUgY29va2llcyB3aWxsIGJlIHNldCBjbGllbnQtc2lkZS5gO2NvbnN0IFJFU0VSVkVEX0tFWVdPUkRfV0FSTklORz0oY29udGV4dCxwcm9wZXJ0eSxwYXJlbnRLZXlQYXRoLHJlc2VydmVkRWxlbWVudHMpPT5gJHtjb250ZXh0fSR7TE9HX0NPTlRFWFRfU0VQQVJBVE9SfVRoZSBcIiR7cHJvcGVydHl9XCIgcHJvcGVydHkgZGVmaW5lZCB1bmRlciBcIiR7cGFyZW50S2V5UGF0aH1cIiBpcyBhIHJlc2VydmVkIGtleXdvcmQuIFBsZWFzZSBjaG9vc2UgYSBkaWZmZXJlbnQgcHJvcGVydHkgbmFtZSB0byBhdm9pZCBjb25mbGljdHMgd2l0aCByZXNlcnZlZCBrZXl3b3JkcyAoJHtyZXNlcnZlZEVsZW1lbnRzfSkuYDtjb25zdCBJTlZBTElEX0NPTlRFWFRfT0JKRUNUX1dBUk5JTkc9bG9nQ29udGV4dD0+YCR7bG9nQ29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1QbGVhc2UgbWFrZSBzdXJlIHRoYXQgdGhlIFwiY29udGV4dFwiIHByb3BlcnR5IGluIHRoZSBldmVudCBBUEkncyBcIm9wdGlvbnNcIiBhcmd1bWVudCBpcyBhIHZhbGlkIG9iamVjdCBsaXRlcmFsIHdpdGgga2V5LXZhbHVlIHBhaXJzLmA7Y29uc3QgVU5TVVBQT1JURURfQkVBQ09OX0FQSV9XQVJOSU5HPWNvbnRleHQ9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9VGhlIEJlYWNvbiBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXIuIFRoZSBldmVudHMgd2lsbCBiZSBzZW50IHVzaW5nIFhIUiBpbnN0ZWFkLmA7Y29uc3QgVElNRU9VVF9OT1RfTlVNQkVSX1dBUk5JTkc9KGNvbnRleHQsdGltZW91dCxkZWZhdWx0VmFsdWUpPT5gJHtjb250ZXh0fSR7TE9HX0NPTlRFWFRfU0VQQVJBVE9SfVRoZSBzZXNzaW9uIHRpbWVvdXQgdmFsdWUgXCIke3RpbWVvdXR9XCIgaXMgbm90IGEgbnVtYmVyLiBUaGUgZGVmYXVsdCB0aW1lb3V0IG9mICR7ZGVmYXVsdFZhbHVlfSBtcyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5gO2NvbnN0IENVVF9PRkZfRFVSQVRJT05fTk9UX05VTUJFUl9XQVJOSU5HPShjb250ZXh0LGN1dE9mZkR1cmF0aW9uLGRlZmF1bHRWYWx1ZSk9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9VGhlIHNlc3Npb24gY3V0IG9mZiBkdXJhdGlvbiB2YWx1ZSBcIiR7Y3V0T2ZmRHVyYXRpb259XCIgaXMgbm90IGEgbnVtYmVyLiBUaGUgZGVmYXVsdCBjdXQgb2ZmIGR1cmF0aW9uIG9mICR7ZGVmYXVsdFZhbHVlfSBtcyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5gO2NvbnN0IENVVF9PRkZfRFVSQVRJT05fTEVTU19USEFOX1RJTUVPVVRfV0FSTklORz0oY29udGV4dCxjdXRPZmZEdXJhdGlvbix0aW1lb3V0KT0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1UaGUgc2Vzc2lvbiBjdXQgb2ZmIGR1cmF0aW9uIHZhbHVlIFwiJHtjdXRPZmZEdXJhdGlvbn1cIiBtcyBpcyBsZXNzIHRoYW4gdGhlIHNlc3Npb24gdGltZW91dCB2YWx1ZSBcIiR7dGltZW91dH1cIiBtcy4gVGhlIGN1dCBvZmYgZnVuY3Rpb25hbGl0eSB3aWxsIGJlIGRpc2FibGVkLmA7Y29uc3QgVElNRU9VVF9aRVJPX1dBUk5JTkc9Y29udGV4dD0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1UaGUgc2Vzc2lvbiB0aW1lb3V0IHZhbHVlIGlzIDAsIHdoaWNoIGRpc2FibGVzIHRoZSBhdXRvbWF0aWMgc2Vzc2lvbiB0cmFja2luZyBmZWF0dXJlLiBJZiB5b3Ugd2FudCB0byBlbmFibGUgc2Vzc2lvbiB0cmFja2luZywgcGxlYXNlIHByb3ZpZGUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlIGZvciB0aGUgdGltZW91dC5gO2NvbnN0IFRJTUVPVVRfTk9UX1JFQ09NTUVOREVEX1dBUk5JTkc9KGNvbnRleHQsdGltZW91dCxtaW5UaW1lb3V0KT0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1UaGUgc2Vzc2lvbiB0aW1lb3V0IHZhbHVlICR7dGltZW91dH0gbXMgaXMgbGVzcyB0aGFuIHRoZSByZWNvbW1lbmRlZCBtaW5pbXVtIG9mICR7bWluVGltZW91dH0gbXMuIFBsZWFzZSBjb25zaWRlciBpbmNyZWFzaW5nIHRoZSB0aW1lb3V0IHZhbHVlIHRvIGVuc3VyZSBvcHRpbWFsIHBlcmZvcm1hbmNlIGFuZCByZWxpYWJpbGl0eS5gO2NvbnN0IElOVkFMSURfU0VTU0lPTl9JRF9XQVJOSU5HPShjb250ZXh0LHNlc3Npb25JZCxtaW5TZXNzaW9uSWRMZW5ndGgpPT5gJHtjb250ZXh0fSR7TE9HX0NPTlRFWFRfU0VQQVJBVE9SfVRoZSBwcm92aWRlZCBzZXNzaW9uIElEICgke3Nlc3Npb25JZH0pIGlzIGVpdGhlciBpbnZhbGlkLCBub3QgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBvciBub3QgYXQgbGVhc3QgXCIke21pblNlc3Npb25JZExlbmd0aH1cIiBkaWdpdHMgbG9uZy4gQSBuZXcgc2Vzc2lvbiBJRCB3aWxsIGJlIGF1dG8tZ2VuZXJhdGVkIGluc3RlYWQuYDtjb25zdCBTVE9SQUdFX1FVT1RBX0VYQ0VFREVEX1dBUk5JTkc9Y29udGV4dD0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1UaGUgc3RvcmFnZSBpcyBlaXRoZXIgZnVsbCBvciB1bmF2YWlsYWJsZSwgc28gdGhlIGRhdGEgd2lsbCBub3QgYmUgcGVyc2lzdGVkLiBTd2l0Y2hpbmcgdG8gaW4tbWVtb3J5IHN0b3JhZ2UuYDtjb25zdCBTVE9SQUdFX1VOQVZBSUxBQkxFX1dBUk5JTkc9KGNvbnRleHQsZW50cnksc2VsZWN0ZWRTdG9yYWdlVHlwZSxmaW5hbFN0b3JhZ2VUeXBlKT0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1UaGUgc3RvcmFnZSB0eXBlIFwiJHtzZWxlY3RlZFN0b3JhZ2VUeXBlfVwiIGlzIG5vdCBhdmFpbGFibGUgZm9yIGVudHJ5IFwiJHtlbnRyeX1cIi4gVGhlIFNESyB3aWxsIGluaXRpYWxpemUgdGhlIGVudHJ5IHdpdGggXCIke2ZpbmFsU3RvcmFnZVR5cGV9XCIgc3RvcmFnZSB0eXBlIGluc3RlYWQuYDtjb25zdCBDQUxMQkFDS19JTlZPS0VfRVJST1I9Y29udGV4dD0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1UaGUgY2FsbGJhY2sgdGhyZXcgYW4gZXhjZXB0aW9uYDtjb25zdCBJTlZBTElEX0NPTkZJR19VUkxfV0FSTklORz0oY29udGV4dCxjb25maWdVcmwpPT5gJHtjb250ZXh0fSR7TE9HX0NPTlRFWFRfU0VQQVJBVE9SfVRoZSBwcm92aWRlZCBzb3VyY2UgY29uZmlnIFVSTCBcIiR7Y29uZmlnVXJsfVwiIGlzIGludmFsaWQuIFVzaW5nIHRoZSBkZWZhdWx0IHNvdXJjZSBjb25maWcgVVJMIGluc3RlYWQuYDtjb25zdCBQT0xZRklMTF9TQ1JJUFRfTE9BRF9FUlJPUj0oc2NyaXB0SWQsdXJsKT0+YEZhaWxlZCB0byBsb2FkIHRoZSBwb2x5ZmlsbCBzY3JpcHQgd2l0aCBJRCBcIiR7c2NyaXB0SWR9XCIgZnJvbSBVUkwgJHt1cmx9LmA7Y29uc3QgVU5TVVBQT1JURURfUFJFX0NPTlNFTlRfU1RPUkFHRV9TVFJBVEVHWT0oY29udGV4dCxzZWxlY3RlZFN0cmF0ZWd5LGRlZmF1bHRTdHJhdGVneSk9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9VGhlIHByZS1jb25zZW50IHN0b3JhZ2Ugc3RyYXRlZ3kgXCIke3NlbGVjdGVkU3RyYXRlZ3l9XCIgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIGNob29zZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBzdXBwb3J0ZWQgc3RyYXRlZ2llczogXCJub25lLCBzZXNzaW9uLCBhbm9ueW1vdXNJZFwiLiBUaGUgZGVmYXVsdCBzdHJhdGVneSBcIiR7ZGVmYXVsdFN0cmF0ZWd5fVwiIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmA7Y29uc3QgVU5TVVBQT1JURURfUFJFX0NPTlNFTlRfRVZFTlRTX0RFTElWRVJZX1RZUEU9KGNvbnRleHQsc2VsZWN0ZWREZWxpdmVyeVR5cGUsZGVmYXVsdERlbGl2ZXJ5VHlwZSk9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9VGhlIHByZS1jb25zZW50IGV2ZW50cyBkZWxpdmVyeSB0eXBlIFwiJHtzZWxlY3RlZERlbGl2ZXJ5VHlwZX1cIiBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgY2hvb3NlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHN1cHBvcnRlZCB0eXBlczogXCJpbW1lZGlhdGUsIGJ1ZmZlclwiLiBUaGUgZGVmYXVsdCB0eXBlIFwiJHtkZWZhdWx0RGVsaXZlcnlUeXBlfVwiIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmA7Y29uc3QgREVQUkVDQVRFRF9QTFVHSU5fV0FSTklORz0oY29udGV4dCxwbHVnaW5OYW1lKT0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn0ke3BsdWdpbk5hbWV9IHBsdWdpbiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgZXhjbHVkZSBpdCBmcm9tIHRoZSBsb2FkIEFQSSBvcHRpb25zLmA7Y29uc3QgZ2VuZXJhdGVNaXNjb25maWd1cmVkUGx1Z2luc1dhcm5pbmc9KGNvbnRleHQsY29uZmlndXJhdGlvblN0YXR1cyxtaXNzaW5nUGx1Z2lucyxzaG91bGRBZGRNaXNzaW5nUGx1Z2lucyk9Pntjb25zdCBpc1NpbmdsZVBsdWdpbj1taXNzaW5nUGx1Z2lucy5sZW5ndGg9PT0xO2NvbnN0IHBsdWdpbnNTdHJpbmc9aXNTaW5nbGVQbHVnaW4/YCAnJHttaXNzaW5nUGx1Z2luc1swXX0nIHBsdWdpbiB3YXNgOmAgWycke21pc3NpbmdQbHVnaW5zLmpvaW4oXCInLCAnXCIpfSddIHBsdWdpbnMgd2VyZWA7Y29uc3QgYmFzZVdhcm5pbmc9YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn0ke2NvbmZpZ3VyYXRpb25TdGF0dXN9LCBidXQke3BsdWdpbnNTdHJpbmd9IG5vdCBjb25maWd1cmVkIHRvIGxvYWQuYDtpZihzaG91bGRBZGRNaXNzaW5nUGx1Z2lucyl7cmV0dXJuIGAke2Jhc2VXYXJuaW5nfSBTbywgJHtpc1NpbmdsZVBsdWdpbj8ndGhlIHBsdWdpbic6J3Rob3NlIHBsdWdpbnMnfSB3aWxsIGJlIGxvYWRlZCBhdXRvbWF0aWNhbGx5LmA7fXJldHVybiBgJHtiYXNlV2FybmluZ30gSWdub3JlIGlmIHRoaXMgd2FzIGludGVudGlvbmFsLiBPdGhlcndpc2UsIGNvbnNpZGVyIGFkZGluZyAke2lzU2luZ2xlUGx1Z2luPydpdCc6J3RoZW0nfSB0byB0aGUgJ3BsdWdpbnMnIGxvYWQgQVBJIG9wdGlvbi5gO307Y29uc3QgSU5WQUxJRF9QT0xZRklMTF9VUkxfV0FSTklORz0oY29udGV4dCxjdXN0b21Qb2x5ZmlsbFVybCk9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9VGhlIHByb3ZpZGVkIHBvbHlmaWxsIFVSTCBcIiR7Y3VzdG9tUG9seWZpbGxVcmx9XCIgaXMgaW52YWxpZC4gVGhlIGRlZmF1bHQgcG9seWZpbGwgVVJMIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmA7Y29uc3QgUEFHRV9VTkxPQURfT05fQkVBQ09OX0RJU0FCTEVEX1dBUk5JTkc9Y29udGV4dD0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1QYWdlIFVubG9hZGVkIGV2ZW50IGNhbiBvbmx5IGJlIHRyYWNrZWQgd2hlbiB0aGUgQmVhY29uIHRyYW5zcG9ydCBpcyBhY3RpdmUuIFBsZWFzZSBlbmFibGUgXCJ1c2VCZWFjb25cIiBsb2FkIEFQSSBvcHRpb24uYDtjb25zdCBVTktOT1dOX1BMVUdJTlNfV0FSTklORz0oY29udGV4dCx1bmtub3duUGx1Z2lucyk9PmAke2NvbnRleHR9JHtMT0dfQ09OVEVYVF9TRVBBUkFUT1J9SWdub3JpbmcgdW5rbm93biBwbHVnaW5zOiAke3Vua25vd25QbHVnaW5zLmpvaW4oJywgJyl9LmA7Y29uc3QgQ1VTVE9NX0lOVEVHUkFUSU9OX0NBTk5PVF9CRV9BRERFRF9FUlJPUj0oY29udGV4dCxkZXN0aW5hdGlvbklkKT0+YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn1DYW5ub3QgYWRkIGN1c3RvbSBpbnRlZ3JhdGlvbiBmb3IgZGVzdGluYXRpb24gSUQgXCIke2Rlc3RpbmF0aW9uSWR9XCIgYWZ0ZXIgdGhlIFNESyBpcyBsb2FkZWQuYDtcblxuY29uc3QgREVGQVVMVF9JTlRFR1JBVElPTlNfQ09ORklHPXtBbGw6dHJ1ZX07XG5cbmNvbnN0IENETl9JTlRfRElSPSdqcy1pbnRlZ3JhdGlvbnMnO2NvbnN0IENETl9QTFVHSU5TX0RJUj0ncGx1Z2lucyc7Y29uc3QgVVJMX1BBVFRFUk49bmV3IFJlZ0V4cCgnXihodHRwcz86XFxcXC9cXFxcLyknKy8vIHByb3RvY29sXG4nKCcrJygoKFthLXpBLVpcXFxcZF0oW2EtekEtWlxcXFxkLV0qW2EtekEtWlxcXFxkXSkqKVxcXFwuKStbYS16QS1aXXsyLH18JysvLyBkb21haW4gbmFtZVxuJ2xvY2FsaG9zdHwnKy8vIGxvY2FsaG9zdFxuJygoMjVbMC01XXwyWzAtNF1bMC05XXxbMC0xXT9bMC05XT9bMC05XT8pXFxcXC4pezN9JysvLyBPUiBJUCAodjQpIGFkZHJlc3MgZmlyc3QgMyBvY3RldHNcbicoMjVbMC01XXwyWzAtNF1bMC05XXxbMC0xXT9bMC05XT9bMC05XT8pKScrLy8gbGFzdCBvY3RldCBvZiBJUCBhZGRyZXNzXG4nKScrJyhcXFxcOlxcXFxkKyk/JysvLyBwb3J0XG4nKFxcXFwvWy1hLXpBLVpcXFxcZCVfLn4rXSopKicrLy8gcGF0aFxuJyhcXFxcP1s7JmEtekEtWlxcXFxkJV8ufis9LV0qKT8nKy8vIHF1ZXJ5IHN0cmluZ1xuJyhcXFxcI1stYS16QS1aXFxcXGRfXSopPyQnKS8vIGZyYWdtZW50IGxvY2F0b3JcbjtcblxuY29uc3QgQlVJTERfVFlQRT0nbW9kZXJuJztjb25zdCBTREtfQ0ROX0JBU0VfVVJMPSdodHRwczovL2Nkbi5ydWRkZXJsYWJzLmNvbSc7Y29uc3QgQ0ROX0FSQ0hfVkVSU0lPTl9ESVI9J3YzJztjb25zdCBERUZBVUxUX0lOVEVHUkFUSU9OX1NES1NfVVJMPWAke1NES19DRE5fQkFTRV9VUkx9LyR7Q0ROX0FSQ0hfVkVSU0lPTl9ESVJ9LyR7QlVJTERfVFlQRX0vJHtDRE5fSU5UX0RJUn1gO2NvbnN0IERFRkFVTFRfUExVR0lOU19VUkw9YCR7U0RLX0NETl9CQVNFX1VSTH0vJHtDRE5fQVJDSF9WRVJTSU9OX0RJUn0vJHtCVUlMRF9UWVBFfS8ke0NETl9QTFVHSU5TX0RJUn1gO2NvbnN0IERFRkFVTFRfQ09ORklHX0JFX1VSTD0naHR0cHM6Ly9hcGkucnVkZGVyc3RhY2suY29tJztcblxuY29uc3QgREVGQVVMVF9TVE9SQUdFX0VOQ1JZUFRJT05fVkVSU0lPTj0ndjMnO2NvbnN0IERFRkFVTFRfREFUQV9QTEFORV9FVkVOVFNfVFJBTlNQT1JUPSd4aHInO2NvbnN0IENvbnNlbnRNYW5hZ2Vyc1RvUGx1Z2luTmFtZU1hcD17aXViZW5kYTonSXViZW5kYUNvbnNlbnRNYW5hZ2VyJyxvbmVUcnVzdDonT25lVHJ1c3RDb25zZW50TWFuYWdlcicsa2V0Y2g6J0tldGNoQ29uc2VudE1hbmFnZXInLGN1c3RvbTonQ3VzdG9tQ29uc2VudE1hbmFnZXInfTtjb25zdCBTdG9yYWdlRW5jcnlwdGlvblZlcnNpb25zVG9QbHVnaW5OYW1lTWFwPXtbREVGQVVMVF9TVE9SQUdFX0VOQ1JZUFRJT05fVkVSU0lPTl06J1N0b3JhZ2VFbmNyeXB0aW9uJyxsZWdhY3k6J1N0b3JhZ2VFbmNyeXB0aW9uTGVnYWN5J307Y29uc3QgRGF0YVBsYW5lRXZlbnRzVHJhbnNwb3J0VG9QbHVnaW5OYW1lTWFwPXtbREVGQVVMVF9EQVRBX1BMQU5FX0VWRU5UU19UUkFOU1BPUlRdOidYaHJRdWV1ZScsYmVhY29uOidCZWFjb25RdWV1ZSd9O2NvbnN0IERFRkFVTFRfREFUQV9TRVJWSUNFX0VORFBPSU5UPSdyc2FSZXF1ZXN0Jztjb25zdCBNRVRSSUNTX1NFUlZJQ0VfRU5EUE9JTlQ9J3JzYU1ldHJpY3MnO2NvbnN0IENVU1RPTV9ERVZJQ0VfTU9ERV9ERVNUSU5BVElPTl9ESVNQTEFZX05BTUU9J0N1c3RvbSBEZXZpY2UgTW9kZSc7XG5cbmNvbnN0IGRlZmF1bHRMb2FkT3B0aW9ucz17Y29uZmlnVXJsOkRFRkFVTFRfQ09ORklHX0JFX1VSTCxsb2FkSW50ZWdyYXRpb246dHJ1ZSxzZXNzaW9uczp7YXV0b1RyYWNrOnRydWUsdGltZW91dDpERUZBVUxUX1NFU1NJT05fVElNRU9VVF9NUyxjdXRPZmY6e2VuYWJsZWQ6ZmFsc2V9fSxzYW1lU2l0ZUNvb2tpZTonTGF4Jyxwb2x5ZmlsbElmUmVxdWlyZWQ6dHJ1ZSxpbnRlZ3JhdGlvbnM6REVGQVVMVF9JTlRFR1JBVElPTlNfQ09ORklHLHVzZUJlYWNvbjpmYWxzZSxiZWFjb25RdWV1ZU9wdGlvbnM6e30sZGVzdGluYXRpb25zUXVldWVPcHRpb25zOnt9LHF1ZXVlT3B0aW9uczp7fSxsb2NrSW50ZWdyYXRpb25zVmVyc2lvbjp0cnVlLGxvY2tQbHVnaW5zVmVyc2lvbjp0cnVlLHVhQ2hUcmFja0xldmVsOidub25lJyxwbHVnaW5zOltdLHVzZUdsb2JhbEludGVncmF0aW9uc0NvbmZpZ0luRXZlbnRzOmZhbHNlLGJ1ZmZlckRhdGFQbGFuZUV2ZW50c1VudGlsUmVhZHk6ZmFsc2UsZGF0YVBsYW5lRXZlbnRzQnVmZmVyVGltZW91dDpERUZBVUxUX0RBVEFfUExBTkVfRVZFTlRTX0JVRkZFUl9USU1FT1VUX01TLHN0b3JhZ2U6e2VuY3J5cHRpb246e3ZlcnNpb246REVGQVVMVF9TVE9SQUdFX0VOQ1JZUFRJT05fVkVSU0lPTn0sbWlncmF0ZTp0cnVlLGNvb2tpZTp7fX0sc2VuZEFkYmxvY2tQYWdlOmZhbHNlLHNhbWVEb21haW5Db29raWVzT25seTpmYWxzZSxzZWN1cmVDb29raWU6ZmFsc2Usc2VuZEFkYmxvY2tQYWdlT3B0aW9uczp7fSx1c2VTZXJ2ZXJTaWRlQ29va2llczpmYWxzZX07Y29uc3QgbG9hZE9wdGlvbnNTdGF0ZT1kKGNsb25lKGRlZmF1bHRMb2FkT3B0aW9ucykpO1xuXG5jb25zdCBERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVM9ZGVlcEZyZWV6ZSh7dXNlcklkOicnLHVzZXJUcmFpdHM6e30sYW5vbnltb3VzSWQ6JycsZ3JvdXBJZDonJyxncm91cFRyYWl0czp7fSxpbml0aWFsUmVmZXJyZXI6JycsaW5pdGlhbFJlZmVycmluZ0RvbWFpbjonJyxzZXNzaW9uSW5mbzp7fSxhdXRoVG9rZW46bnVsbH0pO2NvbnN0IERFRkFVTFRfUkVTRVRfT1BUSU9OUz1kZWVwRnJlZXplKHtlbnRyaWVzOnt1c2VySWQ6dHJ1ZSx1c2VyVHJhaXRzOnRydWUsZ3JvdXBJZDp0cnVlLGdyb3VwVHJhaXRzOnRydWUsc2Vzc2lvbkluZm86dHJ1ZSxhdXRoVG9rZW46dHJ1ZSwvLyBUaGVzZSBhcmUgbm90IHJlc2V0IGJ5IGRlZmF1bHRcbmFub255bW91c0lkOmZhbHNlLGluaXRpYWxSZWZlcnJlcjpmYWxzZSxpbml0aWFsUmVmZXJyaW5nRG9tYWluOmZhbHNlfX0pO2NvbnN0IFNFUlZFUl9TSURFX0NPT0tJRVNfREVCT1VOQ0VfVElNRT0xMDsvLyBtaWxsaXNlY29uZHNcblxuY29uc3Qgc2Vzc2lvblN0YXRlPXt1c2VySWQ6ZChERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVMudXNlcklkKSx1c2VyVHJhaXRzOmQoREVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLnVzZXJUcmFpdHMpLGFub255bW91c0lkOmQoREVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLmFub255bW91c0lkKSxncm91cElkOmQoREVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLmdyb3VwSWQpLGdyb3VwVHJhaXRzOmQoREVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLmdyb3VwVHJhaXRzKSxpbml0aWFsUmVmZXJyZXI6ZChERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVMuaW5pdGlhbFJlZmVycmVyKSxpbml0aWFsUmVmZXJyaW5nRG9tYWluOmQoREVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLmluaXRpYWxSZWZlcnJpbmdEb21haW4pLHNlc3Npb25JbmZvOmQoREVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLnNlc3Npb25JbmZvKSxhdXRoVG9rZW46ZChERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVMuYXV0aFRva2VuKX07XG5cbmNvbnN0IGNhcGFiaWxpdGllc1N0YXRlPXtpc09ubGluZTpkKHRydWUpLHN0b3JhZ2U6e2lzTG9jYWxTdG9yYWdlQXZhaWxhYmxlOmQoZmFsc2UpLGlzQ29va2llU3RvcmFnZUF2YWlsYWJsZTpkKGZhbHNlKSxpc1Nlc3Npb25TdG9yYWdlQXZhaWxhYmxlOmQoZmFsc2UpfSxpc0JlYWNvbkF2YWlsYWJsZTpkKGZhbHNlKSxpc0xlZ2FjeURPTTpkKGZhbHNlKSxpc1VhQ0hBdmFpbGFibGU6ZChmYWxzZSksaXNDcnlwdG9BdmFpbGFibGU6ZChmYWxzZSksaXNJRTExOmQoZmFsc2UpLGlzQWRCbG9ja2VyRGV0ZWN0aW9uSW5Qcm9ncmVzczpkKGZhbHNlKSxpc0FkQmxvY2tlZDpkKHVuZGVmaW5lZCksY3NwQmxvY2tlZFVSTHM6ZChbXSl9O1xuXG5jb25zdCByZXBvcnRpbmdTdGF0ZT17aXNFcnJvclJlcG9ydGluZ0VuYWJsZWQ6ZChmYWxzZSksaXNNZXRyaWNzUmVwb3J0aW5nRW5hYmxlZDpkKGZhbHNlKSxicmVhZGNydW1iczpkKFtdKX07XG5cbmNvbnN0IHNvdXJjZUNvbmZpZ1N0YXRlPWQodW5kZWZpbmVkKTtcblxuY29uc3QgbGlmZWN5Y2xlU3RhdGU9e2FjdGl2ZURhdGFwbGFuZVVybDpkKHVuZGVmaW5lZCksaW50ZWdyYXRpb25zQ0ROUGF0aDpkKERFRkFVTFRfSU5URUdSQVRJT05fU0RLU19VUkwpLHBsdWdpbnNDRE5QYXRoOmQoREVGQVVMVF9QTFVHSU5TX1VSTCksc291cmNlQ29uZmlnVXJsOmQodW5kZWZpbmVkKSxzdGF0dXM6ZCh1bmRlZmluZWQpLGluaXRpYWxpemVkOmQoZmFsc2UpLGxvZ0xldmVsOmQoUE9TVF9MT0FEX0xPR19MRVZFTCksbG9hZGVkOmQoZmFsc2UpLHJlYWR5Q2FsbGJhY2tzOmQoW10pLHdyaXRlS2V5OmQodW5kZWZpbmVkKSxkYXRhUGxhbmVVcmw6ZCh1bmRlZmluZWQpLHNhZmVBbmFseXRpY3NJbnN0YW5jZTpkKHVuZGVmaW5lZCl9O1xuXG5jb25zdCBjb25zZW50c1N0YXRlPXtlbmFibGVkOmQoZmFsc2UpLGluaXRpYWxpemVkOmQoZmFsc2UpLGRhdGE6ZCh7fSksYWN0aXZlQ29uc2VudE1hbmFnZXJQbHVnaW5OYW1lOmQodW5kZWZpbmVkKSxwcmVDb25zZW50OmQoe2VuYWJsZWQ6ZmFsc2V9KSxwb3N0Q29uc2VudDpkKHt9KSxyZXNvbHV0aW9uU3RyYXRlZ3k6ZCgnYW5kJykscHJvdmlkZXI6ZCh1bmRlZmluZWQpLG1ldGFkYXRhOmQodW5kZWZpbmVkKX07XG5cbmNvbnN0IG1ldHJpY3NTdGF0ZT17cmV0cmllczpkKDApLGRyb3BwZWQ6ZCgwKSxzZW50OmQoMCkscXVldWVkOmQoMCksdHJpZ2dlcmVkOmQoMCksbWV0cmljc1NlcnZpY2VVcmw6ZCh1bmRlZmluZWQpfTtcblxuY29uc3QgY29udGV4dFN0YXRlPXthcHA6ZCh7bmFtZTpBUFBfTkFNRSxuYW1lc3BhY2U6QVBQX05BTUVTUEFDRSx2ZXJzaW9uOkFQUF9WRVJTSU9OLGluc3RhbGxUeXBlOk1PRFVMRV9UWVBFfSksdHJhaXRzOmQobnVsbCksbGlicmFyeTpkKHtuYW1lOkFQUF9OQU1FLHZlcnNpb246QVBQX1ZFUlNJT04sc25pcHBldFZlcnNpb246Z2xvYmFsVGhpcy5SdWRkZXJTbmlwcGV0VmVyc2lvbn0pLHVzZXJBZ2VudDpkKG51bGwpLGRldmljZTpkKG51bGwpLG5ldHdvcms6ZChudWxsKSxvczpkKHtuYW1lOicnLHZlcnNpb246Jyd9KSxsb2NhbGU6ZChudWxsKSxzY3JlZW46ZCh7ZGVuc2l0eTowLHdpZHRoOjAsaGVpZ2h0OjAsaW5uZXJXaWR0aDowLGlubmVySGVpZ2h0OjB9KSwndWEtY2gnOmQodW5kZWZpbmVkKSx0aW1lem9uZTpkKHVuZGVmaW5lZCl9O1xuXG5jb25zdCBuYXRpdmVEZXN0aW5hdGlvbnNTdGF0ZT17Y29uZmlndXJlZERlc3RpbmF0aW9uczpkKFtdKSxhY3RpdmVEZXN0aW5hdGlvbnM6ZChbXSksbG9hZE9ubHlJbnRlZ3JhdGlvbnM6ZCh7fSksZmFpbGVkRGVzdGluYXRpb25zOmQoW10pLGxvYWRJbnRlZ3JhdGlvbjpkKHRydWUpLGluaXRpYWxpemVkRGVzdGluYXRpb25zOmQoW10pLGNsaWVudERlc3RpbmF0aW9uc1JlYWR5OmQoZmFsc2UpLGludGVncmF0aW9uc0NvbmZpZzpkKHt9KX07XG5cbmNvbnN0IGV2ZW50QnVmZmVyU3RhdGU9e3RvQmVQcm9jZXNzZWRBcnJheTpkKFtdKSxyZWFkeUNhbGxiYWNrc0FycmF5OmQoW10pfTtcblxuY29uc3QgcGx1Z2luc1N0YXRlPXtyZWFkeTpkKGZhbHNlKSxsb2FkZWRQbHVnaW5zOmQoW10pLGZhaWxlZFBsdWdpbnM6ZChbXSkscGx1Z2luc1RvTG9hZEZyb21Db25maWc6ZChbXSksYWN0aXZlUGx1Z2luczpkKFtdKSx0b3RhbFBsdWdpbnNUb0xvYWQ6ZCgwKX07XG5cbmNvbnN0IHN0b3JhZ2VTdGF0ZT17ZW5jcnlwdGlvblBsdWdpbk5hbWU6ZCh1bmRlZmluZWQpLG1pZ3JhdGU6ZChmYWxzZSksdHlwZTpkKHVuZGVmaW5lZCksY29va2llOmQodW5kZWZpbmVkKSxlbnRyaWVzOmQoe30pLHRydWx5QW5vbnltb3VzVHJhY2tpbmc6ZChmYWxzZSl9O1xuXG5jb25zdCBzZXJ2ZXJTaWRlQ29va2llc1N0YXRlPXtpc0VuYWJsZWRTZXJ2ZXJTaWRlQ29va2llczpkKGZhbHNlKSxkYXRhU2VydmljZVVybDpkKHVuZGVmaW5lZCl9O1xuXG5jb25zdCBkYXRhUGxhbmVFdmVudHNTdGF0ZT17ZXZlbnRzUXVldWVQbHVnaW5OYW1lOmQodW5kZWZpbmVkKSxkZWxpdmVyeUVuYWJsZWQ6ZCh0cnVlKS8vIERlbGl2ZXJ5IHNob3VsZCBhbHdheXMgaGFwcGVuXG59O1xuXG5jb25zdCBhdXRvVHJhY2tTdGF0ZT17ZW5hYmxlZDpkKGZhbHNlKSxwYWdlTGlmZWN5Y2xlOntlbmFibGVkOmQoZmFsc2UpLHBhZ2VWaWV3SWQ6ZCh1bmRlZmluZWQpLHBhZ2VMb2FkZWRUaW1lc3RhbXA6ZCh1bmRlZmluZWQpfX07XG5cbmNvbnN0IGRlZmF1bHRTdGF0ZVZhbHVlcz17Y2FwYWJpbGl0aWVzOmNhcGFiaWxpdGllc1N0YXRlLGNvbnNlbnRzOmNvbnNlbnRzU3RhdGUsY29udGV4dDpjb250ZXh0U3RhdGUsZXZlbnRCdWZmZXI6ZXZlbnRCdWZmZXJTdGF0ZSxsaWZlY3ljbGU6bGlmZWN5Y2xlU3RhdGUsbG9hZE9wdGlvbnM6bG9hZE9wdGlvbnNTdGF0ZSxtZXRyaWNzOm1ldHJpY3NTdGF0ZSxuYXRpdmVEZXN0aW5hdGlvbnM6bmF0aXZlRGVzdGluYXRpb25zU3RhdGUscGx1Z2luczpwbHVnaW5zU3RhdGUscmVwb3J0aW5nOnJlcG9ydGluZ1N0YXRlLHNlc3Npb246c2Vzc2lvblN0YXRlLHNvdXJjZTpzb3VyY2VDb25maWdTdGF0ZSxzdG9yYWdlOnN0b3JhZ2VTdGF0ZSxzZXJ2ZXJDb29raWVzOnNlcnZlclNpZGVDb29raWVzU3RhdGUsZGF0YVBsYW5lRXZlbnRzOmRhdGFQbGFuZUV2ZW50c1N0YXRlLGF1dG9UcmFjazphdXRvVHJhY2tTdGF0ZX07Y29uc3Qgc3RhdGU9ey4uLmNsb25lKGRlZmF1bHRTdGF0ZVZhbHVlcyl9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgZXJyb3JTdGFja1BhcnNlciQxID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIHN0YWNrZnJhbWUkMSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBzdGFja2ZyYW1lPXN0YWNrZnJhbWUkMS5leHBvcnRzO3ZhciBoYXNSZXF1aXJlZFN0YWNrZnJhbWU7ZnVuY3Rpb24gcmVxdWlyZVN0YWNrZnJhbWUoKXtpZihoYXNSZXF1aXJlZFN0YWNrZnJhbWUpcmV0dXJuIHN0YWNrZnJhbWUkMS5leHBvcnRzO2hhc1JlcXVpcmVkU3RhY2tmcmFtZT0xOyhmdW5jdGlvbihtb2R1bGUsZXhwb3J0cyQxKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXsvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL3ttb2R1bGUuZXhwb3J0cz1mYWN0b3J5KCk7fX0pKHN0YWNrZnJhbWUsZnVuY3Rpb24oKXtmdW5jdGlvbiBfaXNOdW1iZXIobil7cmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSYmaXNGaW5pdGUobik7fWZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cil7cmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStzdHIuc3Vic3RyaW5nKDEpO31mdW5jdGlvbiBfZ2V0dGVyKHApe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0aGlzW3BdO307fXZhciBib29sZWFuUHJvcHM9Wydpc0NvbnN0cnVjdG9yJywnaXNFdmFsJywnaXNOYXRpdmUnLCdpc1RvcGxldmVsJ107dmFyIG51bWVyaWNQcm9wcz1bJ2NvbHVtbk51bWJlcicsJ2xpbmVOdW1iZXInXTt2YXIgc3RyaW5nUHJvcHM9WydmaWxlTmFtZScsJ2Z1bmN0aW9uTmFtZScsJ3NvdXJjZSddO3ZhciBhcnJheVByb3BzPVsnYXJncyddO3ZhciBvYmplY3RQcm9wcz1bJ2V2YWxPcmlnaW4nXTt2YXIgcHJvcHM9Ym9vbGVhblByb3BzLmNvbmNhdChudW1lcmljUHJvcHMsc3RyaW5nUHJvcHMsYXJyYXlQcm9wcyxvYmplY3RQcm9wcyk7ZnVuY3Rpb24gU3RhY2tGcmFtZShvYmope2lmKCFvYmopcmV0dXJuO2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7aWYob2JqW3Byb3BzW2ldXSE9PXVuZGVmaW5lZCl7dGhpc1snc2V0JytfY2FwaXRhbGl6ZShwcm9wc1tpXSldKG9ialtwcm9wc1tpXV0pO319fVN0YWNrRnJhbWUucHJvdG90eXBlPXtnZXRBcmdzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJnczt9LHNldEFyZ3M6ZnVuY3Rpb24odil7aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpIT09J1tvYmplY3QgQXJyYXldJyl7dGhyb3cgbmV3IFR5cGVFcnJvcignQXJncyBtdXN0IGJlIGFuIEFycmF5Jyk7fXRoaXMuYXJncz12O30sZ2V0RXZhbE9yaWdpbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV2YWxPcmlnaW47fSxzZXRFdmFsT3JpZ2luOmZ1bmN0aW9uKHYpe2lmKHYgaW5zdGFuY2VvZiBTdGFja0ZyYW1lKXt0aGlzLmV2YWxPcmlnaW49djt9ZWxzZSBpZih2IGluc3RhbmNlb2YgT2JqZWN0KXt0aGlzLmV2YWxPcmlnaW49bmV3IFN0YWNrRnJhbWUodik7fWVsc2Uge3Rocm93IG5ldyBUeXBlRXJyb3IoJ0V2YWwgT3JpZ2luIG11c3QgYmUgYW4gT2JqZWN0IG9yIFN0YWNrRnJhbWUnKTt9fSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciBmaWxlTmFtZT10aGlzLmdldEZpbGVOYW1lKCl8fCcnO3ZhciBsaW5lTnVtYmVyPXRoaXMuZ2V0TGluZU51bWJlcigpfHwnJzt2YXIgY29sdW1uTnVtYmVyPXRoaXMuZ2V0Q29sdW1uTnVtYmVyKCl8fCcnO3ZhciBmdW5jdGlvbk5hbWU9dGhpcy5nZXRGdW5jdGlvbk5hbWUoKXx8Jyc7aWYodGhpcy5nZXRJc0V2YWwoKSl7aWYoZmlsZU5hbWUpe3JldHVybiAnW2V2YWxdICgnK2ZpbGVOYW1lKyc6JytsaW5lTnVtYmVyKyc6Jytjb2x1bW5OdW1iZXIrJyknO31yZXR1cm4gJ1tldmFsXTonK2xpbmVOdW1iZXIrJzonK2NvbHVtbk51bWJlcjt9aWYoZnVuY3Rpb25OYW1lKXtyZXR1cm4gZnVuY3Rpb25OYW1lKycgKCcrZmlsZU5hbWUrJzonK2xpbmVOdW1iZXIrJzonK2NvbHVtbk51bWJlcisnKSc7fXJldHVybiBmaWxlTmFtZSsnOicrbGluZU51bWJlcisnOicrY29sdW1uTnVtYmVyO319O1N0YWNrRnJhbWUuZnJvbVN0cmluZz1mdW5jdGlvbiBTdGFja0ZyYW1lJCRmcm9tU3RyaW5nKHN0cil7dmFyIGFyZ3NTdGFydEluZGV4PXN0ci5pbmRleE9mKCcoJyk7dmFyIGFyZ3NFbmRJbmRleD1zdHIubGFzdEluZGV4T2YoJyknKTt2YXIgZnVuY3Rpb25OYW1lPXN0ci5zdWJzdHJpbmcoMCxhcmdzU3RhcnRJbmRleCk7dmFyIGFyZ3M9c3RyLnN1YnN0cmluZyhhcmdzU3RhcnRJbmRleCsxLGFyZ3NFbmRJbmRleCkuc3BsaXQoJywnKTt2YXIgbG9jYXRpb25TdHJpbmc9c3RyLnN1YnN0cmluZyhhcmdzRW5kSW5kZXgrMSk7aWYobG9jYXRpb25TdHJpbmcuaW5kZXhPZignQCcpPT09MCl7dmFyIHBhcnRzPS9AKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLy5leGVjKGxvY2F0aW9uU3RyaW5nLCcnKTt2YXIgZmlsZU5hbWU9cGFydHNbMV07dmFyIGxpbmVOdW1iZXI9cGFydHNbMl07dmFyIGNvbHVtbk51bWJlcj1wYXJ0c1szXTt9cmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtmdW5jdGlvbk5hbWU6ZnVuY3Rpb25OYW1lLGFyZ3M6YXJnc3x8dW5kZWZpbmVkLGZpbGVOYW1lOmZpbGVOYW1lLGxpbmVOdW1iZXI6bGluZU51bWJlcnx8dW5kZWZpbmVkLGNvbHVtbk51bWJlcjpjb2x1bW5OdW1iZXJ8fHVuZGVmaW5lZH0pO307Zm9yKHZhciBpPTA7aTxib29sZWFuUHJvcHMubGVuZ3RoO2krKyl7U3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcrX2NhcGl0YWxpemUoYm9vbGVhblByb3BzW2ldKV09X2dldHRlcihib29sZWFuUHJvcHNbaV0pO1N0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnK19jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldPWZ1bmN0aW9uKHApe3JldHVybiBmdW5jdGlvbih2KXt0aGlzW3BdPUJvb2xlYW4odik7fTt9KGJvb2xlYW5Qcm9wc1tpXSk7fWZvcih2YXIgaj0wO2o8bnVtZXJpY1Byb3BzLmxlbmd0aDtqKyspe1N0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnK19jYXBpdGFsaXplKG51bWVyaWNQcm9wc1tqXSldPV9nZXR0ZXIobnVtZXJpY1Byb3BzW2pdKTtTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JytfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXT1mdW5jdGlvbihwKXtyZXR1cm4gZnVuY3Rpb24odil7aWYoIV9pc051bWJlcih2KSl7dGhyb3cgbmV3IFR5cGVFcnJvcihwKycgbXVzdCBiZSBhIE51bWJlcicpO310aGlzW3BdPU51bWJlcih2KTt9O30obnVtZXJpY1Byb3BzW2pdKTt9Zm9yKHZhciBrPTA7azxzdHJpbmdQcm9wcy5sZW5ndGg7aysrKXtTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JytfY2FwaXRhbGl6ZShzdHJpbmdQcm9wc1trXSldPV9nZXR0ZXIoc3RyaW5nUHJvcHNba10pO1N0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnK19jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV09ZnVuY3Rpb24ocCl7cmV0dXJuIGZ1bmN0aW9uKHYpe3RoaXNbcF09U3RyaW5nKHYpO307fShzdHJpbmdQcm9wc1trXSk7fXJldHVybiBTdGFja0ZyYW1lO30pO30pKHN0YWNrZnJhbWUkMSk7cmV0dXJuIHN0YWNrZnJhbWUkMS5leHBvcnRzO31cblxudmFyIGVycm9yU3RhY2tQYXJzZXI9ZXJyb3JTdGFja1BhcnNlciQxLmV4cG9ydHM7dmFyIGhhc1JlcXVpcmVkRXJyb3JTdGFja1BhcnNlcjtmdW5jdGlvbiByZXF1aXJlRXJyb3JTdGFja1BhcnNlcigpe2lmKGhhc1JlcXVpcmVkRXJyb3JTdGFja1BhcnNlcilyZXR1cm4gZXJyb3JTdGFja1BhcnNlciQxLmV4cG9ydHM7aGFzUmVxdWlyZWRFcnJvclN0YWNrUGFyc2VyPTE7KGZ1bmN0aW9uKG1vZHVsZSxleHBvcnRzJDEpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpey8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICove21vZHVsZS5leHBvcnRzPWZhY3RvcnkocmVxdWlyZVN0YWNrZnJhbWUoKSk7fX0pKGVycm9yU3RhY2tQYXJzZXIsZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlcihTdGFja0ZyYW1lKXt2YXIgRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQPS8oXnxAKVxcUys6XFxkKy87dmFyIENIUk9NRV9JRV9TVEFDS19SRUdFWFA9L15cXHMqYXQgLiooXFxTKzpcXGQrfFxcKG5hdGl2ZVxcKSkvbTt2YXIgU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUD0vXihldmFsQCk/KFxcW25hdGl2ZSBjb2RlXSk/JC87cmV0dXJuIHsvKipcblx0XHQgICAgICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgZXh0cmFjdCB0aGUgbW9zdCBpbmZvcm1hdGlvbiBmcm9tIGl0LlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIG9iamVjdFxuXHRcdCAgICAgICAgICogQHJldHVybiB7QXJyYXl9IG9mIFN0YWNrRnJhbWVzXG5cdFx0ICAgICAgICAgKi9wYXJzZTpmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZShlcnJvcil7aWYodHlwZW9mIGVycm9yLnN0YWNrdHJhY2UhPT0ndW5kZWZpbmVkJ3x8dHlwZW9mIGVycm9yWydvcGVyYSNzb3VyY2Vsb2MnXSE9PSd1bmRlZmluZWQnKXtyZXR1cm4gdGhpcy5wYXJzZU9wZXJhKGVycm9yKTt9ZWxzZSBpZihlcnJvci5zdGFjayYmZXJyb3Iuc3RhY2subWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCkpe3JldHVybiB0aGlzLnBhcnNlVjhPcklFKGVycm9yKTt9ZWxzZSBpZihlcnJvci5zdGFjayl7cmV0dXJuIHRoaXMucGFyc2VGRk9yU2FmYXJpKGVycm9yKTt9ZWxzZSB7dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgZ2l2ZW4gRXJyb3Igb2JqZWN0Jyk7fX0sLy8gU2VwYXJhdGUgbGluZSBhbmQgY29sdW1uIG51bWJlcnMgZnJvbSBhIHN0cmluZyBvZiB0aGUgZm9ybTogKFVSSTpMaW5lOkNvbHVtbilcbmV4dHJhY3RMb2NhdGlvbjpmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRleHRyYWN0TG9jYXRpb24odXJsTGlrZSl7Ly8gRmFpbC1mYXN0IGJ1dCByZXR1cm4gbG9jYXRpb25zIGxpa2UgXCIobmF0aXZlKVwiXG5pZih1cmxMaWtlLmluZGV4T2YoJzonKT09PS0xKXtyZXR1cm4gW3VybExpa2VdO312YXIgcmVnRXhwPS8oLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvO3ZhciBwYXJ0cz1yZWdFeHAuZXhlYyh1cmxMaWtlLnJlcGxhY2UoL1soKV0vZywnJykpO3JldHVybiBbcGFydHNbMV0scGFydHNbMl18fHVuZGVmaW5lZCxwYXJ0c1szXXx8dW5kZWZpbmVkXTt9LHBhcnNlVjhPcklFOmZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlVjhPcklFKGVycm9yKXt2YXIgZmlsdGVyZWQ9ZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKXtyZXR1cm4gISFsaW5lLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApO30sdGhpcyk7cmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKXtpZihsaW5lLmluZGV4T2YoJyhldmFsICcpPi0xKXsvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG5saW5lPWxpbmUucmVwbGFjZSgvZXZhbCBjb2RlL2csJ2V2YWwnKS5yZXBsYWNlKC8oXFwoZXZhbCBhdCBbXigpXSopfCgsLiokKS9nLCcnKTt9dmFyIHNhbml0aXplZExpbmU9bGluZS5yZXBsYWNlKC9eXFxzKy8sJycpLnJlcGxhY2UoL1xcKGV2YWwgY29kZS9nLCcoJykucmVwbGFjZSgvXi4qP1xccysvLCcnKTsvLyBjYXB0dXJlIGFuZCBwcmVzZXZlIHRoZSBwYXJlbnRoZXNpemVkIGxvY2F0aW9uIFwiKC9mb28vbXkgYmFyLmpzOjEyOjg3KVwiIGluXG4vLyBjYXNlIGl0IGhhcyBzcGFjZXMgaW4gaXQsIGFzIHRoZSBzdHJpbmcgaXMgc3BsaXQgb24gXFxzKyBsYXRlciBvblxudmFyIGxvY2F0aW9uPXNhbml0aXplZExpbmUubWF0Y2goLyAoXFwoLitcXCkkKS8pOy8vIHJlbW92ZSB0aGUgcGFyZW50aGVzaXplZCBsb2NhdGlvbiBmcm9tIHRoZSBsaW5lLCBpZiBpdCB3YXMgbWF0Y2hlZFxuc2FuaXRpemVkTGluZT1sb2NhdGlvbj9zYW5pdGl6ZWRMaW5lLnJlcGxhY2UobG9jYXRpb25bMF0sJycpOnNhbml0aXplZExpbmU7Ly8gaWYgYSBsb2NhdGlvbiB3YXMgbWF0Y2hlZCwgcGFzcyBpdCB0byBleHRyYWN0TG9jYXRpb24oKSBvdGhlcndpc2UgcGFzcyBhbGwgc2FuaXRpemVkTGluZVxuLy8gYmVjYXVzZSB0aGlzIGxpbmUgZG9lc24ndCBoYXZlIGZ1bmN0aW9uIG5hbWVcbnZhciBsb2NhdGlvblBhcnRzPXRoaXMuZXh0cmFjdExvY2F0aW9uKGxvY2F0aW9uP2xvY2F0aW9uWzFdOnNhbml0aXplZExpbmUpO3ZhciBmdW5jdGlvbk5hbWU9bG9jYXRpb24mJnNhbml0aXplZExpbmV8fHVuZGVmaW5lZDt2YXIgZmlsZU5hbWU9WydldmFsJywnPGFub255bW91cz4nXS5pbmRleE9mKGxvY2F0aW9uUGFydHNbMF0pPi0xP3VuZGVmaW5lZDpsb2NhdGlvblBhcnRzWzBdO3JldHVybiBuZXcgU3RhY2tGcmFtZSh7ZnVuY3Rpb25OYW1lOmZ1bmN0aW9uTmFtZSxmaWxlTmFtZTpmaWxlTmFtZSxsaW5lTnVtYmVyOmxvY2F0aW9uUGFydHNbMV0sY29sdW1uTnVtYmVyOmxvY2F0aW9uUGFydHNbMl0sc291cmNlOmxpbmV9KTt9LHRoaXMpO30scGFyc2VGRk9yU2FmYXJpOmZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlRkZPclNhZmFyaShlcnJvcil7dmFyIGZpbHRlcmVkPWVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24obGluZSl7cmV0dXJuICFsaW5lLm1hdGNoKFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFApO30sdGhpcyk7cmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKXsvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG5pZihsaW5lLmluZGV4T2YoJyA+IGV2YWwnKT4tMSl7bGluZT1saW5lLnJlcGxhY2UoLyBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsOlxcZCs6XFxkKy9nLCc6JDEnKTt9aWYobGluZS5pbmRleE9mKCdAJyk9PT0tMSYmbGluZS5pbmRleE9mKCc6Jyk9PT0tMSl7Ly8gU2FmYXJpIGV2YWwgZnJhbWVzIG9ubHkgaGF2ZSBmdW5jdGlvbiBuYW1lcyBhbmQgbm90aGluZyBlbHNlXG5yZXR1cm4gbmV3IFN0YWNrRnJhbWUoe2Z1bmN0aW9uTmFtZTpsaW5lfSk7fWVsc2Uge3ZhciBmdW5jdGlvbk5hbWVSZWdleD0vKCguKlwiLitcIlteQF0qKT9bXkBdKikoPzpAKS87dmFyIG1hdGNoZXM9bGluZS5tYXRjaChmdW5jdGlvbk5hbWVSZWdleCk7dmFyIGZ1bmN0aW9uTmFtZT1tYXRjaGVzJiZtYXRjaGVzWzFdP21hdGNoZXNbMV06dW5kZWZpbmVkO3ZhciBsb2NhdGlvblBhcnRzPXRoaXMuZXh0cmFjdExvY2F0aW9uKGxpbmUucmVwbGFjZShmdW5jdGlvbk5hbWVSZWdleCwnJykpO3JldHVybiBuZXcgU3RhY2tGcmFtZSh7ZnVuY3Rpb25OYW1lOmZ1bmN0aW9uTmFtZSxmaWxlTmFtZTpsb2NhdGlvblBhcnRzWzBdLGxpbmVOdW1iZXI6bG9jYXRpb25QYXJ0c1sxXSxjb2x1bW5OdW1iZXI6bG9jYXRpb25QYXJ0c1syXSxzb3VyY2U6bGluZX0pO319LHRoaXMpO30scGFyc2VPcGVyYTpmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhKGUpe2lmKCFlLnN0YWNrdHJhY2V8fGUubWVzc2FnZS5pbmRleE9mKCdcXG4nKT4tMSYmZS5tZXNzYWdlLnNwbGl0KCdcXG4nKS5sZW5ndGg+ZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKS5sZW5ndGgpe3JldHVybiB0aGlzLnBhcnNlT3BlcmE5KGUpO31lbHNlIGlmKCFlLnN0YWNrKXtyZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTAoZSk7fWVsc2Uge3JldHVybiB0aGlzLnBhcnNlT3BlcmExMShlKTt9fSxwYXJzZU9wZXJhOTpmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhOShlKXt2YXIgbGluZVJFPS9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspL2k7dmFyIGxpbmVzPWUubWVzc2FnZS5zcGxpdCgnXFxuJyk7dmFyIHJlc3VsdD1bXTtmb3IodmFyIGk9MixsZW49bGluZXMubGVuZ3RoO2k8bGVuO2krPTIpe3ZhciBtYXRjaD1saW5lUkUuZXhlYyhsaW5lc1tpXSk7aWYobWF0Y2gpe3Jlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHtmaWxlTmFtZTptYXRjaFsyXSxsaW5lTnVtYmVyOm1hdGNoWzFdLHNvdXJjZTpsaW5lc1tpXX0pKTt9fXJldHVybiByZXN1bHQ7fSxwYXJzZU9wZXJhMTA6ZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTEwKGUpe3ZhciBsaW5lUkU9L0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykoPzo6IEluIGZ1bmN0aW9uIChcXFMrKSk/JC9pO3ZhciBsaW5lcz1lLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpO3ZhciByZXN1bHQ9W107Zm9yKHZhciBpPTAsbGVuPWxpbmVzLmxlbmd0aDtpPGxlbjtpKz0yKXt2YXIgbWF0Y2g9bGluZVJFLmV4ZWMobGluZXNbaV0pO2lmKG1hdGNoKXtyZXN1bHQucHVzaChuZXcgU3RhY2tGcmFtZSh7ZnVuY3Rpb25OYW1lOm1hdGNoWzNdfHx1bmRlZmluZWQsZmlsZU5hbWU6bWF0Y2hbMl0sbGluZU51bWJlcjptYXRjaFsxXSxzb3VyY2U6bGluZXNbaV19KSk7fX1yZXR1cm4gcmVzdWx0O30sLy8gT3BlcmEgMTAuNjUrIEVycm9yLnN0YWNrIHZlcnkgc2ltaWxhciB0byBGRi9TYWZhcmlcbnBhcnNlT3BlcmExMTpmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhMTEoZXJyb3Ipe3ZhciBmaWx0ZXJlZD1lcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpe3JldHVybiAhIWxpbmUubWF0Y2goRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQKSYmIWxpbmUubWF0Y2goL15FcnJvciBjcmVhdGVkIGF0Lyk7fSx0aGlzKTtyZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpe3ZhciB0b2tlbnM9bGluZS5zcGxpdCgnQCcpO3ZhciBsb2NhdGlvblBhcnRzPXRoaXMuZXh0cmFjdExvY2F0aW9uKHRva2Vucy5wb3AoKSk7dmFyIGZ1bmN0aW9uQ2FsbD10b2tlbnMuc2hpZnQoKXx8Jyc7dmFyIGZ1bmN0aW9uTmFtZT1mdW5jdGlvbkNhbGwucmVwbGFjZSgvPGFub255bW91cyBmdW5jdGlvbig6IChcXHcrKSk/Pi8sJyQyJykucmVwbGFjZSgvXFwoW14pXSpcXCkvZywnJyl8fHVuZGVmaW5lZDt2YXIgYXJnc1JhdztpZihmdW5jdGlvbkNhbGwubWF0Y2goL1xcKChbXildKilcXCkvKSl7YXJnc1Jhdz1mdW5jdGlvbkNhbGwucmVwbGFjZSgvXlteKF0rXFwoKFteKV0qKVxcKSQvLCckMScpO312YXIgYXJncz1hcmdzUmF3PT09dW5kZWZpbmVkfHxhcmdzUmF3PT09J1thcmd1bWVudHMgbm90IGF2YWlsYWJsZV0nP3VuZGVmaW5lZDphcmdzUmF3LnNwbGl0KCcsJyk7cmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtmdW5jdGlvbk5hbWU6ZnVuY3Rpb25OYW1lLGFyZ3M6YXJncyxmaWxlTmFtZTpsb2NhdGlvblBhcnRzWzBdLGxpbmVOdW1iZXI6bG9jYXRpb25QYXJ0c1sxXSxjb2x1bW5OdW1iZXI6bG9jYXRpb25QYXJ0c1syXSxzb3VyY2U6bGluZX0pO30sdGhpcyk7fX07fSk7fSkoZXJyb3JTdGFja1BhcnNlciQxKTtyZXR1cm4gZXJyb3JTdGFja1BhcnNlciQxLmV4cG9ydHM7fVxuXG52YXIgZXJyb3JTdGFja1BhcnNlckV4cG9ydHMgPSByZXF1aXJlRXJyb3JTdGFja1BhcnNlcigpO1xuY29uc3QgRXJyb3JTdGFja1BhcnNlciA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhlcnJvclN0YWNrUGFyc2VyRXhwb3J0cyk7XG5cbmNvbnN0IEdMT0JBTF9DT0RFPSdnbG9iYWwgY29kZSc7Y29uc3Qgbm9ybWFsaXplRnVuY3Rpb25OYW1lPW5hbWU9PntpZihpc0RlZmluZWQobmFtZSkpe3JldHVybiAvXmdsb2JhbCBjb2RlJC9pLnRlc3QobmFtZSk/R0xPQkFMX0NPREU6bmFtZTt9cmV0dXJuIG5hbWU7fTsvKipcbiAqIFRha2VzIGEgc3RhY2t0cmFjZS5qcyBzdHlsZSBzdGFja2ZyYW1lIChodHRwczovL2dpdGh1Yi5jb20vc3RhY2t0cmFjZWpzL3N0YWNrZnJhbWUpXG4gKiBhbmQgcmV0dXJucyBhIEJ1Z3NuYWcgY29tcGF0aWJsZSBzdGFja2ZyYW1lIChodHRwczovL2RvY3MuYnVnc25hZy5jb20vYXBpL2Vycm9yLXJlcG9ydGluZy8janNvbi1wYXlsb2FkKVxuICogQHBhcmFtIGZyYW1lXG4gKiBAcmV0dXJuc1xuICovY29uc3QgZm9ybWF0U3RhY2tmcmFtZT1mcmFtZT0+e2NvbnN0IGY9e2ZpbGU6ZnJhbWUuZmlsZU5hbWUsbWV0aG9kOm5vcm1hbGl6ZUZ1bmN0aW9uTmFtZShmcmFtZS5mdW5jdGlvbk5hbWUpLGxpbmVOdW1iZXI6ZnJhbWUubGluZU51bWJlcixjb2x1bW5OdW1iZXI6ZnJhbWUuY29sdW1uTnVtYmVyfTsvLyBTb21lIGluc3RhbmNlcyByZXN1bHQgaW4gbm8gZmlsZTpcbi8vIC0gbm9uLWVycm9yIGV4Y2VwdGlvbiB0aHJvd24gZnJvbSBnbG9iYWwgY29kZSBpbiBGRlxuLy8gVGhpcyBhZGRzIG9uZS5cbmlmKGYubGluZU51bWJlciYmZi5saW5lTnVtYmVyPi0xJiYhZi5maWxlJiYhZi5tZXRob2Qpe2YuZmlsZT1HTE9CQUxfQ09ERTt9cmV0dXJuIGY7fTtjb25zdCBlbnN1cmVTdHJpbmc9c3RyPT5pc1N0cmluZyhzdHIpP3N0cjonJztmdW5jdGlvbiBjcmVhdGVFeGNlcHRpb24oZXJyb3JDbGFzcyxlcnJvck1lc3NhZ2UsbXNnUHJlZml4LHN0YWNrdHJhY2Upe3JldHVybiB7ZXJyb3JDbGFzczplbnN1cmVTdHJpbmcoZXJyb3JDbGFzcyksbWVzc2FnZTpgJHttc2dQcmVmaXh9JHtlbnN1cmVTdHJpbmcoZXJyb3JNZXNzYWdlKX1gLHR5cGU6J2Jyb3dzZXJqcycsc3RhY2t0cmFjZTpzdGFja3RyYWNlLnJlZHVjZSgoYWNjdW0sZnJhbWUpPT57Y29uc3QgZj1mb3JtYXRTdGFja2ZyYW1lKGZyYW1lKTsvLyBkb24ndCBpbmNsdWRlIGEgc3RhY2tmcmFtZSBpZiBub25lIG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkXG50cnl7aWYoSlNPTi5zdHJpbmdpZnkoZik9PT0ne30nKXJldHVybiBhY2N1bTtyZXR1cm4gYWNjdW0uY29uY2F0KGYpO31jYXRjaHtyZXR1cm4gYWNjdW07fX0sW10pfTt9Y29uc3Qgbm9ybWFsaXplRXJyb3I9KG1heWJlRXJyb3IsbG9nZ2VyKT0+e2xldCBlcnJvcjtpZihpc1R5cGVPZkVycm9yKG1heWJlRXJyb3IpJiZpc1N0cmluZyhnZXRTdGFja3RyYWNlKG1heWJlRXJyb3IpKSl7ZXJyb3I9bWF5YmVFcnJvcjt9ZWxzZSB7bG9nZ2VyLndhcm4oTk9OX0VSUk9SX1dBUk5JTkcoRVJST1JfSEFORExFUixzdHJpbmdpZnlXaXRob3V0Q2lyY3VsYXIobWF5YmVFcnJvcikpKTtlcnJvcj11bmRlZmluZWQ7fXJldHVybiBlcnJvcjt9O2NvbnN0IGNyZWF0ZUJ1Z3NuYWdFeGNlcHRpb249KGVycm9yLG1zZ1ByZWZpeCk9Pnt0cnl7Y29uc3Qgc3RhY2t0cmFjZT1FcnJvclN0YWNrUGFyc2VyLnBhcnNlKGVycm9yKTtyZXR1cm4gY3JlYXRlRXhjZXB0aW9uKGVycm9yLm5hbWUsZXJyb3IubWVzc2FnZSxtc2dQcmVmaXgsc3RhY2t0cmFjZSk7fWNhdGNoe3JldHVybiBjcmVhdGVFeGNlcHRpb24oZXJyb3IubmFtZSxlcnJvci5tZXNzYWdlLG1zZ1ByZWZpeCxbXSk7fX07XG5cbi8qKlxuICogVXRpbGl0eSB0byBwYXJzZSBYSFIgSlNPTiByZXNwb25zZVxuICovY29uc3QgcmVzcG9uc2VUZXh0VG9Kc29uPShyZXNwb25zZVRleHQsb25FcnJvcik9Pnt0cnl7cmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2VUZXh0fHwnJyk7fWNhdGNoKGVycil7Y29uc3QgZXJyb3I9Z2V0TXV0YXRlZEVycm9yKGVyciwnRmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGRhdGEnKTtvbkVycm9yKGVycm9yKTt9cmV0dXJuIHVuZGVmaW5lZDt9O1xuXG5jb25zdCBGQUlMRURfUkVRVUVTVF9FUlJfTVNHX1BSRUZJWD0nVGhlIHJlcXVlc3QgZmFpbGVkJztjb25zdCBQTFVHSU5TX0xPQURfRkFJTFVSRV9NRVNTQUdFUz1bL0ZhaWxlZCB0byBmZXRjaCBkeW5hbWljYWxseSBpbXBvcnRlZCBtb2R1bGU6IC4qL107Y29uc3QgSU5URUdSQVRJT05TX0xPQURfRkFJTFVSRV9NRVNTQUdFUz1bL1VuYWJsZSB0byBsb2FkIFxcKC4qXFwpIHRoZSBzY3JpcHQgd2l0aCB0aGUgaWQgLiovLC9BIHRpbWVvdXQgb2YgXFxkKyBtcyBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gbG9hZCB0aGUgc2NyaXB0IHdpdGggaWQgLiovXTtjb25zdCBFUlJPUl9NRVNTQUdFU19UT19CRV9GSUxURVJFRD1bbmV3IFJlZ0V4cChgJHtGQUlMRURfUkVRVUVTVF9FUlJfTVNHX1BSRUZJWH0uKmApLC9BIHNjcmlwdCB3aXRoIHRoZSBpZCAuKiBpcyBhbHJlYWR5IGxvYWRlZFxcLi9dO2NvbnN0IFNDUklQVF9MT0FEX0ZBSUxVUkVfTUVTU0FHRVM9Wy4uLlBMVUdJTlNfTE9BRF9GQUlMVVJFX01FU1NBR0VTLC4uLklOVEVHUkFUSU9OU19MT0FEX0ZBSUxVUkVfTUVTU0FHRVNdO1xuXG5jb25zdCBERUZBVUxUX1hIUl9SRVFVRVNUX09QVElPTlM9e2hlYWRlcnM6e0FjY2VwdDonYXBwbGljYXRpb24vanNvbicsJ0NvbnRlbnQtVHlwZSc6J2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCd9LG1ldGhvZDonR0VUJ307LyoqXG4gKiBVdGlsaXR5IHRvIGNyZWF0ZSByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gYmFzZWQgb24gZGVmYXVsdCBvcHRpb25zXG4gKi9jb25zdCBjcmVhdGVYaHJSZXF1ZXN0T3B0aW9ucz0odXJsLG9wdGlvbnMsYmFzaWNBdXRoSGVhZGVyKT0+e2NvbnN0IHJlcXVlc3RPcHRpb25zPW1lcmdlRGVlcFJpZ2h0KERFRkFVTFRfWEhSX1JFUVVFU1RfT1BUSU9OUyxvcHRpb25zfHx7fSk7aWYoYmFzaWNBdXRoSGVhZGVyKXtyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzPW1lcmdlRGVlcFJpZ2h0KHJlcXVlc3RPcHRpb25zLmhlYWRlcnMse0F1dGhvcml6YXRpb246YmFzaWNBdXRoSGVhZGVyfSk7fXJlcXVlc3RPcHRpb25zLnVybD11cmw7cmV0dXJuIHJlcXVlc3RPcHRpb25zO307LyoqXG4gKiBVdGlsaXR5IGltcGxlbWVudGF0aW9uIG9mIFhIUiwgZmV0Y2ggY2Fubm90IGJlIHVzZWQgYXMgaXQgcmVxdWlyZXMgZXhwbGljaXRcbiAqIG9yaWdpbiBhbGxvd2VkIHZhbHVlcyBhbmQgbm90IHdpbGRjYXJkIGZvciBDT1JTIHJlcXVlc3RzIHdpdGggY3JlZGVudGlhbHMgYW5kXG4gKiB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgb3VyIHNvdXJjZUNvbmZpZyBBUElcbiAqL2NvbnN0IHhoclJlcXVlc3Q9KG9wdGlvbnMsdGltZW91dD1ERUZBVUxUX1hIUl9USU1FT1VUX01TLGxvZ2dlcik9Pm5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntsZXQgcGF5bG9hZDtpZihvcHRpb25zLnNlbmRSYXdEYXRhPT09dHJ1ZSl7cGF5bG9hZD1vcHRpb25zLmRhdGE7fWVsc2Uge3BheWxvYWQ9c3RyaW5naWZ5V2l0aG91dENpcmN1bGFyKG9wdGlvbnMuZGF0YSxmYWxzZSxbXSxsb2dnZXIpO2lmKGlzTnVsbChwYXlsb2FkKSl7cmVqZWN0KHtlcnJvcjpuZXcgRXJyb3IoWEhSX1BBWUxPQURfUFJFUF9FUlJPUiksdW5kZWZpbmVkLG9wdGlvbnN9KTsvLyByZXR1cm4gYW5kIGRvbid0IHByb2Nlc3MgZnVydGhlciBpZiB0aGUgcGF5bG9hZCBjb3VsZCBub3QgYmUgc3RyaW5naWZpZWRcbnJldHVybjt9fWNvbnN0IHhocj1uZXcgWE1MSHR0cFJlcXVlc3QoKTsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5jb25zdCB4aHJSZWplY3Q9ZT0+e3JlamVjdCh7ZXJyb3I6bmV3IEVycm9yKFhIUl9ERUxJVkVSWV9FUlJPUihGQUlMRURfUkVRVUVTVF9FUlJfTVNHX1BSRUZJWCx4aHIuc3RhdHVzLHhoci5zdGF0dXNUZXh0LG9wdGlvbnMudXJsLHhoci5yZXNwb25zZVRleHQpKSx4aHIsb3B0aW9uc30pO307Y29uc3QgeGhyRXJyb3I9ZT0+e3JlamVjdCh7ZXJyb3I6bmV3IEVycm9yKFhIUl9SRVFVRVNUX0VSUk9SKEZBSUxFRF9SRVFVRVNUX0VSUl9NU0dfUFJFRklYLGUsb3B0aW9ucy51cmwpKSx4aHIsb3B0aW9ucywuLi4oZT8udHlwZT09PSd0aW1lb3V0Jz97dGltZWRPdXQ6dHJ1ZX06e30pfSk7fTt4aHIub250aW1lb3V0PXhockVycm9yO3hoci5vbmVycm9yPXhockVycm9yO3hoci5vbmxvYWQ9KCk9PntpZih4aHIuc3RhdHVzPj0yMDAmJnhoci5zdGF0dXM8NDAwKXtyZXNvbHZlKHtyZXNwb25zZTp4aHIucmVzcG9uc2VUZXh0LHhocixvcHRpb25zfSk7fWVsc2Uge3hoclJlamVjdCgpO319O3hoci5vcGVuKG9wdGlvbnMubWV0aG9kLG9wdGlvbnMudXJsLHRydWUpO2lmKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzPT09dHJ1ZSl7eGhyLndpdGhDcmVkZW50aWFscz10cnVlO30vLyBUaGUgdGltZW91dCBwcm9wZXJ0eSBtYXkgYmUgc2V0IG9ubHkgaW4gdGhlIHRpbWUgaW50ZXJ2YWwgYmV0d2VlbiBhIGNhbGwgdG8gdGhlIG9wZW4gbWV0aG9kXG4vLyBhbmQgdGhlIGZpcnN0IGNhbGwgdG8gdGhlIHNlbmQgbWV0aG9kIGluIGxlZ2FjeSBicm93c2Vyc1xueGhyLnRpbWVvdXQ9dGltZW91dDtPYmplY3Qua2V5cyhvcHRpb25zLmhlYWRlcnMpLmZvckVhY2goaGVhZGVyTmFtZT0+e2lmKG9wdGlvbnMuaGVhZGVyc1toZWFkZXJOYW1lXSl7eGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSxvcHRpb25zLmhlYWRlcnNbaGVhZGVyTmFtZV0pO319KTt0cnl7eGhyLnNlbmQocGF5bG9hZCk7fWNhdGNoKGVycil7cmVqZWN0KHtlcnJvcjpnZXRNdXRhdGVkRXJyb3IoZXJyLFhIUl9TRU5EX0VSUk9SKEZBSUxFRF9SRVFVRVNUX0VSUl9NU0dfUFJFRklYLG9wdGlvbnMudXJsKSkseGhyLG9wdGlvbnN9KTt9fSk7XG5cbi8qKlxuICogU2VydmljZSB0byBoYW5kbGUgZGF0YSBjb21tdW5pY2F0aW9uIHdpdGggQVBJc1xuICovY2xhc3MgSHR0cENsaWVudHtjb25zdHJ1Y3Rvcihsb2dnZXIpe3RoaXMubG9nZ2VyPWxvZ2dlcjt0aGlzLm9uRXJyb3I9dGhpcy5vbkVycm9yLmJpbmQodGhpcyk7fWluaXQoZXJyb3JIYW5kbGVyKXt0aGlzLmVycm9ySGFuZGxlcj1lcnJvckhhbmRsZXI7fS8qKlxuICAgKiBJbXBsZW1lbnQgcmVxdWVzdHMgaW4gYSBibG9ja2luZyB3YXlcbiAgICovYXN5bmMgZ2V0RGF0YShjb25maWcpe2NvbnN0e3VybCxvcHRpb25zLHRpbWVvdXQsaXNSYXdSZXNwb25zZX09Y29uZmlnO3RyeXtjb25zdCBkYXRhPWF3YWl0IHhoclJlcXVlc3QoY3JlYXRlWGhyUmVxdWVzdE9wdGlvbnModXJsLG9wdGlvbnMsdGhpcy5iYXNpY0F1dGhIZWFkZXIpLHRpbWVvdXQsdGhpcy5sb2dnZXIpO3JldHVybiB7ZGF0YTppc1Jhd1Jlc3BvbnNlP2RhdGEucmVzcG9uc2U6cmVzcG9uc2VUZXh0VG9Kc29uKGRhdGEucmVzcG9uc2UsdGhpcy5vbkVycm9yKSxkZXRhaWxzOmRhdGF9O31jYXRjaChyZWFzb24pe3JldHVybiB7ZGF0YTp1bmRlZmluZWQsZGV0YWlsczpyZWFzb259O319LyoqXG4gICAqIEltcGxlbWVudCByZXF1ZXN0cyBpbiBhIG5vbi1ibG9ja2luZyB3YXlcbiAgICovZ2V0QXN5bmNEYXRhKGNvbmZpZyl7Y29uc3R7Y2FsbGJhY2ssdXJsLG9wdGlvbnMsdGltZW91dCxpc1Jhd1Jlc3BvbnNlfT1jb25maWc7Y29uc3QgaXNGaXJlQW5kRm9yZ2V0PSFpc0Z1bmN0aW9uKGNhbGxiYWNrKTt4aHJSZXF1ZXN0KGNyZWF0ZVhoclJlcXVlc3RPcHRpb25zKHVybCxvcHRpb25zLHRoaXMuYmFzaWNBdXRoSGVhZGVyKSx0aW1lb3V0LHRoaXMubG9nZ2VyKS50aGVuKGRhdGE9PntpZighaXNGaXJlQW5kRm9yZ2V0KXtjYWxsYmFjayhpc1Jhd1Jlc3BvbnNlP2RhdGEucmVzcG9uc2U6cmVzcG9uc2VUZXh0VG9Kc29uKGRhdGEucmVzcG9uc2UsdGhpcy5vbkVycm9yKSxkYXRhKTt9fSkuY2F0Y2goZGF0YT0+e2lmKCFpc0ZpcmVBbmRGb3JnZXQpe2NhbGxiYWNrKHVuZGVmaW5lZCxkYXRhKTt9fSk7fS8qKlxuICAgKiBIYW5kbGUgZXJyb3JzXG4gICAqL29uRXJyb3IoZXJyb3IsZ3JvdXBpbmdIYXNoKXt0aGlzLmVycm9ySGFuZGxlcj8ub25FcnJvcih7ZXJyb3IsY29udGV4dDpIVFRQX0NMSUVOVCxncm91cGluZ0hhc2h9KTt9LyoqXG4gICAqIFNldCBiYXNpYyBhdXRoZW50aWNhdGlvbiBoZWFkZXIgKGVnIHdyaXRla2V5KVxuICAgKi9zZXRBdXRoSGVhZGVyKHZhbHVlLG5vQnRvYT1mYWxzZSl7Y29uc3QgYXV0aFZhbD1ub0J0b2E/dmFsdWU6dG9CYXNlNjQoYCR7dmFsdWV9OmApO3RoaXMuYmFzaWNBdXRoSGVhZGVyPWBCYXNpYyAke2F1dGhWYWx9YDt9LyoqXG4gICAqIENsZWFyIGJhc2ljIGF1dGhlbnRpY2F0aW9uIGhlYWRlclxuICAgKi9yZXNldEF1dGhIZWFkZXIoKXt0aGlzLmJhc2ljQXV0aEhlYWRlcj11bmRlZmluZWQ7fX1jb25zdCBkZWZhdWx0SHR0cENsaWVudD1uZXcgSHR0cENsaWVudChkZWZhdWx0TG9nZ2VyKTtcblxuY29uc3QgTUVUUklDU19QQVlMT0FEX1ZFUlNJT049JzEnO1xuXG4vLyBFcnJvcnMgZnJvbSB0aGUgYmVsb3cgc2NyaXB0cyBhcmUgTk9UIGFsbG93ZWQgdG8gcmVhY2ggQnVnc25hZ1xuY29uc3QgU0RLX0ZJTEVfTkFNRV9QUkVGSVhFUz0oKT0+Wydyc2EnLy8gUHJlZml4IGZvciBhbGwgdGhlIFNESyBzY3JpcHRzIGluY2x1ZGluZyBwbHVnaW5zIGFuZCBtb2R1bGUgZmVkZXJhdGVkIGNodW5rc1xuXTtjb25zdCBERVZfSE9TVFM9Wyd3d3cudGVzdC1ob3N0LmNvbScsJ2xvY2FsaG9zdCcsJzEyNy4wLjAuMScsJ1s6OjFdJ107Ly8gTGlzdCBvZiBrZXlzIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgbWV0YWRhdGFcbi8vIFBvdGVudGlhbCBQSUkgb3Igc2Vuc2l0aXZlIGRhdGFcbmNvbnN0IEFQUF9TVEFURV9FWENMVURFX0tFWVM9Wyd1c2VySWQnLCd1c2VyVHJhaXRzJywnZ3JvdXBJZCcsJ2dyb3VwVHJhaXRzJywnYW5vbnltb3VzSWQnLCdjb25maWcnLCdpbnRlZ3JhdGlvbicsLy8gaW50ZWdyYXRpb24gaW5zdGFuY2Ugb2JqZWN0c1xuJ2V2ZW50QnVmZmVyJywvLyBwcmUtbG9hZCBldmVudCBidWZmZXIgKG1heSBjb250YWluIFBJSSlcbid0cmFpdHMnLCdhdXRoVG9rZW4nXTtjb25zdCBOT1RJRklFUl9OQU1FPSdSdWRkZXJTdGFjayBKYXZhU2NyaXB0IFNESyc7Y29uc3QgU0RLX0dJVEhVQl9VUkw9J2dpdCtodHRwczovL2dpdGh1Yi5jb20vcnVkZGVybGFicy9ydWRkZXItc2RrLWpzLmdpdCc7Y29uc3QgU09VUkNFX05BTUU9J2pzJztjb25zdCBERUZBVUxUX0VSUk9SX0NBVEVHT1JZPSdzZGsnO1xuXG5jb25zdCBkZXRlY3RBZEJsb2NrZXJzPWh0dHBDbGllbnQ9PntzdGF0ZS5jYXBhYmlsaXRpZXMuaXNBZEJsb2NrZXJEZXRlY3Rpb25JblByb2dyZXNzLnZhbHVlPXRydWU7dHJ5ey8vIEFwcGFyZW50bHksICc/dmlldz1hZCcgaXMgYSBxdWVyeSBwYXJhbSB0aGF0IGlzIGJsb2NrZWQgYnkgbWFqb3JpdHkgb2YgYWRibG9ja2Vyc1xuLy8gVXNlIHNvdXJjZSBjb25maWcgVVJMIGhlcmUgYXMgaXQgaXMgdmVyeSB1bmxpa2VseSB0byBiZSBibG9ja2VkIGJ5IGFkYmxvY2tlcnNcbi8vIE9ubHkgdGhlIGV4dHJhIHF1ZXJ5IHBhcmFtIHNob3VsZCBtYWtlIGl0IHZ1bG5lcmFibGUgdG8gYWRibG9ja2Vyc1xuLy8gVGhpcyB3aWxsIHdvcmsgZXZlbiBpZiB0aGUgdXNlcnMgcHJveGllcyBpdC5cbi8vIFRoZSBlZGdlIGNhc2Ugd2hlcmUgdGhpcyBkb2Vzbid0IHdvcmsgaXMgd2hlbiBIRUFEIG1ldGhvZCBpcyBub3QgYWxsb3dlZCBieSB0aGUgc2VydmVyICh1c2VyJ3MpXG5jb25zdCBiYXNlVXJsPW5ldyBVUkwoc3RhdGUubGlmZWN5Y2xlLnNvdXJjZUNvbmZpZ1VybC52YWx1ZSk7Y29uc3QgdXJsPWAke2Jhc2VVcmwub3JpZ2lufSR7YmFzZVVybC5wYXRobmFtZX0/dmlldz1hZGA7aHR0cENsaWVudC5nZXRBc3luY0RhdGEoe3VybCxvcHRpb25zOnsvLyBXZSBhY3R1YWxseSBkb24ndCBuZWVkIHRoZSByZXNwb25zZSBmcm9tIHRoZSByZXF1ZXN0LCBzbyB3ZSBhcmUgdXNpbmcgSEVBRFxubWV0aG9kOidIRUFEJyxoZWFkZXJzOnsnQ29udGVudC1UeXBlJzp1bmRlZmluZWR9fSxpc1Jhd1Jlc3BvbnNlOnRydWUsY2FsbGJhY2s6KHJlc3VsdCxkZXRhaWxzKT0+e3N0YXRlLmNhcGFiaWxpdGllcy5pc0FkQmxvY2tlckRldGVjdGlvbkluUHJvZ3Jlc3MudmFsdWU9ZmFsc2U7Ly8gbm90IGFkIGJsb2NrZWQgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCBvciBpdCBpcyBub3QgaW50ZXJuYWxseSByZWRpcmVjdGVkIG9uIHRoZSBjbGllbnQgc2lkZVxuLy8gT2Z0ZW4gYWRibG9ja2VycyBpbnN0ZWFkIG9mIGJsb2NraW5nIHRoZSByZXF1ZXN0LCB0aGV5IHJlZGlyZWN0IGl0IHRvIGFuIGludGVybmFsIFVSTFxuc3RhdGUuY2FwYWJpbGl0aWVzLmlzQWRCbG9ja2VkLnZhbHVlPWRldGFpbHM/LmVycm9yIT09dW5kZWZpbmVkfHxkZXRhaWxzPy54aHI/LnJlc3BvbnNlVVJMIT09dXJsO319KTt9Y2F0Y2goZXJyKXsvLyBSZXNldCB0aGUgZmxhZyB0byBwcmV2ZW50IGJsb2NraW5nIGZ1dHVyZSBkZXRlY3Rpb24gYXR0ZW1wdHNcbnN0YXRlLmNhcGFiaWxpdGllcy5pc0FkQmxvY2tlckRldGVjdGlvbkluUHJvZ3Jlc3MudmFsdWU9ZmFsc2U7Ly8gUmUtdGhyb3cgdGhlIGVycm9yIHRvIGJlIGhhbmRsZWQgYnkgdGhlIGNhbGxlclxudGhyb3cgZXJyO319O1xuXG5jb25zdCBnZXRFcnJJbnN0YW5jZT0oZXJyLGVycm9yVHlwZSk9Pntzd2l0Y2goZXJyb3JUeXBlKXtjYXNlIEVycm9yVHlwZS5VTkhBTkRMRURFWENFUFRJT046e2NvbnN0e2Vycm9yfT1lcnI7cmV0dXJuIGVycm9yfHxlcnI7fWNhc2UgRXJyb3JUeXBlLlVOSEFORExFRFJFSkVDVElPTjp7cmV0dXJuIGVyci5yZWFzb247fWNhc2UgRXJyb3JUeXBlLkhBTkRMRURFWENFUFRJT046ZGVmYXVsdDpyZXR1cm4gZXJyO319O2NvbnN0IGNyZWF0ZU5ld0JyZWFkY3J1bWI9bWVzc2FnZT0+KHt0eXBlOidtYW51YWwnLG5hbWU6bWVzc2FnZSx0aW1lc3RhbXA6bmV3IERhdGUoKSxtZXRhRGF0YTp7fX0pOy8qKlxuICogQSBmdW5jdGlvbiB0byBnZXQgdGhlIEJ1Z3NuYWcgcmVsZWFzZSBzdGFnZSBmb3IgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcbiAqIEBwYXJhbSBnZXRIb3N0TmFtZSBPcHRpb25hbCBmdW5jdGlvbiB0byBnZXQgdGhlIGhvc3RuYW1lIChwcmltYXJpbHkgZm9yIHRlc3RpbmcpXG4gKiBAcmV0dXJucyAnZGV2ZWxvcG1lbnQnIGlmIHRoZSBob3N0IGlzIGVtcHR5IChmb3IgZmlsZTovLyBwcm90b2NvbCBldGMuKSBvciBhIGRldiBob3N0IChsb2NhbGhvc3QsIDEyNy4wLjAuMSwgZXRjLiksIG90aGVyd2lzZSAnJ3Byb2R1Y3Rpb24nJyAoaXQnbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgYWN0dWFsIHJlbGVhc2Ugc3RhZ2UgZHVyaW5nIHRoZSBidWlsZClcbiAqL2NvbnN0IGdldFJlbGVhc2VTdGFnZT0oZ2V0SG9zdE5hbWU9KCk9PndpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSk9Pntjb25zdCBob3N0PWdldEhvc3ROYW1lKCk7cmV0dXJuICFob3N0fHxob3N0JiZERVZfSE9TVFMuaW5jbHVkZXMoaG9zdCk/J2RldmVsb3BtZW50JzoncHJvZHVjdGlvbic7fTtjb25zdCBnZXRBcHBTdGF0ZUZvck1ldGFkYXRhPXN0YXRlPT57Y29uc3Qgc3RhdGVTdHI9c3RyaW5naWZ5V2l0aG91dENpcmN1bGFyKHN0YXRlLGZhbHNlLEFQUF9TVEFURV9FWENMVURFX0tFWVMpO3JldHVybiBzdGF0ZVN0ciE9PW51bGw/SlNPTi5wYXJzZShzdGF0ZVN0cik6e307fTtjb25zdCBnZXRVUkxXaXRob3V0UXVlcnlTdHJpbmc9KCk9Pntjb25zdCB1cmw9Z2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmLnNwbGl0KCc/Jyk7cmV0dXJuIHVybFswXTt9O2NvbnN0IGdldFVzZXJEZXRhaWxzPShzb3VyY2Usc2Vzc2lvbixsaWZlY3ljbGUsYXV0b1RyYWNrKT0+KHtpZDpgJHtzb3VyY2UudmFsdWU/LmlkPz9saWZlY3ljbGUud3JpdGVLZXkudmFsdWV9Li4ke3Nlc3Npb24uc2Vzc2lvbkluZm8udmFsdWUuaWQ/PydOQSd9Li4ke2F1dG9UcmFjay5wYWdlTGlmZWN5Y2xlLnBhZ2VWaWV3SWQudmFsdWU/PydOQSd9YCxuYW1lOnNvdXJjZS52YWx1ZT8ubmFtZT8/J05BJ30pO2NvbnN0IGdldERldmljZURldGFpbHM9KGxvY2FsZSx1c2VyQWdlbnQpPT4oe2xvY2FsZTpsb2NhbGUudmFsdWU/PydOQScsdXNlckFnZW50OnVzZXJBZ2VudC52YWx1ZT8/J05BJyx0aW1lOm5ldyBEYXRlKCl9KTtjb25zdCBnZXRCdWdzbmFnRXJyb3JFdmVudD0oZXhjZXB0aW9uLGVycm9yU3RhdGUsc3RhdGUsZ3JvdXBpbmdIYXNoKT0+e2NvbnN0e2NvbnRleHQsbGlmZWN5Y2xlLHNlc3Npb24sc291cmNlLHJlcG9ydGluZyxhdXRvVHJhY2t9PXN0YXRlO2NvbnN0e2FwcCxsb2NhbGUsdXNlckFnZW50LHRpbWV6b25lLHNjcmVlbixsaWJyYXJ5fT1jb250ZXh0O3JldHVybiB7cGF5bG9hZFZlcnNpb246JzUnLG5vdGlmaWVyOntuYW1lOk5PVElGSUVSX05BTUUsdmVyc2lvbjphcHAudmFsdWUudmVyc2lvbix1cmw6U0RLX0dJVEhVQl9VUkx9LGV2ZW50czpbe2V4Y2VwdGlvbnM6W2Nsb25lKGV4Y2VwdGlvbildLHNldmVyaXR5OmVycm9yU3RhdGUuc2V2ZXJpdHksdW5oYW5kbGVkOmVycm9yU3RhdGUudW5oYW5kbGVkLHNldmVyaXR5UmVhc29uOmVycm9yU3RhdGUuc2V2ZXJpdHlSZWFzb24sYXBwOnt2ZXJzaW9uOmFwcC52YWx1ZS52ZXJzaW9uLHJlbGVhc2VTdGFnZTpnZXRSZWxlYXNlU3RhZ2UoKSx0eXBlOmFwcC52YWx1ZS5pbnN0YWxsVHlwZX0sZGV2aWNlOmdldERldmljZURldGFpbHMobG9jYWxlLHVzZXJBZ2VudCkscmVxdWVzdDp7dXJsOmdldFVSTFdpdGhvdXRRdWVyeVN0cmluZygpLGNsaWVudElwOidbTk9UIENPTExFQ1RFRF0nfSxicmVhZGNydW1iczpjbG9uZShyZXBvcnRpbmcuYnJlYWRjcnVtYnMudmFsdWUpLGNvbnRleHQ6ZXhjZXB0aW9uLm1lc3NhZ2UsZ3JvdXBpbmdIYXNoLG1ldGFEYXRhOnthcHA6e3NuaXBwZXRWZXJzaW9uOmxpYnJhcnkudmFsdWUuc25pcHBldFZlcnNpb259LGRldmljZTp7Li4uc2NyZWVuLnZhbHVlLHRpbWV6b25lOnRpbWV6b25lLnZhbHVlfSwvLyBBZGQgcmVzdCBvZiB0aGUgc3RhdGUgZ3JvdXBzIGFzIG1ldGFkYXRhXG4vLyBzbyB0aGF0IHRoZXkgc2hvdyB1cCBhcyBzZXBhcmF0ZSB0YWJzIGluIHRoZSBkYXNoYm9hcmRcbi4uLmdldEFwcFN0YXRlRm9yTWV0YWRhdGEoc3RhdGUpfSx1c2VyOmdldFVzZXJEZXRhaWxzKHNvdXJjZSxzZXNzaW9uLGxpZmVjeWNsZSxhdXRvVHJhY2spfV19O307LyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIGFkYmxvY2tlcnMgYXJlIGFjdGl2ZS4gVGhlIHByb21pc2UncyByZXNvbHZlIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIHdpdGggdHJ1ZSBpZiBhZGJsb2NrZXJzIGFyZSBub3QgZGV0ZWN0ZWQgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7QXBwbGljYXRpb25TdGF0ZX0gc3RhdGUgVGhlIGFwcGxpY2F0aW9uIHN0YXRlXG4gKiBAcGFyYW0ge0lIdHRwQ2xpZW50fSBodHRwQ2xpZW50IFRoZSBIVFRQIGNsaWVudCBpbnN0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBUaGUgcHJvbWlzZSdzIHJlc29sdmUgZnVuY3Rpb25cbiAqL2NvbnN0IGNoZWNrSWZBZEJsb2NrZXJzQXJlQWN0aXZlPShzdGF0ZSxodHRwQ2xpZW50LHJlc29sdmUpPT57Ly8gSW5pdGlhdGUgYWQgYmxvY2tlciBkZXRlY3Rpb24gaWYgbm90IGRvbmUgcHJldmlvdXNseSBhbmQgbm90IGFscmVhZHkgaW4gcHJvZ3Jlc3MuXG5pZihpc1VuZGVmaW5lZChzdGF0ZS5jYXBhYmlsaXRpZXMuaXNBZEJsb2NrZWQudmFsdWUpKXtpZihzdGF0ZS5jYXBhYmlsaXRpZXMuaXNBZEJsb2NrZXJEZXRlY3Rpb25JblByb2dyZXNzLnZhbHVlPT09ZmFsc2Upe2RldGVjdEFkQmxvY2tlcnMoaHR0cENsaWVudCk7fS8vIFdhaXQgZm9yIHRoZSBkZXRlY3Rpb24gdG8gY29tcGxldGUuXG5jb25zdCBkZXRlY3Rpb25EaXNwb3Nlcj1FKCgpPT57aWYoaXNEZWZpbmVkKHN0YXRlLmNhcGFiaWxpdGllcy5pc0FkQmxvY2tlZC52YWx1ZSkpey8vIElmIGFkIGJsb2NrZXIgaXMgbm90IGRldGVjdGVkLCBub3RpZnkuXG5yZXNvbHZlKHN0YXRlLmNhcGFiaWxpdGllcy5pc0FkQmxvY2tlZC52YWx1ZT09PWZhbHNlKTsvLyBDbGVhbnVwIHRoZSBlZmZlY3QuXG5kZXRlY3Rpb25EaXNwb3NlcigpO319KTt9ZWxzZSB7Ly8gSWYgYWQgYmxvY2tlciBpcyBub3QgZGV0ZWN0ZWQsIG5vdGlmeS5cbnJlc29sdmUoc3RhdGUuY2FwYWJpbGl0aWVzLmlzQWRCbG9ja2VkLnZhbHVlPT09ZmFsc2UpO319Oy8qKlxuICogQSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgZXJyb3Igc2hvdWxkIGJlIHByb21vdGVkIHRvIG5vdGlmeSBvciBub3QuXG4gKiBGb3IgcGx1Z2luIGFuZCBpbnRlZ3JhdGlvbiBlcnJvcnMgZnJvbSBSUyBDRE4sIGlmIGl0IGlzIGR1ZSB0byBDU1AgYmxvY2tlZCBVUkxzIG9yIEFkQmxvY2tlcnMsXG4gKiBpdCB3aWxsIG5vdCBiZSBwcm9tb3RlZCB0byBub3RpZnkuXG4gKiBJZiBpdCBpcyBkdWUgdG8gb3RoZXIgcmVhc29ucywgaXQgd2lsbCBiZSBwcm9tb3RlZCB0byBub3RpZnkuXG4gKiBAcGFyYW0ge0Vycm9yfSBleGNlcHRpb24gVGhlIGVycm9yIG9iamVjdFxuICogQHBhcmFtIHtBcHBsaWNhdGlvblN0YXRlfSBzdGF0ZSBUaGUgYXBwbGljYXRpb24gc3RhdGVcbiAqIEBwYXJhbSB7SUh0dHBDbGllbnR9IGh0dHBDbGllbnQgVGhlIEhUVFAgY2xpZW50IGluc3RhbmNlXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlcnJvciBzaG91bGQgYmUgcHJvbW90ZWQgdG8gbm90aWZ5IG9yIG5vdFxuICovY29uc3QgY2hlY2tJZkFsbG93ZWRUb0JlTm90aWZpZWQ9KGV4Y2VwdGlvbixzdGF0ZSxodHRwQ2xpZW50KT0+e2NvbnN0IGVyck1zZz1leGNlcHRpb24ubWVzc2FnZTtyZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZT0+ey8vIEZpbHRlciBvdXQgc2NyaXB0IGxvYWQgZmFpbHVyZXMgdGhhdCBhcmUgbm90IGZyb20gdGhlIFJTIENETi5cbmlmKFNDUklQVF9MT0FEX0ZBSUxVUkVfTUVTU0FHRVMuc29tZShyZWdleD0+cmVnZXgudGVzdChlcnJNc2cpKSl7Y29uc3QgZXh0cmFjdGVkVVJMPS9odHRwcz86XFwvXFwvW15cXHNcIicoKSw7PD5bXFxde31dKy8uZXhlYyhlcnJNc2cpPy5bMF07aWYoaXNTdHJpbmcoZXh0cmFjdGVkVVJMKSl7aWYoZXh0cmFjdGVkVVJMLnN0YXJ0c1dpdGgoU0RLX0NETl9CQVNFX1VSTCkpey8vIEZpbHRlciBvdXQgZXJyb3JzIHRoYXQgYXJlIGZyb20gQ1NQIGJsb2NrZWQgVVJMcy5cbmlmKHN0YXRlLmNhcGFiaWxpdGllcy5jc3BCbG9ja2VkVVJMcy52YWx1ZS5pbmNsdWRlcyhleHRyYWN0ZWRVUkwpKXtyZXNvbHZlKGZhbHNlKTt9ZWxzZSB7Ly8gRmlsdGVyIG91dCBlcnJvcnMgaWYgYWRibG9ja2VycyBhcmUgZGV0ZWN0ZWQuXG5jaGVja0lmQWRCbG9ja2Vyc0FyZUFjdGl2ZShzdGF0ZSxodHRwQ2xpZW50LHJlc29sdmUpO319ZWxzZSB7Ly8gRmlsdGVyIG91dCBlcnJvcnMgdGhhdCBhcmUgbm90IGZyb20gdGhlIFJTIENETi5cbnJlc29sdmUoZmFsc2UpO319ZWxzZSB7Ly8gQWxsb3cgdGhlIGVycm9yIHRvIGJlIG5vdGlmaWVkIGlmIG5vIFVSTCBjb3VsZCBiZSBleHRyYWN0ZWQgZnJvbSB0aGUgZXJyb3IgbWVzc2FnZVxucmVzb2x2ZSh0cnVlKTt9fWVsc2Uge3Jlc29sdmUoIUVSUk9SX01FU1NBR0VTX1RPX0JFX0ZJTFRFUkVELnNvbWUoZT0+ZS50ZXN0KGVyck1zZykpKTt9fSk7fTsvKipcbiAqIEEgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIHRoZSBlcnJvciBpcyBmcm9tIFJ1ZGRlciBTREtcbiAqIEBwYXJhbSB7RXJyb3J9IGV4Y2VwdGlvblxuICogQHJldHVybnNcbiAqL2NvbnN0IGlzU0RLRXJyb3I9ZXhjZXB0aW9uPT57Y29uc3QgZXJyb3JPcmlnaW49ZXhjZXB0aW9uLnN0YWNrdHJhY2VbMF0/LmZpbGU7aWYoIWVycm9yT3JpZ2lufHx0eXBlb2YgZXJyb3JPcmlnaW4hPT0nc3RyaW5nJyl7cmV0dXJuIGZhbHNlO31jb25zdCBzcmNGaWxlTmFtZT1lcnJvck9yaWdpbi5zdWJzdHJpbmcoZXJyb3JPcmlnaW4ubGFzdEluZGV4T2YoJy8nKSsxKTtjb25zdCBwYXRocz1lcnJvck9yaWdpbi5zcGxpdCgnLycpOy8vIGV4dHJhY3QgdGhlIHBhcmVudCBmb2xkZXIgbmFtZSBmcm9tIHRoZSBlcnJvciBvcmlnaW4gZmlsZSBwYXRoXG4vLyBFeDogcGFyZW50Rm9sZGVyTmFtZSB3aWxsIGJlICdzYW1wbGUnIGZvciB1cmw6IGh0dHBzOi8vZXhhbXBsZS5jb20vc2FtcGxlL2ZpbGUubWluLmpzXG5jb25zdCBwYXJlbnRGb2xkZXJOYW1lPXBhdGhzW3BhdGhzLmxlbmd0aC0yXTtyZXR1cm4gcGFyZW50Rm9sZGVyTmFtZT09PUNETl9JTlRfRElSfHxTREtfRklMRV9OQU1FX1BSRUZJWEVTKCkuc29tZShwcmVmaXg9PnNyY0ZpbGVOYW1lLnN0YXJ0c1dpdGgocHJlZml4KSYmc3JjRmlsZU5hbWUuZW5kc1dpdGgoJy5qcycpKTt9O2NvbnN0IGdldEVycm9yRGVsaXZlcnlQYXlsb2FkPShwYXlsb2FkLHN0YXRlLGNhdGVnb3J5KT0+e2NvbnN0IGRhdGE9e3ZlcnNpb246TUVUUklDU19QQVlMT0FEX1ZFUlNJT04sbWVzc2FnZV9pZDpnZW5lcmF0ZVVVSUQoKSxzb3VyY2U6e25hbWU6U09VUkNFX05BTUUsc2RrX3ZlcnNpb246c3RhdGUuY29udGV4dC5hcHAudmFsdWUudmVyc2lvbix3cml0ZV9rZXk6c3RhdGUubGlmZWN5Y2xlLndyaXRlS2V5LnZhbHVlLGluc3RhbGxfdHlwZTpzdGF0ZS5jb250ZXh0LmFwcC52YWx1ZS5pbnN0YWxsVHlwZSxjYXRlZ29yeTpjYXRlZ29yeT8/REVGQVVMVF9FUlJPUl9DQVRFR09SWX0sZXJyb3JzOnBheWxvYWR9O3JldHVybiBzdHJpbmdpZnlXaXRob3V0Q2lyY3VsYXIoZGF0YSk7fTsvKipcbiAqIEEgZnVuY3Rpb24gdG8gZ2V0IHRoZSBncm91cGluZyBoYXNoIHZhbHVlIHRvIGJlIHVzZWQgZm9yIHRoZSBlcnJvciBldmVudC5cbiAqIElmIHRoZSBncm91cGluZyBoYXNoIGlzIGFuIGVycm9yIGluc3RhbmNlLCB0aGUgbm9ybWFsaXplZCBlcnJvciBtZXNzYWdlIGlzIHVzZWQgYXMgdGhlIGdyb3VwaW5nIGhhc2guXG4gKiBJZiB0aGUgZ3JvdXBpbmcgaGFzaCBpcyBhbiBlbXB0eSBzdHJpbmcgb3Igbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgZ3JvdXBpbmcgaGFzaCBpcyB1c2VkLlxuICogSWYgdGhlIGdyb3VwaW5nIGhhc2ggaXMgYSBzdHJpbmcsIGl0IGlzIHVzZWQgYXMgaXMuXG4gKiBAcGFyYW0gY3VyRXJyR3JvdXBpbmdIYXNoIFRoZSBncm91cGluZyBoYXNoIHZhbHVlIHBhcnQgb2YgdGhlIGVycm9yIGV2ZW50XG4gKiBAcGFyYW0gZGVmYXVsdEdyb3VwaW5nSGFzaCBUaGUgZGVmYXVsdCBncm91cGluZyBoYXNoIHZhbHVlLiBJdCBpcyB0aGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSBsb2dnZXIgVGhlIGxvZ2dlciBpbnN0YW5jZVxuICogQHJldHVybnMgVGhlIGZpbmFsIGdyb3VwaW5nIGhhc2ggdmFsdWUgdG8gYmUgdXNlZCBmb3IgdGhlIGVycm9yIGV2ZW50XG4gKi9jb25zdCBnZXRFcnJvckdyb3VwaW5nSGFzaD0oY3VyRXJyR3JvdXBpbmdIYXNoLGRlZmF1bHRHcm91cGluZ0hhc2gsbG9nZ2VyKT0+e2xldCBub3JtYWxpemVkR3JvdXBpbmdIYXNoO2lmKCFpc0RlZmluZWQoY3VyRXJyR3JvdXBpbmdIYXNoKSl7bm9ybWFsaXplZEdyb3VwaW5nSGFzaD1kZWZhdWx0R3JvdXBpbmdIYXNoO31lbHNlIGlmKGlzU3RyaW5nKGN1ckVyckdyb3VwaW5nSGFzaCkpe25vcm1hbGl6ZWRHcm91cGluZ0hhc2g9Y3VyRXJyR3JvdXBpbmdIYXNoO31lbHNlIHtjb25zdCBub3JtYWxpemVkRXJyb3JJbnN0YW5jZT1ub3JtYWxpemVFcnJvcihjdXJFcnJHcm91cGluZ0hhc2gsbG9nZ2VyKTtpZihpc0RlZmluZWQobm9ybWFsaXplZEVycm9ySW5zdGFuY2UpKXtub3JtYWxpemVkR3JvdXBpbmdIYXNoPW5vcm1hbGl6ZWRFcnJvckluc3RhbmNlLm1lc3NhZ2U7fWVsc2Uge25vcm1hbGl6ZWRHcm91cGluZ0hhc2g9ZGVmYXVsdEdyb3VwaW5nSGFzaDt9fXJldHVybiBub3JtYWxpemVkR3JvdXBpbmdIYXNoO307XG5cbi8qKlxuICogQSBzZXJ2aWNlIHRvIGhhbmRsZSBlcnJvcnNcbiAqL2NsYXNzIEVycm9ySGFuZGxlcntpbml0aWFsaXplZD1mYWxzZTsvLyBJZiBubyBsb2dnZXIgaXMgcGFzc2VkIGVycm9ycyB3aWxsIGJlIHRocm93biBhcyB1bmhhbmRsZWQgZXJyb3JcbmNvbnN0cnVjdG9yKGh0dHBDbGllbnQsbG9nZ2VyKXt0aGlzLmh0dHBDbGllbnQ9aHR0cENsaWVudDt0aGlzLmxvZ2dlcj1sb2dnZXI7fS8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgZXJyb3IgaGFuZGxlciBieSBhdHRhY2hpbmcgZ2xvYmFsIGVycm9yIGxpc3RlbmVycy5cbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIGFmdGVyIGNvbnN0cnVjdGlvbi5cbiAgICovaW5pdCgpe2lmKHRoaXMuaW5pdGlhbGl6ZWQpe3JldHVybjt9dGhpcy5hdHRhY2hFcnJvckxpc3RlbmVycygpO3RoaXMuaW5pdGlhbGl6ZWQ9dHJ1ZTt9LyoqXG4gICAqIEF0dGFjaCBlcnJvciBsaXN0ZW5lcnMgdG8gdGhlIGdsb2JhbCB3aW5kb3cgb2JqZWN0XG4gICAqL2F0dGFjaEVycm9yTGlzdGVuZXJzKCl7Z2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsZXZlbnQ9Pnt0aGlzLm9uRXJyb3Ioe2Vycm9yOmV2ZW50LGNvbnRleHQ6RVJST1JfSEFORExFUixlcnJvclR5cGU6RXJyb3JUeXBlLlVOSEFORExFREVYQ0VQVElPTn0pO30pO2dsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJyxldmVudD0+e3RoaXMub25FcnJvcih7ZXJyb3I6ZXZlbnQsY29udGV4dDpFUlJPUl9IQU5ETEVSLGVycm9yVHlwZTpFcnJvclR5cGUuVU5IQU5ETEVEUkVKRUNUSU9OfSk7fSk7Ly8gTGlzdGVuIHRvIENTUCB2aW9sYXRpb25zIGFuZCBhZGQgdGhlIGJsb2NrZWQgVVJMIHRvIHRoZSBzdGF0ZVxuLy8gaWYgdGhvc2UgVVJMcyBhcmUgZnJvbSBSUyBDRE4uXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWN1cml0eXBvbGljeXZpb2xhdGlvbicsZXZlbnQ9Pntjb25zdCBibG9ja2VkVVJMPWlzU3RyaW5nKGV2ZW50LmJsb2NrZWRVUkkpP2V2ZW50LmJsb2NrZWRVUkk6Jyc7aWYoZXZlbnQuZGlzcG9zaXRpb249PT0nZW5mb3JjZScmJmJsb2NrZWRVUkwuc3RhcnRzV2l0aChTREtfQ0ROX0JBU0VfVVJMKSYmIXN0YXRlLmNhcGFiaWxpdGllcy5jc3BCbG9ja2VkVVJMcy52YWx1ZS5pbmNsdWRlcyhibG9ja2VkVVJMKSl7c3RhdGUuY2FwYWJpbGl0aWVzLmNzcEJsb2NrZWRVUkxzLnZhbHVlPVsuLi5zdGF0ZS5jYXBhYmlsaXRpZXMuY3NwQmxvY2tlZFVSTHMudmFsdWUsYmxvY2tlZFVSTF07fX0pO30vKipcbiAgICogSGFuZGxlIGVycm9yc1xuICAgKiBAcGFyYW0gZXJyb3JJbmZvIC0gVGhlIGVycm9yIGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSBlcnJvckluZm8uZXJyb3IgLSBUaGUgZXJyb3IgdG8gaGFuZGxlXG4gICAqIEBwYXJhbSBlcnJvckluZm8uY29udGV4dCAtIFRoZSBjb250ZXh0IG9mIHdoZXJlIHRoZSBlcnJvciBvY2N1cnJlZFxuICAgKiBAcGFyYW0gZXJyb3JJbmZvLmN1c3RvbU1lc3NhZ2UgLSBUaGUgY3VzdG9tIG1lc3NhZ2Ugb2YgdGhlIGVycm9yXG4gICAqIEBwYXJhbSBlcnJvckluZm8uZXJyb3JUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGVycm9yIChoYW5kbGVkIG9yIHVuaGFuZGxlZClcbiAgICogQHBhcmFtIGVycm9ySW5mby5ncm91cGluZ0hhc2ggLSBUaGUgZ3JvdXBpbmcgaGFzaCBvZiB0aGUgZXJyb3JcbiAgICogQHBhcmFtIGVycm9ySW5mby5jYXRlZ29yeSAtIFRoZSBjYXRlZ29yeSBvZiB0aGUgZXJyb3IgKHNkayBvciBpbnRlZ3JhdGlvbnMpXG4gICAqL2FzeW5jIG9uRXJyb3IoZXJyb3JJbmZvKXt0cnl7Y29uc3R7ZXJyb3IsY29udGV4dCxjdXN0b21NZXNzYWdlLGdyb3VwaW5nSGFzaCxjYXRlZ29yeX09ZXJyb3JJbmZvO2NvbnN0IGVycm9yVHlwZT1lcnJvckluZm8uZXJyb3JUeXBlPz9FcnJvclR5cGUuSEFORExFREVYQ0VQVElPTjtjb25zdCBlcnJJbnN0YW5jZT1nZXRFcnJJbnN0YW5jZShlcnJvcixlcnJvclR5cGUpO2NvbnN0IG5vcm1hbGl6ZWRFcnJvcj1ub3JtYWxpemVFcnJvcihlcnJJbnN0YW5jZSx0aGlzLmxvZ2dlcik7aWYoaXNVbmRlZmluZWQobm9ybWFsaXplZEVycm9yKSl7cmV0dXJuO31jb25zdCBjdXN0b21Nc2dWYWw9Y3VzdG9tTWVzc2FnZT9gJHtjdXN0b21NZXNzYWdlfSAtIGA6Jyc7Y29uc3QgZXJyb3JNc2dQcmVmaXg9YCR7Y29udGV4dH0ke0xPR19DT05URVhUX1NFUEFSQVRPUn0ke2N1c3RvbU1zZ1ZhbH1gO2NvbnN0IGJzRXhjZXB0aW9uPWNyZWF0ZUJ1Z3NuYWdFeGNlcHRpb24obm9ybWFsaXplZEVycm9yLGVycm9yTXNnUHJlZml4KTtjb25zdCBzdGFja3RyYWNlPWdldFN0YWNrdHJhY2Uobm9ybWFsaXplZEVycm9yKTtjb25zdCBpc1Nka0Rpc3BhdGNoZWQ9c3RhY2t0cmFjZS5pbmNsdWRlcyhNQU5VQUxfRVJST1JfSURFTlRJRklFUik7Ly8gRmlsdGVyIGVycm9ycyB0aGF0IGFyZSBub3Qgb3JpZ2luYXRlZCBpbiB0aGUgU0RLLlxuLy8gSW4gY2FzZSBvZiBOUE0gaW5zdGFsbGF0aW9ucywgdGhlIHVuaGFuZGxlZCBlcnJvcnMgZnJvbSB0aGUgU0RLIGNhbm5vdCBiZSBpZGVudGlmaWVkXG4vLyBhbmQgd2lsbCBOT1QgYmUgcmVwb3J0ZWQgdW5sZXNzIHRoZXkgb2NjdXIgaW4gcGx1Z2lucyBvciBpbnRlZ3JhdGlvbnMuXG5pZighaXNTZGtEaXNwYXRjaGVkJiYhaXNTREtFcnJvcihic0V4Y2VwdGlvbikmJmVycm9yVHlwZSE9PUVycm9yVHlwZS5IQU5ETEVERVhDRVBUSU9OKXtyZXR1cm47fWlmKHN0YXRlLnJlcG9ydGluZy5pc0Vycm9yUmVwb3J0aW5nRW5hYmxlZC52YWx1ZSl7Y29uc3QgaXNBbGxvd2VkPWF3YWl0IGNoZWNrSWZBbGxvd2VkVG9CZU5vdGlmaWVkKGJzRXhjZXB0aW9uLHN0YXRlLHRoaXMuaHR0cENsaWVudCk7aWYoaXNBbGxvd2VkKXtjb25zdCBlcnJvclN0YXRlPXtzZXZlcml0eTonZXJyb3InLHVuaGFuZGxlZDplcnJvclR5cGUhPT1FcnJvclR5cGUuSEFORExFREVYQ0VQVElPTixzZXZlcml0eVJlYXNvbjp7dHlwZTplcnJvclR5cGV9fTsvLyBUaGlzIHdpbGwgYWxsb3cgY3VzdG9tIGdyb3VwaW5nIG9mIGVycm9ycy5cbi8vIEluIGNhc2Ugb2YgTlBNIGluc3RhbGxhdGlvbnMsIHRoZSBkZWZhdWx0IGdyb3VwaW5nIGJ5IHN1cnJvdW5kaW5nIGNvZGVcbi8vIGRvZXMgbm90IG1ha2Ugc2Vuc2UgYXMgZWFjaCB1c2VyIGFwcGxpY2F0aW9uIGlzIGRpZmZlcmVudCBhbmQgd2lsbCBjcmVhdGUgYSBsb3Qgb2Ygbm9pc2UgaW4gdGhlIGFsZXJ0cy5cbi8vIFJlZmVyZW5jZXM6XG4vLyBodHRwczovL2RvY3MuYnVnc25hZy5jb20vcGxhdGZvcm1zL2phdmFzY3JpcHQvY3VzdG9taXppbmctZXJyb3ItcmVwb3J0cy8jZ3JvdXBpbmdoYXNoXG4vLyBodHRwczovL2RvY3MuYnVnc25hZy5jb20vcHJvZHVjdC9lcnJvci1ncm91cGluZy8jdXNlcl9kZWZpbmVkXG5jb25zdCBub3JtYWxpemVkR3JvdXBpbmdIYXNoPWdldEVycm9yR3JvdXBpbmdIYXNoKGdyb3VwaW5nSGFzaCxic0V4Y2VwdGlvbi5tZXNzYWdlLHRoaXMubG9nZ2VyKTsvLyBHZXQgdGhlIGZpbmFsIHBheWxvYWQgdG8gYmUgc2VudCB0byB0aGUgbWV0cmljcyBzZXJ2aWNlXG5jb25zdCBidWdzbmFnUGF5bG9hZD1nZXRCdWdzbmFnRXJyb3JFdmVudChic0V4Y2VwdGlvbixlcnJvclN0YXRlLHN0YXRlLG5vcm1hbGl6ZWRHcm91cGluZ0hhc2gpOy8vIHNlbmQgaXQgdG8gbWV0cmljcyBzZXJ2aWNlXG50aGlzLmh0dHBDbGllbnQuZ2V0QXN5bmNEYXRhKHt1cmw6c3RhdGUubWV0cmljcy5tZXRyaWNzU2VydmljZVVybC52YWx1ZSxvcHRpb25zOnttZXRob2Q6J1BPU1QnLGRhdGE6Z2V0RXJyb3JEZWxpdmVyeVBheWxvYWQoYnVnc25hZ1BheWxvYWQsc3RhdGUsY2F0ZWdvcnkpLHNlbmRSYXdEYXRhOnRydWV9LGlzUmF3UmVzcG9uc2U6dHJ1ZX0pO319Ly8gTG9nIGhhbmRsZWQgZXJyb3JzIGFuZCBlcnJvcnMgZGlzcGF0Y2hlZCBieSB0aGUgU0RLXG5pZihlcnJvclR5cGU9PT1FcnJvclR5cGUuSEFORExFREVYQ0VQVElPTnx8aXNTZGtEaXNwYXRjaGVkKXt0aGlzLmxvZ2dlci5lcnJvcihic0V4Y2VwdGlvbi5tZXNzYWdlKTt9fWNhdGNoKGVycil7Ly8gSWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIGhhbmRsaW5nIGFuIGVycm9yLCBsb2cgaXRcbnRoaXMubG9nZ2VyLmVycm9yKEhBTkRMRV9FUlJPUl9GQUlMVVJFKEVSUk9SX0hBTkRMRVIpLGVycik7fX0vKipcbiAgICogQWRkIGJyZWFkY3J1bWJzIHRvIGFkZCBpbnNpZ2h0IG9mIGEgdXNlcidzIGpvdXJuZXkgYmVmb3JlIGFuIGVycm9yXG4gICAqIG9jY3VycmVkIGFuZCBzZW5kIHRvIGV4dGVybmFsIGVycm9yIG1vbml0b3Jpbmcgc2VydmljZSB2aWEgYSBwbHVnaW5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJyZWFkY3J1bWIgYnJlYWRjcnVtYnMgbWVzc2FnZVxuICAgKi9sZWF2ZUJyZWFkY3J1bWIoYnJlYWRjcnVtYil7dHJ5e3N0YXRlLnJlcG9ydGluZy5icmVhZGNydW1icy52YWx1ZT1bLi4uc3RhdGUucmVwb3J0aW5nLmJyZWFkY3J1bWJzLnZhbHVlLGNyZWF0ZU5ld0JyZWFkY3J1bWIoYnJlYWRjcnVtYildO31jYXRjaChlcnIpe3RoaXMub25FcnJvcih7ZXJyb3I6ZXJyLGNvbnRleHQ6RVJST1JfSEFORExFUixjdXN0b21NZXNzYWdlOkJSRUFEQ1JVTUJfRVJST1IsZ3JvdXBpbmdIYXNoOkJSRUFEQ1JVTUJfRVJST1J9KTt9fX0vLyBOb3RlOiBSZW1lbWJlciB0byBjYWxsIGRlZmF1bHRFcnJvckhhbmRsZXIuaW5pdCgpIGJlZm9yZSB1c2luZyBpdFxuY29uc3QgZGVmYXVsdEVycm9ySGFuZGxlcj1uZXcgRXJyb3JIYW5kbGVyKGRlZmF1bHRIdHRwQ2xpZW50LGRlZmF1bHRMb2dnZXIpO1xuXG4vLyAgdG8gbmV4dCBvciByZXR1cm4gdGhlIHZhbHVlIGlmIGl0IGlzIHRoZSBsYXN0IG9uZSBpbnN0ZWFkIG9mIGFuIGFycmF5IHBlclxuLy8gIHBsdWdpbiB0aGF0IGlzIHRoZSBub3JtYWwgaW52b2tlXG4vLyBUT0RPOiBhZGQgaW52b2tlIG1ldGhvZCBmb3IgZXh0ZW5zaW9uIHBvaW50IHRoYXQgd2Uga25vdyBvbmx5IG9uZSBwbHVnaW4gY2FuIGJlIHVzZWQuIGFkZCBpbnZva2VNdWx0aXBsZSBhbmQgaW52b2tlU2luZ2xlIG1ldGhvZHNcbmNsYXNzIFBsdWdpbkVuZ2luZXtwbHVnaW5zPVtdO2J5TmFtZT17fTtjYWNoZT17fTtjb25maWc9e3Rocm93czp0cnVlfTtjb25zdHJ1Y3Rvcihsb2dnZXIsb3B0aW9ucz17fSl7dGhpcy5jb25maWc9e3Rocm93czp0cnVlLC4uLm9wdGlvbnN9O3RoaXMubG9nZ2VyPWxvZ2dlcjt9cmVnaXN0ZXIocGx1Z2luLHN0YXRlKXtpZighcGx1Z2luLm5hbWUpe2NvbnN0IGVycm9yTWVzc2FnZT1QTFVHSU5fTkFNRV9NSVNTSU5HX0VSUk9SKFBMVUdJTl9FTkdJTkUpO2lmKHRoaXMuY29uZmlnLnRocm93cyl7dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7fWVsc2Uge3RoaXMubG9nZ2VyLmVycm9yKGVycm9yTWVzc2FnZSxwbHVnaW4pO3JldHVybjt9fWlmKHRoaXMuYnlOYW1lW3BsdWdpbi5uYW1lXSl7Y29uc3QgZXJyb3JNZXNzYWdlPVBMVUdJTl9BTFJFQURZX0VYSVNUU19FUlJPUihQTFVHSU5fRU5HSU5FLHBsdWdpbi5uYW1lKTtpZih0aGlzLmNvbmZpZy50aHJvd3Mpe3Rocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO31lbHNlIHt0aGlzLmxvZ2dlci5lcnJvcihlcnJvck1lc3NhZ2UpO3JldHVybjt9fXRoaXMuY2FjaGU9e307dGhpcy5wbHVnaW5zPXRoaXMucGx1Z2lucy5zbGljZSgpO2xldCBwb3M9dGhpcy5wbHVnaW5zLmxlbmd0aDt0aGlzLnBsdWdpbnMuZm9yRWFjaCgocGx1Z2luSXRlbSxpbmRleCk9PntpZihwbHVnaW5JdGVtLmRlcHM/LmluY2x1ZGVzKHBsdWdpbi5uYW1lKSl7cG9zPU1hdGgubWluKHBvcyxpbmRleCk7fX0pO3RoaXMucGx1Z2lucy5zcGxpY2UocG9zLDAscGx1Z2luKTt0aGlzLmJ5TmFtZVtwbHVnaW4ubmFtZV09cGx1Z2luO2lmKGlzRnVuY3Rpb24ocGx1Z2luLmluaXRpYWxpemUpKXtwbHVnaW4uaW5pdGlhbGl6ZShzdGF0ZSk7fX11bnJlZ2lzdGVyKG5hbWUpe2NvbnN0IHBsdWdpbj10aGlzLmJ5TmFtZVtuYW1lXTtpZighcGx1Z2luKXtjb25zdCBlcnJvck1lc3NhZ2U9UExVR0lOX05PVF9GT1VORF9FUlJPUihQTFVHSU5fRU5HSU5FLG5hbWUpO2lmKHRoaXMuY29uZmlnLnRocm93cyl7dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7fWVsc2Uge3RoaXMubG9nZ2VyLmVycm9yKGVycm9yTWVzc2FnZSk7cmV0dXJuO319Y29uc3QgaW5kZXg9dGhpcy5wbHVnaW5zLmluZGV4T2YocGx1Z2luKTtpZihpbmRleD09PS0xKXtjb25zdCBlcnJvck1lc3NhZ2U9UExVR0lOX0VOR0lORV9CVUdfRVJST1IoUExVR0lOX0VOR0lORSxuYW1lKTtpZih0aGlzLmNvbmZpZy50aHJvd3Mpe3Rocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO31lbHNlIHt0aGlzLmxvZ2dlci5lcnJvcihlcnJvck1lc3NhZ2UpO3JldHVybjt9fXRoaXMuY2FjaGU9e307ZGVsZXRlIHRoaXMuYnlOYW1lW25hbWVdO3RoaXMucGx1Z2lucz10aGlzLnBsdWdpbnMuc2xpY2UoKTt0aGlzLnBsdWdpbnMuc3BsaWNlKGluZGV4LDEpO31nZXRQbHVnaW4obmFtZSl7cmV0dXJuIHRoaXMuYnlOYW1lW25hbWVdO31nZXRQbHVnaW5zKGV4dFBvaW50KXtjb25zdCBsaWZlQ3ljbGVOYW1lPWV4dFBvaW50Pz8nLic7aWYoIXRoaXMuY2FjaGVbbGlmZUN5Y2xlTmFtZV0pe3RoaXMuY2FjaGVbbGlmZUN5Y2xlTmFtZV09dGhpcy5wbHVnaW5zLmZpbHRlcihwbHVnaW49PntpZihwbHVnaW4uZGVwcz8uc29tZShkZXBlbmRlbmN5PT4hdGhpcy5ieU5hbWVbZGVwZW5kZW5jeV0pKXsvLyBJZiBkZXBzIG5vdCBleGlzdCwgdGhlbiBub3QgbG9hZCBpdC5cbmNvbnN0IG5vdEV4aXN0RGVwcz1wbHVnaW4uZGVwcy5maWx0ZXIoZGVwZW5kZW5jeT0+IXRoaXMuYnlOYW1lW2RlcGVuZGVuY3ldKTt0aGlzLmxvZ2dlci5lcnJvcihQTFVHSU5fREVQU19FUlJPUihQTFVHSU5fRU5HSU5FLHBsdWdpbi5uYW1lLG5vdEV4aXN0RGVwcykpO3JldHVybiBmYWxzZTt9cmV0dXJuIGxpZmVDeWNsZU5hbWU9PT0nLic/dHJ1ZTpoYXNWYWx1ZUJ5UGF0aChwbHVnaW4sbGlmZUN5Y2xlTmFtZSk7fSk7fXJldHVybiB0aGlzLmNhY2hlW2xpZmVDeWNsZU5hbWVdO30vLyBUaGlzIG1ldGhvZCBhbGxvd3MgdG8gcHJvY2VzcyB0aGlzLnBsdWdpbnMgc28gdGhhdCBpdCBjb3VsZFxuLy8gZG8gc29tZSB1bmlmaWVkIHByZS1wcm9jZXNzIGJlZm9yZSBhcHBsaWNhdGlvbiBzdGFydHMuXG5wcm9jZXNzUmF3UGx1Z2lucyhjYWxsYmFjayl7Y2FsbGJhY2sodGhpcy5wbHVnaW5zKTt0aGlzLmNhY2hlPXt9O31pbnZva2UoZXh0UG9pbnQsYWxsb3dNdWx0aXBsZT10cnVlLC4uLmFyZ3Mpe2xldCBleHRlbnNpb25Qb2ludE5hbWU9ZXh0UG9pbnQ7aWYoIWV4dGVuc2lvblBvaW50TmFtZSl7dGhyb3cgbmV3IEVycm9yKFBMVUdJTl9FWFRfUE9JTlRfTUlTU0lOR19FUlJPUik7fWNvbnN0IG5vQ2FsbD1leHRlbnNpb25Qb2ludE5hbWUuc3RhcnRzV2l0aCgnIScpO2NvbnN0IHRocm93cz10aGlzLmNvbmZpZy50aHJvd3M/P2V4dGVuc2lvblBvaW50TmFtZS5lbmRzV2l0aCgnIScpOy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxuZXh0ZW5zaW9uUG9pbnROYW1lPWV4dGVuc2lvblBvaW50TmFtZS5yZXBsYWNlKC8oXiF8ISQpL2csJycpO2lmKCFleHRlbnNpb25Qb2ludE5hbWUpe3Rocm93IG5ldyBFcnJvcihQTFVHSU5fRVhUX1BPSU5UX0lOVkFMSURfRVJST1IpO31jb25zdCBleHRlbnNpb25Qb2ludE5hbWVQYXJ0cz1leHRlbnNpb25Qb2ludE5hbWUuc3BsaXQoJy4nKTtleHRlbnNpb25Qb2ludE5hbWVQYXJ0cy5wb3AoKTtjb25zdCBwbHVnaW5NZXRob2RQYXRoPWV4dGVuc2lvblBvaW50TmFtZVBhcnRzLmpvaW4oJy4nKTtjb25zdCBwbHVnaW5zVG9JbnZva2U9YWxsb3dNdWx0aXBsZT90aGlzLmdldFBsdWdpbnMoZXh0ZW5zaW9uUG9pbnROYW1lKTpbdGhpcy5nZXRQbHVnaW5zKGV4dGVuc2lvblBvaW50TmFtZSlbMF1dO3JldHVybiBwbHVnaW5zVG9JbnZva2UubWFwKHBsdWdpbj0+e2NvbnN0IG1ldGhvZD1nZXRWYWx1ZUJ5UGF0aChwbHVnaW4sZXh0ZW5zaW9uUG9pbnROYW1lKTtpZighaXNGdW5jdGlvbihtZXRob2QpfHxub0NhbGwpe3JldHVybiBtZXRob2Q7fXRyeXtyZXR1cm4gbWV0aG9kLmFwcGx5KGdldFZhbHVlQnlQYXRoKHBsdWdpbixwbHVnaW5NZXRob2RQYXRoKSxhcmdzKTt9Y2F0Y2goZXJyKXsvLyBXaGVuIGEgcGx1Z2luIGZhaWxlZCwgZG9lc24ndCBicmVhayB0aGUgYXBwXG5pZih0aHJvd3Mpe3Rocm93IGVycjt9ZWxzZSB7dGhpcy5sb2dnZXIuZXJyb3IoUExVR0lOX0lOVk9DQVRJT05fRVJST1IoUExVR0lOX0VOR0lORSxleHRlbnNpb25Qb2ludE5hbWUscGx1Z2luLm5hbWUpLGVycik7fX1yZXR1cm4gbnVsbDt9KTt9aW52b2tlU2luZ2xlKGV4dFBvaW50LC4uLmFyZ3Mpe3JldHVybiB0aGlzLmludm9rZShleHRQb2ludCxmYWxzZSwuLi5hcmdzKVswXTt9aW52b2tlTXVsdGlwbGUoZXh0UG9pbnQsLi4uYXJncyl7cmV0dXJuIHRoaXMuaW52b2tlKGV4dFBvaW50LHRydWUsLi4uYXJncyk7fX1jb25zdCBkZWZhdWx0UGx1Z2luRW5naW5lPW5ldyBQbHVnaW5FbmdpbmUoZGVmYXVsdExvZ2dlcix7dGhyb3dzOnRydWV9KTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGZpbHRlciBhbmQgcmV0dXJuIG5vbiBjbG91ZCBtb2RlIGRlc3RpbmF0aW9uc1xuICogQSBkZXN0aW5hdGlvbiBpcyBjb25zaWRlcmVkIG5vbiBjbG91ZCBtb2RlIGlmIGl0IGlzIG5vdCBhIGNsb3VkIG1vZGUgZGVzdGluYXRpb24gb3IgaWYgaXQgaXMgYSBoeWJyaWQgbW9kZSBkZXN0aW5hdGlvblxuICogQHBhcmFtIGRlc3RpbmF0aW9uXG4gKlxuICogQHJldHVybnMgYm9vbGVhblxuICovY29uc3QgaXNOb25DbG91ZERlc3RpbmF0aW9uPWRlc3RpbmF0aW9uPT5Cb29sZWFuKGRlc3RpbmF0aW9uLmNvbmZpZy5jb25uZWN0aW9uTW9kZSE9PSdjbG91ZCd8fGRlc3RpbmF0aW9uLmNvbmZpZy51c2VOYXRpdmVTREtUb1NlbmQ9PT10cnVlfHwvLyB0aGlzIGlzIHRoZSBvbGRlciBmbGFnIGZvciBoeWJyaWQgbW9kZSBkZXN0aW5hdGlvbnNcbmRlc3RpbmF0aW9uLmNvbmZpZy51c2VOYXRpdmVTREs9PT10cnVlKTtjb25zdCBpc0h5YnJpZE1vZGVEZXN0aW5hdGlvbj1kZXN0aW5hdGlvbj0+Qm9vbGVhbihkZXN0aW5hdGlvbi5jb25maWcuY29ubmVjdGlvbk1vZGU9PT0naHlicmlkJ3x8ZGVzdGluYXRpb24uY29uZmlnLnVzZU5hdGl2ZVNES1RvU2VuZD09PXRydWUpOy8qKlxuICogQSBmdW5jdGlvbiB0byBmaWx0ZXIgYW5kIHJldHVybiBub24gY2xvdWQgbW9kZSBkZXN0aW5hdGlvbnNcbiAqIEBwYXJhbSBkZXN0aW5hdGlvbnNcbiAqXG4gKiBAcmV0dXJucyBkZXN0aW5hdGlvbnNcbiAqL2NvbnN0IGdldE5vbkNsb3VkRGVzdGluYXRpb25zPWRlc3RpbmF0aW9ucz0+ZGVzdGluYXRpb25zLmZpbHRlcihpc05vbkNsb3VkRGVzdGluYXRpb24pOy8qKlxuICogQSBmdW5jdGlvbiB0byBnZXQgdGhlIHVzZXIgZnJpZW5kbHkgaWQgZm9yIGEgZGVzdGluYXRpb25cbiAqIFJlcGxhY2VzIGFsbCBzcGFjZXMgd2l0aCBoeXBoZW5zIGFuZCBhcHBlbmRzIHRoZSBpZCB0byB0aGUgZGlzcGxheSBuYW1lXG4gKiBAcGFyYW0gZGlzcGxheU5hbWUgVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgZGVzdGluYXRpb25cbiAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGRlc3RpbmF0aW9uXG4gKlxuICogQHJldHVybnMgdGhlIHVzZXIgZnJpZW5kbHkgaWRcbiAqL2NvbnN0IGdldERlc3RpbmF0aW9uVXNlckZyaWVuZGx5SWQ9KGRpc3BsYXlOYW1lLGlkKT0+YCR7ZGlzcGxheU5hbWUucmVwbGFjZUFsbCgnICcsJy0nKX1fX18ke2lkfWA7XG5cbi8qKlxuICogTGlzdCBvZiBwbHVnaW4gbmFtZXMgdGhhdCBhcmUgbG9hZGVkIGFzIGR5bmFtaWMgaW1wb3J0cyBpbiBtb2Rlcm4gYnVpbGRzXG4gKi9jb25zdCBwbHVnaW5OYW1lc0xpc3Q9WydCZWFjb25RdWV1ZScsJ0N1c3RvbUNvbnNlbnRNYW5hZ2VyJywnRGV2aWNlTW9kZURlc3RpbmF0aW9ucycsJ0RldmljZU1vZGVUcmFuc2Zvcm1hdGlvbicsJ0V4dGVybmFsQW5vbnltb3VzSWQnLCdHb29nbGVMaW5rZXInLCdJdWJlbmRhQ29uc2VudE1hbmFnZXInLCdLZXRjaENvbnNlbnRNYW5hZ2VyJywnTmF0aXZlRGVzdGluYXRpb25RdWV1ZScsJ09uZVRydXN0Q29uc2VudE1hbmFnZXInLCdTdG9yYWdlRW5jcnlwdGlvbicsJ1N0b3JhZ2VFbmNyeXB0aW9uTGVnYWN5JywnU3RvcmFnZU1pZ3JhdG9yJywnWGhyUXVldWUnXTtjb25zdCBkZXByZWNhdGVkUGx1Z2luc0xpc3Q9WydCdWdzbmFnJywnRXJyb3JSZXBvcnRpbmcnXTtcblxuY29uc3QgcmVtb3Rlc01hcCA9IHtcbidydWRkZXJBbmFseXRpY3NSZW1vdGVQbHVnaW5zJzp7dXJsOigpPT5Qcm9taXNlLnJlc29sdmUod2luZG93LlJ1ZGRlclN0YWNrR2xvYmFscyAmJiB3aW5kb3cuUnVkZGVyU3RhY2tHbG9iYWxzLmFwcCAmJiB3aW5kb3cuUnVkZGVyU3RhY2tHbG9iYWxzLmFwcC5wbHVnaW5zQ0ROUGF0aCA/IGAke3dpbmRvdy5SdWRkZXJTdGFja0dsb2JhbHMuYXBwLnBsdWdpbnNDRE5QYXRofS9yc2EtcGx1Z2lucy5qc2AgOiBgaHR0cHM6Ly9jZG4ucnVkZGVybGFicy5jb20vdjMvbW9kZXJuL3BsdWdpbnMvL3JzYS1wbHVnaW5zLmpzYCksZm9ybWF0Oidlc20nLGZyb206J3ZpdGUnfVxufTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtZXJnZShvYmoxLCBvYmoyKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWRPYmogPSBPYmplY3QuYXNzaWduKG9iajEsIG9iajIpO1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWVyZ2VkT2JqKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lcmdlZE9ialtrZXldID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqMltrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZE9ialtrZXldID0gbWVyZ2UobWVyZ2VkT2JqW2tleV0sIG9iajJba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZWRPYmo7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcFNoYXJlTW9kdWxlID0gcmVtb3RlRnJvbSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIH0sIChnbG9iYWxUaGlzLl9fZmVkZXJhdGlvbl9zaGFyZWRfXyB8fCB7fSlbJ2RlZmF1bHQnXSB8fCB7fSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIF9fZmVkZXJhdGlvbl9tZXRob2RfZW5zdXJlKHJlbW90ZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZSA9IHJlbW90ZXNNYXBbcmVtb3RlSWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbW90ZS5pbml0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbJ2VzbScsICdzeXN0ZW1qcyddLmluY2x1ZGVzKHJlbW90ZS5mb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9hZGluZyBqcyB3aXRoIGltcG9ydCguLi4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0VXJsID0gdHlwZW9mIHJlbW90ZS51cmwgPT09ICdmdW5jdGlvbicgPyByZW1vdGUudXJsIDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHJlbW90ZS51cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRVcmwoKS50aGVuKHVybCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyAvKiBAdml0ZS1pZ25vcmUgKi8gdXJsKS50aGVuKGxpYiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZW1vdGUuaW5pdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlU2NvcGUgPSB3cmFwU2hhcmVNb2R1bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliLmluaXQoc2hhcmVTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZS5saWIgPSBsaWI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZS5saWIuaW5pdChzaGFyZVNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlLmluaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVtb3RlLmxpYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW90ZS5saWI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfX2ZlZGVyYXRpb25fbWV0aG9kX3dyYXBEZWZhdWx0KG1vZHVsZSwgbmVlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1vZHVsZT8uZGVmYXVsdCAmJiBuZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5kZWZhdWx0ID0gbW9kdWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLl9fZXNNb2R1bGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9fZmVkZXJhdGlvbl9tZXRob2RfZ2V0UmVtb3RlKHJlbW90ZU5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZmVkZXJhdGlvbl9tZXRob2RfZW5zdXJlKHJlbW90ZU5hbWUpLnRoZW4oKHJlbW90ZSkgPT4gcmVtb3RlLmdldChjb21wb25lbnROYW1lKS50aGVuKGZhY3RvcnkgPT4gZmFjdG9yeSgpKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4vKipcbiAqIEdldCB0aGUgbGF6eSBsb2FkZWQgZHluYW1pYyBpbXBvcnQgZm9yIGEgcGx1Z2luIG5hbWVcbiAqL2NvbnN0IGdldEZlZGVyYXRlZE1vZHVsZUltcG9ydD1wbHVnaW5OYW1lPT57c3dpdGNoKHBsdWdpbk5hbWUpe2Nhc2UgJ0JlYWNvblF1ZXVlJzpyZXR1cm4gKCk9Pl9fZmVkZXJhdGlvbl9tZXRob2RfZ2V0UmVtb3RlKFwicnVkZGVyQW5hbHl0aWNzUmVtb3RlUGx1Z2luc1wiICwgXCIuL0JlYWNvblF1ZXVlXCIpLnRoZW4obW9kdWxlPT5fX2ZlZGVyYXRpb25fbWV0aG9kX3dyYXBEZWZhdWx0KG1vZHVsZSwgdHJ1ZSkpO2Nhc2UgJ0N1c3RvbUNvbnNlbnRNYW5hZ2VyJzpyZXR1cm4gKCk9Pl9fZmVkZXJhdGlvbl9tZXRob2RfZ2V0UmVtb3RlKFwicnVkZGVyQW5hbHl0aWNzUmVtb3RlUGx1Z2luc1wiICwgXCIuL0N1c3RvbUNvbnNlbnRNYW5hZ2VyXCIpLnRoZW4obW9kdWxlPT5fX2ZlZGVyYXRpb25fbWV0aG9kX3dyYXBEZWZhdWx0KG1vZHVsZSwgdHJ1ZSkpO2Nhc2UgJ0RldmljZU1vZGVEZXN0aW5hdGlvbnMnOnJldHVybiAoKT0+X19mZWRlcmF0aW9uX21ldGhvZF9nZXRSZW1vdGUoXCJydWRkZXJBbmFseXRpY3NSZW1vdGVQbHVnaW5zXCIgLCBcIi4vRGV2aWNlTW9kZURlc3RpbmF0aW9uc1wiKS50aGVuKG1vZHVsZT0+X19mZWRlcmF0aW9uX21ldGhvZF93cmFwRGVmYXVsdChtb2R1bGUsIHRydWUpKTtjYXNlICdEZXZpY2VNb2RlVHJhbnNmb3JtYXRpb24nOnJldHVybiAoKT0+X19mZWRlcmF0aW9uX21ldGhvZF9nZXRSZW1vdGUoXCJydWRkZXJBbmFseXRpY3NSZW1vdGVQbHVnaW5zXCIgLCBcIi4vRGV2aWNlTW9kZVRyYW5zZm9ybWF0aW9uXCIpLnRoZW4obW9kdWxlPT5fX2ZlZGVyYXRpb25fbWV0aG9kX3dyYXBEZWZhdWx0KG1vZHVsZSwgdHJ1ZSkpO2Nhc2UgJ0V4dGVybmFsQW5vbnltb3VzSWQnOnJldHVybiAoKT0+X19mZWRlcmF0aW9uX21ldGhvZF9nZXRSZW1vdGUoXCJydWRkZXJBbmFseXRpY3NSZW1vdGVQbHVnaW5zXCIgLCBcIi4vRXh0ZXJuYWxBbm9ueW1vdXNJZFwiKS50aGVuKG1vZHVsZT0+X19mZWRlcmF0aW9uX21ldGhvZF93cmFwRGVmYXVsdChtb2R1bGUsIHRydWUpKTtjYXNlICdHb29nbGVMaW5rZXInOnJldHVybiAoKT0+X19mZWRlcmF0aW9uX21ldGhvZF9nZXRSZW1vdGUoXCJydWRkZXJBbmFseXRpY3NSZW1vdGVQbHVnaW5zXCIgLCBcIi4vR29vZ2xlTGlua2VyXCIpLnRoZW4obW9kdWxlPT5fX2ZlZGVyYXRpb25fbWV0aG9kX3dyYXBEZWZhdWx0KG1vZHVsZSwgdHJ1ZSkpO2Nhc2UgJ0tldGNoQ29uc2VudE1hbmFnZXInOnJldHVybiAoKT0+X19mZWRlcmF0aW9uX21ldGhvZF9nZXRSZW1vdGUoXCJydWRkZXJBbmFseXRpY3NSZW1vdGVQbHVnaW5zXCIgLCBcIi4vS2V0Y2hDb25zZW50TWFuYWdlclwiKS50aGVuKG1vZHVsZT0+X19mZWRlcmF0aW9uX21ldGhvZF93cmFwRGVmYXVsdChtb2R1bGUsIHRydWUpKTtjYXNlICdJdWJlbmRhQ29uc2VudE1hbmFnZXInOnJldHVybiAoKT0+X19mZWRlcmF0aW9uX21ldGhvZF9nZXRSZW1vdGUoXCJydWRkZXJBbmFseXRpY3NSZW1vdGVQbHVnaW5zXCIgLCBcIi4vSXViZW5kYUNvbnNlbnRNYW5hZ2VyXCIpLnRoZW4obW9kdWxlPT5fX2ZlZGVyYXRpb25fbWV0aG9kX3dyYXBEZWZhdWx0KG1vZHVsZSwgdHJ1ZSkpO2Nhc2UgJ05hdGl2ZURlc3RpbmF0aW9uUXVldWUnOnJldHVybiAoKT0+X19mZWRlcmF0aW9uX21ldGhvZF9nZXRSZW1vdGUoXCJydWRkZXJBbmFseXRpY3NSZW1vdGVQbHVnaW5zXCIgLCBcIi4vTmF0aXZlRGVzdGluYXRpb25RdWV1ZVwiKS50aGVuKG1vZHVsZT0+X19mZWRlcmF0aW9uX21ldGhvZF93cmFwRGVmYXVsdChtb2R1bGUsIHRydWUpKTtjYXNlICdPbmVUcnVzdENvbnNlbnRNYW5hZ2VyJzpyZXR1cm4gKCk9Pl9fZmVkZXJhdGlvbl9tZXRob2RfZ2V0UmVtb3RlKFwicnVkZGVyQW5hbHl0aWNzUmVtb3RlUGx1Z2luc1wiICwgXCIuL09uZVRydXN0Q29uc2VudE1hbmFnZXJcIikudGhlbihtb2R1bGU9Pl9fZmVkZXJhdGlvbl9tZXRob2Rfd3JhcERlZmF1bHQobW9kdWxlLCB0cnVlKSk7Y2FzZSAnU3RvcmFnZUVuY3J5cHRpb24nOnJldHVybiAoKT0+X19mZWRlcmF0aW9uX21ldGhvZF9nZXRSZW1vdGUoXCJydWRkZXJBbmFseXRpY3NSZW1vdGVQbHVnaW5zXCIgLCBcIi4vU3RvcmFnZUVuY3J5cHRpb25cIikudGhlbihtb2R1bGU9Pl9fZmVkZXJhdGlvbl9tZXRob2Rfd3JhcERlZmF1bHQobW9kdWxlLCB0cnVlKSk7Y2FzZSAnU3RvcmFnZUVuY3J5cHRpb25MZWdhY3knOnJldHVybiAoKT0+X19mZWRlcmF0aW9uX21ldGhvZF9nZXRSZW1vdGUoXCJydWRkZXJBbmFseXRpY3NSZW1vdGVQbHVnaW5zXCIgLCBcIi4vU3RvcmFnZUVuY3J5cHRpb25MZWdhY3lcIikudGhlbihtb2R1bGU9Pl9fZmVkZXJhdGlvbl9tZXRob2Rfd3JhcERlZmF1bHQobW9kdWxlLCB0cnVlKSk7Y2FzZSAnU3RvcmFnZU1pZ3JhdG9yJzpyZXR1cm4gKCk9Pl9fZmVkZXJhdGlvbl9tZXRob2RfZ2V0UmVtb3RlKFwicnVkZGVyQW5hbHl0aWNzUmVtb3RlUGx1Z2luc1wiICwgXCIuL1N0b3JhZ2VNaWdyYXRvclwiKS50aGVuKG1vZHVsZT0+X19mZWRlcmF0aW9uX21ldGhvZF93cmFwRGVmYXVsdChtb2R1bGUsIHRydWUpKTtjYXNlICdYaHJRdWV1ZSc6cmV0dXJuICgpPT5fX2ZlZGVyYXRpb25fbWV0aG9kX2dldFJlbW90ZShcInJ1ZGRlckFuYWx5dGljc1JlbW90ZVBsdWdpbnNcIiAsIFwiLi9YaHJRdWV1ZVwiKS50aGVuKG1vZHVsZT0+X19mZWRlcmF0aW9uX21ldGhvZF93cmFwRGVmYXVsdChtb2R1bGUsIHRydWUpKTtkZWZhdWx0OnJldHVybiB1bmRlZmluZWQ7fX07LyoqXG4gKiBNYXAgb2YgYWN0aXZlIHBsdWdpbiBuYW1lcyB0byB0aGVpciBkeW5hbWljIGltcG9ydFxuICovY29uc3QgZmVkZXJhdGVkTW9kdWxlc0J1aWxkUGx1Z2luSW1wb3J0cz1hY3RpdmVQbHVnaW5OYW1lcz0+e2NvbnN0IHJlbW90ZVBsdWdpbnM9e307YWN0aXZlUGx1Z2luTmFtZXMuZm9yRWFjaChwbHVnaW5OYW1lPT57aWYocGx1Z2luTmFtZXNMaXN0LmluY2x1ZGVzKHBsdWdpbk5hbWUpKXtjb25zdCBsYXp5TG9hZEltcG9ydD1nZXRGZWRlcmF0ZWRNb2R1bGVJbXBvcnQocGx1Z2luTmFtZSk7aWYobGF6eUxvYWRJbXBvcnQpe3JlbW90ZVBsdWdpbnNbcGx1Z2luTmFtZV09bGF6eUxvYWRJbXBvcnQ7fX19KTtyZXR1cm4gcmVtb3RlUGx1Z2luczt9O1xuXG4vKipcbiAqIE1hcCBvZiBtYW5kYXRvcnkgcGx1Z2luIG5hbWVzIGFuZCBkaXJlY3QgaW1wb3J0c1xuICovY29uc3QgZ2V0TWFuZGF0b3J5UGx1Z2luc01hcD0oKT0+KHt9KTsvKipcbiAqIE1hcCBvZiBvcHRpb25hbCBwbHVnaW4gbmFtZXMgYW5kIGRpcmVjdCBpbXBvcnRzIGZvciBsZWdhY3kgYnVpbGRzXG4gKi9jb25zdCBnZXRPcHRpb25hbFBsdWdpbnNNYXA9KCk9Pnt7cmV0dXJuIHt9O319Oy8qKlxuICogTWFwIG9mIG9wdGlvbmFsIHBsdWdpbiBuYW1lcyBhbmQgZHluYW1pYyBpbXBvcnRzIGZvciBtb2Rlcm4gYnVpbGRzXG4gKi9jb25zdCBnZXRSZW1vdGVQbHVnaW5zTWFwPWFjdGl2ZVBsdWdpbk5hbWVzPT57cmV0dXJuIGZlZGVyYXRlZE1vZHVsZXNCdWlsZFBsdWdpbkltcG9ydHM/LihhY3RpdmVQbHVnaW5OYW1lcyl8fHt9O307Y29uc3QgcGx1Z2luc0ludmVudG9yeT17Li4uZ2V0TWFuZGF0b3J5UGx1Z2luc01hcCgpLC4uLmdldE9wdGlvbmFsUGx1Z2luc01hcCgpfTtjb25zdCByZW1vdGVQbHVnaW5zSW52ZW50b3J5PWFjdGl2ZVBsdWdpbk5hbWVzPT4oey4uLmdldFJlbW90ZVBsdWdpbnNNYXAoYWN0aXZlUGx1Z2luTmFtZXMpfSk7XG5cbi8vIFRPRE86IGFkZCByZXRyeSBtZWNoYW5pc20gZm9yIGdldHRpbmcgcmVtb3RlIHBsdWdpbnNcbi8vIFRPRE86IGFkZCB0aW1lb3V0IGVycm9yIG1lY2hhbmlzbSBmb3IgbWFya2luZyByZW1vdGUgcGx1Z2lucyB0aGF0IGZhaWxlZCB0byBsb2FkIGFzIGZhaWxlZCBpbiBzdGF0ZVxuY2xhc3MgUGx1Z2luc01hbmFnZXJ7Y29uc3RydWN0b3IoZW5naW5lLGVycm9ySGFuZGxlcixsb2dnZXIpe3RoaXMuZW5naW5lPWVuZ2luZTt0aGlzLmVycm9ySGFuZGxlcj1lcnJvckhhbmRsZXI7dGhpcy5sb2dnZXI9bG9nZ2VyO3RoaXMub25FcnJvcj10aGlzLm9uRXJyb3IuYmluZCh0aGlzKTt9LyoqXG4gICAqIE9yY2hlc3RyYXRlIHRoZSBwbHVnaW4gbG9hZGluZyBhbmQgcmVnaXN0ZXJpbmdcbiAgICovaW5pdCgpe3N0YXRlLmxpZmVjeWNsZS5zdGF0dXMudmFsdWU9J3BsdWdpbnNMb2FkaW5nJzsvLyBFeHBvc2UgcGx1Z2luc0NETlBhdGggdG8gZ2xvYmFsIG9iamVjdCwgc28gaXQgY2FuIGJlIHVzZWQgaW4gdGhlIHByb21pc2UgdGhhdCBkZXRlcm1pbmVzXG4vLyByZW1vdGUgcGx1Z2luIGNkbiBwYXRoIHRvIHN1cHBvcnQgcHJveGllZCBwbHVnaW4gcmVtb3Rlc1xue3NldEV4cG9zZWRHbG9iYWwoJ3BsdWdpbnNDRE5QYXRoJyxzdGF0ZS5saWZlY3ljbGUucGx1Z2luc0NETlBhdGgudmFsdWUpO310aGlzLnNldEFjdGl2ZVBsdWdpbnMoKTt0aGlzLnJlZ2lzdGVyTG9jYWxQbHVnaW5zKCk7dGhpcy5yZWdpc3RlclJlbW90ZVBsdWdpbnMoKTt0aGlzLmF0dGFjaEVmZmVjdHMoKTt9LyoqXG4gICAqIFVwZGF0ZSBzdGF0ZSBiYXNlZCBvbiBwbHVnaW4gbG9hZGVkIHN0YXR1c1xuICAgKi8vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuYXR0YWNoRWZmZWN0cygpe0UoKCk9Pntjb25zdCBpc0FsbFBsdWdpbnNSZWFkeT1zdGF0ZS5wbHVnaW5zLmFjdGl2ZVBsdWdpbnMudmFsdWUubGVuZ3RoPT09MHx8c3RhdGUucGx1Z2lucy5sb2FkZWRQbHVnaW5zLnZhbHVlLmxlbmd0aCtzdGF0ZS5wbHVnaW5zLmZhaWxlZFBsdWdpbnMudmFsdWUubGVuZ3RoPT09c3RhdGUucGx1Z2lucy50b3RhbFBsdWdpbnNUb0xvYWQudmFsdWU7aWYoaXNBbGxQbHVnaW5zUmVhZHkpe3IoKCk9PntzdGF0ZS5wbHVnaW5zLnJlYWR5LnZhbHVlPXRydWU7Ly8gVE9ETzogZGVjaWRlIHdoYXQgdG8gZG8gaWYgYSBwbHVnaW4gZmFpbHMgdG8gbG9hZCBmb3IgYW55IHJlYXNvbi5cbi8vICBTaG91bGQgd2Ugc3RvcCBoZXJlIG9yIHNob3VsZCB3ZSBwcm9ncmVzcz9cbnN0YXRlLmxpZmVjeWNsZS5zdGF0dXMudmFsdWU9J3BsdWdpbnNSZWFkeSc7fSk7fX0pO30vKipcbiAgICogRGV0ZXJtaW5lIHRoZSBsaXN0IG9mIHBsdWdpbnMgdGhhdCBzaG91bGQgYmUgbG9hZGVkIGJhc2VkIG9uIHNvdXJjZUNvbmZpZyAmIGxvYWQgb3B0aW9uc1xuICAgKi8vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuZ2V0UGx1Z2luc1RvTG9hZEJhc2VkT25Db25maWcoKXsvLyBUaGlzIGNvbnRhaW5zIHRoZSBkZWZhdWx0IHBsdWdpbnMgaWYgbG9hZCBvcHRpb24gaGFzIGJlZW4gb21pdHRlZCBieSB1c2VyXG5sZXQgcGx1Z2luc1RvTG9hZEZyb21Db25maWc9c3RhdGUucGx1Z2lucy5wbHVnaW5zVG9Mb2FkRnJvbUNvbmZpZy52YWx1ZTtpZighcGx1Z2luc1RvTG9hZEZyb21Db25maWcpe3JldHVybiBbXTt9Ly8gRmlsdGVyIGRlcHJlY2F0ZWQgcGx1Z2luc1xucGx1Z2luc1RvTG9hZEZyb21Db25maWc9cGx1Z2luc1RvTG9hZEZyb21Db25maWcuZmlsdGVyKHBsdWdpbk5hbWU9PntpZihkZXByZWNhdGVkUGx1Z2luc0xpc3QuaW5jbHVkZXMocGx1Z2luTmFtZSkpe3RoaXMubG9nZ2VyLndhcm4oREVQUkVDQVRFRF9QTFVHSU5fV0FSTklORyhQTFVHSU5TX01BTkFHRVIscGx1Z2luTmFtZSkpO3JldHVybiBmYWxzZTt9cmV0dXJuIHRydWU7fSk7Y29uc3QgcGx1Z2luR3JvdXBzVG9Qcm9jZXNzPVt7Y29uZmlndXJhdGlvblN0YXR1czooKT0+aXNEZWZpbmVkKHN0YXRlLmRhdGFQbGFuZUV2ZW50cy5ldmVudHNRdWV1ZVBsdWdpbk5hbWUudmFsdWUpLGNvbmZpZ3VyYXRpb25TdGF0dXNTdHI6J0RhdGEgcGxhbmUgZXZlbnRzIGRlbGl2ZXJ5IGlzIGVuYWJsZWQnLGFjdGl2ZVBsdWdpbk5hbWU6c3RhdGUuZGF0YVBsYW5lRXZlbnRzLmV2ZW50c1F1ZXVlUGx1Z2luTmFtZS52YWx1ZSxzdXBwb3J0ZWRQbHVnaW5zOk9iamVjdC52YWx1ZXMoRGF0YVBsYW5lRXZlbnRzVHJhbnNwb3J0VG9QbHVnaW5OYW1lTWFwKSxzaG91bGRBZGRNaXNzaW5nUGx1Z2luczp0cnVlfSx7Y29uZmlndXJhdGlvblN0YXR1czooKT0+Z2V0Tm9uQ2xvdWREZXN0aW5hdGlvbnMoc3RhdGUubmF0aXZlRGVzdGluYXRpb25zLmNvbmZpZ3VyZWREZXN0aW5hdGlvbnMudmFsdWUpLmxlbmd0aD4wLGNvbmZpZ3VyYXRpb25TdGF0dXNTdHI6J0RldmljZSBtb2RlIGRlc3RpbmF0aW9ucyBhcmUgY29ubmVjdGVkIHRvIHRoZSBzb3VyY2UnLHN1cHBvcnRlZFBsdWdpbnM6WydEZXZpY2VNb2RlRGVzdGluYXRpb25zJywnTmF0aXZlRGVzdGluYXRpb25RdWV1ZSddfSx7Y29uZmlndXJhdGlvblN0YXR1czooKT0+Z2V0Tm9uQ2xvdWREZXN0aW5hdGlvbnMoc3RhdGUubmF0aXZlRGVzdGluYXRpb25zLmNvbmZpZ3VyZWREZXN0aW5hdGlvbnMudmFsdWUpLnNvbWUoZGVzdGluYXRpb249PmRlc3RpbmF0aW9uLnNob3VsZEFwcGx5RGV2aWNlTW9kZVRyYW5zZm9ybWF0aW9uKSxjb25maWd1cmF0aW9uU3RhdHVzU3RyOidEZXZpY2UgbW9kZSB0cmFuc2Zvcm1hdGlvbnMgYXJlIGVuYWJsZWQgZm9yIGF0IGxlYXN0IG9uZSBkZXN0aW5hdGlvbicsc3VwcG9ydGVkUGx1Z2luczpbJ0RldmljZU1vZGVUcmFuc2Zvcm1hdGlvbiddfSx7Y29uZmlndXJhdGlvblN0YXR1czooKT0+aXNEZWZpbmVkKHN0YXRlLmNvbnNlbnRzLmFjdGl2ZUNvbnNlbnRNYW5hZ2VyUGx1Z2luTmFtZS52YWx1ZSksY29uZmlndXJhdGlvblN0YXR1c1N0cjonQ29uc2VudCBtYW5hZ2VtZW50IGlzIGVuYWJsZWQnLGFjdGl2ZVBsdWdpbk5hbWU6c3RhdGUuY29uc2VudHMuYWN0aXZlQ29uc2VudE1hbmFnZXJQbHVnaW5OYW1lLnZhbHVlLHN1cHBvcnRlZFBsdWdpbnM6T2JqZWN0LnZhbHVlcyhDb25zZW50TWFuYWdlcnNUb1BsdWdpbk5hbWVNYXApfSx7Y29uZmlndXJhdGlvblN0YXR1czooKT0+aXNEZWZpbmVkKHN0YXRlLnN0b3JhZ2UuZW5jcnlwdGlvblBsdWdpbk5hbWUudmFsdWUpLGNvbmZpZ3VyYXRpb25TdGF0dXNTdHI6J1N0b3JhZ2UgZW5jcnlwdGlvbiBpcyBlbmFibGVkJyxhY3RpdmVQbHVnaW5OYW1lOnN0YXRlLnN0b3JhZ2UuZW5jcnlwdGlvblBsdWdpbk5hbWUudmFsdWUsc3VwcG9ydGVkUGx1Z2luczpPYmplY3QudmFsdWVzKFN0b3JhZ2VFbmNyeXB0aW9uVmVyc2lvbnNUb1BsdWdpbk5hbWVNYXApfSx7Y29uZmlndXJhdGlvblN0YXR1czooKT0+c3RhdGUuc3RvcmFnZS5taWdyYXRlLnZhbHVlLGNvbmZpZ3VyYXRpb25TdGF0dXNTdHI6J1N0b3JhZ2UgbWlncmF0aW9uIGlzIGVuYWJsZWQnLHN1cHBvcnRlZFBsdWdpbnM6WydTdG9yYWdlTWlncmF0b3InXX1dO2NvbnN0IGFkZE1pc3NpbmdQbHVnaW5zPWZhbHNlO3BsdWdpbkdyb3Vwc1RvUHJvY2Vzcy5mb3JFYWNoKGdyb3VwPT57aWYoZ3JvdXAuY29uZmlndXJhdGlvblN0YXR1cygpKXtwbHVnaW5zVG9Mb2FkRnJvbUNvbmZpZz1wbHVnaW5zVG9Mb2FkRnJvbUNvbmZpZy5maWx0ZXIoZ3JvdXAuYWN0aXZlUGx1Z2luTmFtZT9wbHVnaW5OYW1lPT4hKHBsdWdpbk5hbWUhPT1ncm91cC5hY3RpdmVQbHVnaW5OYW1lJiZncm91cC5zdXBwb3J0ZWRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbk5hbWUpKTpwbHVnaW5OYW1lPT5pc0RlZmluZWQocGx1Z2luTmFtZSkvLyBwYXNzIHRocm91Z2hcbik7dGhpcy5hZGRNaXNzaW5nUGx1Z2lucyhncm91cCxhZGRNaXNzaW5nUGx1Z2lucyxwbHVnaW5zVG9Mb2FkRnJvbUNvbmZpZyk7fWVsc2Uge3BsdWdpbnNUb0xvYWRGcm9tQ29uZmlnPXBsdWdpbnNUb0xvYWRGcm9tQ29uZmlnLmZpbHRlcihncm91cC5iYXNlUGx1Z2lucyE9PXVuZGVmaW5lZD9wbHVnaW5OYW1lPT4hKGdyb3VwLmJhc2VQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbk5hbWUpfHxncm91cC5zdXBwb3J0ZWRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbk5hbWUpKTpwbHVnaW5OYW1lPT4hZ3JvdXAuc3VwcG9ydGVkUGx1Z2lucy5pbmNsdWRlcyhwbHVnaW5OYW1lKSk7fX0pO3JldHVybiBbLi4uT2JqZWN0LmtleXMoZ2V0TWFuZGF0b3J5UGx1Z2luc01hcCgpKSwuLi5wbHVnaW5zVG9Mb2FkRnJvbUNvbmZpZ107fWFkZE1pc3NpbmdQbHVnaW5zKGdyb3VwLGFkZE1pc3NpbmdQbHVnaW5zLHBsdWdpbnNUb0xvYWRGcm9tQ29uZmlnKXtjb25zdCBzaG91bGRBZGRNaXNzaW5nUGx1Z2lucz1ncm91cC5zaG91bGRBZGRNaXNzaW5nUGx1Z2luc3x8YWRkTWlzc2luZ1BsdWdpbnM7bGV0IHBsdWdpbnNUb0NvbmZpZ3VyZTtpZihncm91cC5hY3RpdmVQbHVnaW5OYW1lKXtwbHVnaW5zVG9Db25maWd1cmU9Wy4uLihncm91cC5iYXNlUGx1Z2luc3x8W10pLGdyb3VwLmFjdGl2ZVBsdWdpbk5hbWVdO31lbHNlIHtwbHVnaW5zVG9Db25maWd1cmU9Wy4uLmdyb3VwLnN1cHBvcnRlZFBsdWdpbnNdO31jb25zdCBtaXNzaW5nUGx1Z2lucz1wbHVnaW5zVG9Db25maWd1cmUuZmlsdGVyKHBsdWdpbk5hbWU9PiFwbHVnaW5zVG9Mb2FkRnJvbUNvbmZpZy5pbmNsdWRlcyhwbHVnaW5OYW1lKSk7aWYobWlzc2luZ1BsdWdpbnMubGVuZ3RoPjApe2lmKHNob3VsZEFkZE1pc3NpbmdQbHVnaW5zKXtwbHVnaW5zVG9Mb2FkRnJvbUNvbmZpZy5wdXNoKC4uLm1pc3NpbmdQbHVnaW5zKTt9dGhpcy5sb2dnZXIud2FybihnZW5lcmF0ZU1pc2NvbmZpZ3VyZWRQbHVnaW5zV2FybmluZyhQTFVHSU5TX01BTkFHRVIsZ3JvdXAuY29uZmlndXJhdGlvblN0YXR1c1N0cixtaXNzaW5nUGx1Z2lucyxzaG91bGRBZGRNaXNzaW5nUGx1Z2lucykpO319LyoqXG4gICAqIERldGVybWluZSB0aGUgbGlzdCBvZiBwbHVnaW5zIHRoYXQgc2hvdWxkIGJlIGFjdGl2YXRlZFxuICAgKi9zZXRBY3RpdmVQbHVnaW5zKCl7Y29uc3QgcGx1Z2luc1RvTG9hZD10aGlzLmdldFBsdWdpbnNUb0xvYWRCYXNlZE9uQ29uZmlnKCk7Ly8gTWVyZ2luZyBhdmFpbGFibGUgbWFuZGF0b3J5IGFuZCBvcHRpb25hbCBwbHVnaW4gbmFtZSBsaXN0XG5jb25zdCBhdmFpbGFibGVQbHVnaW5zPVsuLi5PYmplY3Qua2V5cyhwbHVnaW5zSW52ZW50b3J5KSwuLi5wbHVnaW5OYW1lc0xpc3RdO2NvbnN0IGFjdGl2ZVBsdWdpbnM9W107Y29uc3QgZmFpbGVkUGx1Z2lucz1bXTtwbHVnaW5zVG9Mb2FkLmZvckVhY2gocGx1Z2luTmFtZT0+e2lmKGF2YWlsYWJsZVBsdWdpbnMuaW5jbHVkZXMocGx1Z2luTmFtZSkpe2FjdGl2ZVBsdWdpbnMucHVzaChwbHVnaW5OYW1lKTt9ZWxzZSB7ZmFpbGVkUGx1Z2lucy5wdXNoKHBsdWdpbk5hbWUpO319KTtpZihmYWlsZWRQbHVnaW5zLmxlbmd0aD4wKXt0aGlzLmxvZ2dlci53YXJuKFVOS05PV05fUExVR0lOU19XQVJOSU5HKFBMVUdJTlNfTUFOQUdFUixmYWlsZWRQbHVnaW5zKSk7fXIoKCk9PntzdGF0ZS5wbHVnaW5zLnRvdGFsUGx1Z2luc1RvTG9hZC52YWx1ZT1wbHVnaW5zVG9Mb2FkLmxlbmd0aDtzdGF0ZS5wbHVnaW5zLmFjdGl2ZVBsdWdpbnMudmFsdWU9YWN0aXZlUGx1Z2lucztzdGF0ZS5wbHVnaW5zLmZhaWxlZFBsdWdpbnMudmFsdWU9ZmFpbGVkUGx1Z2luczt9KTt9LyoqXG4gICAqIFJlZ2lzdGVyIHBsdWdpbnMgdGhhdCBhcmUgZGlyZWN0IGltcG9ydHMgdG8gUGx1Z2luRW5naW5lXG4gICAqL3JlZ2lzdGVyTG9jYWxQbHVnaW5zKCl7T2JqZWN0LnZhbHVlcyhwbHVnaW5zSW52ZW50b3J5KS5mb3JFYWNoKGxvY2FsUGx1Z2luPT57aWYoaXNGdW5jdGlvbihsb2NhbFBsdWdpbikmJnN0YXRlLnBsdWdpbnMuYWN0aXZlUGx1Z2lucy52YWx1ZS5pbmNsdWRlcyhsb2NhbFBsdWdpbigpLm5hbWUpKXt0aGlzLnJlZ2lzdGVyKFtsb2NhbFBsdWdpbigpXSk7fX0pO30vKipcbiAgICogUmVnaXN0ZXIgcGx1Z2lucyB0aGF0IGFyZSBkeW5hbWljIGltcG9ydHMgdG8gUGx1Z2luRW5naW5lXG4gICAqL3JlZ2lzdGVyUmVtb3RlUGx1Z2lucygpe2NvbnN0IHJlbW90ZVBsdWdpbnNMaXN0PXJlbW90ZVBsdWdpbnNJbnZlbnRvcnkoc3RhdGUucGx1Z2lucy5hY3RpdmVQbHVnaW5zLnZhbHVlKTtQcm9taXNlLmFsbChPYmplY3Qua2V5cyhyZW1vdGVQbHVnaW5zTGlzdCkubWFwKGFzeW5jIHJlbW90ZVBsdWdpbktleT0+e2F3YWl0IHJlbW90ZVBsdWdpbnNMaXN0W3JlbW90ZVBsdWdpbktleV0oKS50aGVuKHJlbW90ZVBsdWdpbk1vZHVsZT0+dGhpcy5yZWdpc3RlcihbcmVtb3RlUGx1Z2luTW9kdWxlLmRlZmF1bHQoKV0pKS5jYXRjaChlcnI9PnsvLyBUT0RPOiBhZGQgcmV0cnkgaGVyZSBpZiBkeW5hbWljIGltcG9ydCBmYWlsc1xuc3RhdGUucGx1Z2lucy5mYWlsZWRQbHVnaW5zLnZhbHVlPVsuLi5zdGF0ZS5wbHVnaW5zLmZhaWxlZFBsdWdpbnMudmFsdWUscmVtb3RlUGx1Z2luS2V5XTt0aGlzLm9uRXJyb3IoZXJyLGBGYWlsZWQgdG8gbG9hZCBwbHVnaW4gXCIke3JlbW90ZVBsdWdpbktleX1cImAsZXJyKTt9KTt9KSkuY2F0Y2goZXJyPT57dGhpcy5vbkVycm9yKGVycik7fSk7fS8qKlxuICAgKiBFeHRlbnNpb24gcG9pbnQgaW52b2tlIHRoYXQgYWxsb3dzIG11bHRpcGxlIHBsdWdpbnMgdG8gYmUgcmVnaXN0ZXJlZCB0byBpdCB3aXRoIGVycm9yIGhhbmRsaW5nXG4gICAqL2ludm9rZU11bHRpcGxlKGV4dFBvaW50LC4uLmFyZ3Mpe3RyeXtyZXR1cm4gdGhpcy5lbmdpbmUuaW52b2tlTXVsdGlwbGUoZXh0UG9pbnQsLi4uYXJncyk7fWNhdGNoKGUpe3RoaXMub25FcnJvcihlLGV4dFBvaW50KTtyZXR1cm4gW107fX0vKipcbiAgICogRXh0ZW5zaW9uIHBvaW50IGludm9rZSB0aGF0IGFsbG93cyBhIHNpbmdsZSBwbHVnaW4gdG8gYmUgcmVnaXN0ZXJlZCB0byBpdCB3aXRoIGVycm9yIGhhbmRsaW5nXG4gICAqL2ludm9rZVNpbmdsZShleHRQb2ludCwuLi5hcmdzKXt0cnl7cmV0dXJuIHRoaXMuZW5naW5lLmludm9rZVNpbmdsZShleHRQb2ludCwuLi5hcmdzKTt9Y2F0Y2goZSl7dGhpcy5vbkVycm9yKGUsZXh0UG9pbnQpO3JldHVybiBudWxsO319LyoqXG4gICAqIFBsdWdpbiBlbmdpbmUgcmVnaXN0ZXIgd2l0aCBlcnJvciBoYW5kbGluZ1xuICAgKi9yZWdpc3RlcihwbHVnaW5zKXtwbHVnaW5zLmZvckVhY2gocGx1Z2luPT57dHJ5e3RoaXMuZW5naW5lLnJlZ2lzdGVyKHBsdWdpbixzdGF0ZSk7fWNhdGNoKGUpe3N0YXRlLnBsdWdpbnMuZmFpbGVkUGx1Z2lucy52YWx1ZT1bLi4uc3RhdGUucGx1Z2lucy5mYWlsZWRQbHVnaW5zLnZhbHVlLHBsdWdpbi5uYW1lXTt0aGlzLm9uRXJyb3IoZSxgRmFpbGVkIHRvIHJlZ2lzdGVyIHBsdWdpbiBcIiR7cGx1Z2luLm5hbWV9XCJgKTt9fSk7fS8vIFRPRE86IEltcGxlbWVudCByZXNldCBBUEkgaW5zdGVhZFxudW5yZWdpc3RlckxvY2FsUGx1Z2lucygpe09iamVjdC52YWx1ZXMocGx1Z2luc0ludmVudG9yeSkuZm9yRWFjaChsb2NhbFBsdWdpbj0+e3RyeXt0aGlzLmVuZ2luZS51bnJlZ2lzdGVyKGxvY2FsUGx1Z2luKCkubmFtZSk7fWNhdGNoKGUpe3RoaXMub25FcnJvcihlLGBGYWlsZWQgdG8gdW5yZWdpc3RlciBwbHVnaW4gXCIke2xvY2FsUGx1Z2luKCkubmFtZX1cImApO319KTt9LyoqXG4gICAqIEhhbmRsZSBlcnJvcnNcbiAgICovb25FcnJvcihlcnJvcixjdXN0b21NZXNzYWdlLGdyb3VwaW5nSGFzaCl7dGhpcy5lcnJvckhhbmRsZXIub25FcnJvcih7ZXJyb3IsY29udGV4dDpQTFVHSU5TX01BTkFHRVIsY3VzdG9tTWVzc2FnZSxncm91cGluZ0hhc2h9KTt9fVxuXG5jb25zdCBDT09LSUVfU1RPUkFHRT0nY29va2llU3RvcmFnZSc7Y29uc3QgTE9DQUxfU1RPUkFHRT0nbG9jYWxTdG9yYWdlJztjb25zdCBTRVNTSU9OX1NUT1JBR0U9J3Nlc3Npb25TdG9yYWdlJztjb25zdCBNRU1PUllfU1RPUkFHRT0nbWVtb3J5U3RvcmFnZSc7Y29uc3QgTk9fU1RPUkFHRT0nbm9uZSc7Y29uc3QgU1RPUkFHRV9URVNUX0NPT0tJRT0ndGVzdF9ydWRkZXJfY29va2llJztjb25zdCBTVE9SQUdFX1RFU1RfTE9DQUxfU1RPUkFHRT0ndGVzdF9ydWRkZXJfbHMnO2NvbnN0IFNUT1JBR0VfVEVTVF9TRVNTSU9OX1NUT1JBR0U9J3Rlc3RfcnVkZGVyX3NzJztcblxuY29uc3QgdXNlcklkS2V5PSdybF91c2VyX2lkJztjb25zdCB1c2VyVHJhaXRzS2V5PSdybF90cmFpdCc7Y29uc3QgYW5vbnltb3VzVXNlcklkS2V5PSdybF9hbm9ueW1vdXNfaWQnO2NvbnN0IGdyb3VwSWRLZXk9J3JsX2dyb3VwX2lkJztjb25zdCBncm91cFRyYWl0c0tleT0ncmxfZ3JvdXBfdHJhaXQnO2NvbnN0IHBhZ2VJbml0aWFsUmVmZXJyZXJLZXk9J3JsX3BhZ2VfaW5pdF9yZWZlcnJlcic7Y29uc3QgcGFnZUluaXRpYWxSZWZlcnJpbmdEb21haW5LZXk9J3JsX3BhZ2VfaW5pdF9yZWZlcnJpbmdfZG9tYWluJztjb25zdCBzZXNzaW9uSW5mb0tleT0ncmxfc2Vzc2lvbic7Y29uc3QgYXV0aFRva2VuS2V5PSdybF9hdXRoX3Rva2VuJztjb25zdCBDT09LSUVfS0VZUz17dXNlcklkOnVzZXJJZEtleSx1c2VyVHJhaXRzOnVzZXJUcmFpdHNLZXksYW5vbnltb3VzSWQ6YW5vbnltb3VzVXNlcklkS2V5LGdyb3VwSWQ6Z3JvdXBJZEtleSxncm91cFRyYWl0czpncm91cFRyYWl0c0tleSxpbml0aWFsUmVmZXJyZXI6cGFnZUluaXRpYWxSZWZlcnJlcktleSxpbml0aWFsUmVmZXJyaW5nRG9tYWluOnBhZ2VJbml0aWFsUmVmZXJyaW5nRG9tYWluS2V5LHNlc3Npb25JbmZvOnNlc3Npb25JbmZvS2V5LGF1dGhUb2tlbjphdXRoVG9rZW5LZXl9O1xuXG5jb25zdCBTVE9SQUdFX1RFU1RfVE9QX0xFVkVMX0RPTUFJTj0nX190bGRfXyc7Y29uc3QgQ0xJRU5UX0RBVEFfU1RPUkVfQ09PS0lFPSdjbGllbnREYXRhSW5Db29raWUnO2NvbnN0IENMSUVOVF9EQVRBX1NUT1JFX0xTPSdjbGllbnREYXRhSW5Mb2NhbFN0b3JhZ2UnO2NvbnN0IENMSUVOVF9EQVRBX1NUT1JFX01FTU9SWT0nY2xpZW50RGF0YUluTWVtb3J5Jztjb25zdCBDTElFTlRfREFUQV9TVE9SRV9TRVNTSU9OPSdjbGllbnREYXRhSW5TZXNzaW9uU3RvcmFnZSc7Y29uc3QgVVNFUl9TRVNTSU9OX0tFWVM9Wyd1c2VySWQnLCd1c2VyVHJhaXRzJywnYW5vbnltb3VzSWQnLCdncm91cElkJywnZ3JvdXBUcmFpdHMnLCdpbml0aWFsUmVmZXJyZXInLCdpbml0aWFsUmVmZXJyaW5nRG9tYWluJywnc2Vzc2lvbkluZm8nLCdhdXRoVG9rZW4nXTtcblxuY29uc3Qgc3RvcmFnZUNsaWVudERhdGFTdG9yZU5hbWVNYXA9e1tDT09LSUVfU1RPUkFHRV06Q0xJRU5UX0RBVEFfU1RPUkVfQ09PS0lFLFtMT0NBTF9TVE9SQUdFXTpDTElFTlRfREFUQV9TVE9SRV9MUyxbTUVNT1JZX1NUT1JBR0VdOkNMSUVOVF9EQVRBX1NUT1JFX01FTU9SWSxbU0VTU0lPTl9TVE9SQUdFXTpDTElFTlRfREFUQV9TVE9SRV9TRVNTSU9OfTtcblxuLyoqXG4gKiBFbmNvZGUuXG4gKi9jb25zdCBlbmNvZGU9KHZhbHVlLGxvZ2dlcik9Pnt0cnl7cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7fWNhdGNoKGVycil7bG9nZ2VyPy5lcnJvcihDT09LSUVfREFUQV9FTkNPRElOR19FUlJPUixlcnIpO3JldHVybiB1bmRlZmluZWQ7fX07LyoqXG4gKiBEZWNvZGVcbiAqL2NvbnN0IGRlY29kZT12YWx1ZT0+e3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTt9Y2F0Y2goZXJyKXsvLyBEbyBub3RoaW5nIGFzIG5vbi1SUyBTREsgY29va2llcyBtYXkgbm90IGJlIFVSSSBlbmNvZGVkXG5yZXR1cm4gdW5kZWZpbmVkO319Oy8qKlxuICogUGFyc2UgY29va2llIGBzdHJgXG4gKi9jb25zdCBwYXJzZT1zdHI9Pntjb25zdCBvYmo9e307Y29uc3QgcGFpcnM9c3RyLnNwbGl0KC9cXHMqO1xccyovKTtsZXQgcGFpcjtpZighcGFpcnNbMF0pe3JldHVybiBvYmo7fS8vIFRPRE86IERlY29kZSBvbmx5IHRoZSBjb29raWVzIHRoYXQgYXJlIG5lZWRlZCBieSB0aGUgU0RLXG5wYWlycy5mb3JFYWNoKHBhaXJJdGVtPT57cGFpcj1wYWlySXRlbS5zcGxpdCgnPScpO2NvbnN0IGtleU5hbWU9cGFpclswXT9kZWNvZGUocGFpclswXSk6dW5kZWZpbmVkO2lmKGtleU5hbWUpe29ialtrZXlOYW1lXT1wYWlyWzFdP2RlY29kZShwYWlyWzFdKTp1bmRlZmluZWQ7fX0pO3JldHVybiBvYmo7fTsvKipcbiAqIFNldCBjb29raWUgYG5hbWVgIHRvIGB2YWx1ZWBcbiAqL2NvbnN0IHNldD0obmFtZSx2YWx1ZSxvcHRpb25zQ29uZmlnLGxvZ2dlcik9Pntjb25zdCBvcHRpb25zPXsuLi4ob3B0aW9uc0NvbmZpZ3x8e30pfTtsZXQgY29va2llU3RyaW5nPWAke2VuY29kZShuYW1lLGxvZ2dlcil9PSR7ZW5jb2RlKHZhbHVlLGxvZ2dlcil9YDtpZihpc051bGwodmFsdWUpKXtvcHRpb25zLm1heGFnZT0tMTt9aWYob3B0aW9ucy5tYXhhZ2Upe29wdGlvbnMuZXhwaXJlcz1uZXcgRGF0ZSgrbmV3IERhdGUoKStvcHRpb25zLm1heGFnZSk7fWlmKG9wdGlvbnMucGF0aCl7Y29va2llU3RyaW5nKz1gOyBwYXRoPSR7b3B0aW9ucy5wYXRofWA7fWlmKG9wdGlvbnMuZG9tYWluKXtjb29raWVTdHJpbmcrPWA7IGRvbWFpbj0ke29wdGlvbnMuZG9tYWlufWA7fWlmKG9wdGlvbnMuZXhwaXJlcyl7Y29va2llU3RyaW5nKz1gOyBleHBpcmVzPSR7b3B0aW9ucy5leHBpcmVzLnRvVVRDU3RyaW5nKCl9YDt9aWYob3B0aW9ucy5zYW1lc2l0ZSl7Y29va2llU3RyaW5nKz1gOyBzYW1lc2l0ZT0ke29wdGlvbnMuc2FtZXNpdGV9YDt9aWYob3B0aW9ucy5zZWN1cmUpe2Nvb2tpZVN0cmluZys9YDsgc2VjdXJlYDt9Z2xvYmFsVGhpcy5kb2N1bWVudC5jb29raWU9Y29va2llU3RyaW5nO307LyoqXG4gKiBSZXR1cm4gYWxsIGNvb2tpZXNcbiAqL2NvbnN0IGFsbD0oKT0+e2NvbnN0IGNvb2tpZVN0cmluZ1ZhbHVlPWdsb2JhbFRoaXMuZG9jdW1lbnQuY29va2llO3JldHVybiBwYXJzZShjb29raWVTdHJpbmdWYWx1ZSk7fTsvKipcbiAqIEdldCBjb29raWUgYG5hbWVgXG4gKi9jb25zdCBnZXQ9bmFtZT0+YWxsKClbbmFtZV07LyoqXG4gKiBTZXQgb3IgZ2V0IGNvb2tpZSBgbmFtZWAgd2l0aCBgdmFsdWVgIGFuZCBgb3B0aW9uc2Agb2JqZWN0XG4gKi8vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuY29uc3QgY29va2llPWZ1bmN0aW9uKG5hbWUsdmFsdWUsb3B0aW9ucyxsb2dnZXIpe3N3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDQ6Y2FzZSAzOmNhc2UgMjpyZXR1cm4gc2V0KG5hbWUsdmFsdWUsb3B0aW9ucyxsb2dnZXIpO2Nhc2UgMTppZihuYW1lKXtyZXR1cm4gZ2V0KG5hbWUpO31yZXR1cm4gYWxsKCk7ZGVmYXVsdDpyZXR1cm4gYWxsKCk7fX07XG5cbmNvbnN0IGxlZ2FjeUdldEhvc3RuYW1lPWhyZWY9Pntjb25zdCBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtsLmhyZWY9aHJlZjtyZXR1cm4gbC5ob3N0bmFtZTt9Oy8qKlxuICogTGV2ZWxzIHJldHVybnMgYWxsIGxldmVscyBvZiB0aGUgZ2l2ZW4gdXJsXG4gKlxuICogVGhlIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IGFycmF5IHdoZW4gdGhlIGhvc3RuYW1lIGlzIGFuIGlwLlxuICovY29uc3QgbGV2ZWxzRnVuYz11cmw9PnsvLyBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIHBvbHlmaWxscyBsb2FkIHRodXMgbmV3IFVSTCBjYW5ub3QgYmUgdXNlZFxuY29uc3QgaG9zdD10eXBlb2YgZ2xvYmFsVGhpcy5VUkwhPT0nZnVuY3Rpb24nP2xlZ2FjeUdldEhvc3RuYW1lKHVybCk6bmV3IFVSTCh1cmwpLmhvc3RuYW1lO2NvbnN0IHBhcnRzPWhvc3Q/LnNwbGl0KCcuJyk/P1tdO2NvbnN0IGxhc3Q9cGFydHNbcGFydHMubGVuZ3RoLTFdO2NvbnN0IGxldmVscz1bXTsvLyBJcCBhZGRyZXNzLlxuaWYocGFydHMubGVuZ3RoPT09NCYmbGFzdCYmbGFzdD09PXBhcnNlSW50KGxhc3QsMTApLnRvU3RyaW5nKCkpe3JldHVybiBsZXZlbHM7fS8vIExvY2FsaG9zdC5cbmlmKHBhcnRzLmxlbmd0aDw9MSl7Ly8gRml4IHRvIHN1cHBvcnQgbG9jYWxob3N0XG5pZihwYXJ0c1swXSYmcGFydHNbMF0uaW5kZXhPZignbG9jYWxob3N0JykhPT0tMSl7cmV0dXJuIFsnbG9jYWxob3N0J107fXJldHVybiBsZXZlbHM7fS8vIENyZWF0ZSBsZXZlbHMuXG5mb3IobGV0IGk9cGFydHMubGVuZ3RoLTI7aT49MDtpLT0xKXtsZXZlbHMucHVzaChwYXJ0cy5zbGljZShpKS5qb2luKCcuJykpO31yZXR1cm4gbGV2ZWxzO307LyoqXG4gKiBHZXQgdGhlIHRvcCBkb21haW4uXG4gKlxuICogVGhlIGZ1bmN0aW9uIGNvbnN0cnVjdHMgdGhlIGxldmVscyBvZiBkb21haW4gYW5kIGF0dGVtcHRzIHRvIHNldCBhIGdsb2JhbFxuICogY29va2llIG9uIGVhY2ggb25lIHdoZW4gaXQgc3VjY2VlZHMgaXQgcmV0dXJucyB0aGUgdG9wIGxldmVsIGRvbWFpbi5cbiAqXG4gKiBUaGUgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nIHdoZW4gdGhlIGhvc3RuYW1lIGlzIGFuIGlwLlxuICovY29uc3QgZG9tYWluPXVybD0+e2NvbnN0IGxldmVscz1sZXZlbHNGdW5jKHVybCk7Ly8gTG9va3VwIHRoZSByZWFsIHRvcCBsZXZlbCBvbmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1mb3ItbG9vcFxuZm9yKGxldCBpPTA7aTxsZXZlbHMubGVuZ3RoO2krPTEpe2NvbnN0IGRvbWFpbj1sZXZlbHNbaV07Y29uc3QgY25hbWU9U1RPUkFHRV9URVNUX1RPUF9MRVZFTF9ET01BSU47Y29uc3Qgb3B0cz17ZG9tYWluOmAke2RvbWFpbi5pbmRleE9mKCdsb2NhbGhvc3QnKSE9PS0xPycnOicuJ30ke2RvbWFpbn1gfTt0cnl7Ly8gU2V0IGNvb2tpZSBvbiBkb21haW5cbmNvb2tpZShjbmFtZSwxLG9wdHMpOy8vIElmIHN1Y2Nlc3NmdWxcbmlmKGNvb2tpZShjbmFtZSkpey8vIFJlbW92ZSBjb29raWUgZnJvbSBkb21haW5cbmNvb2tpZShjbmFtZSxudWxsLG9wdHMpO3JldHVybiBkb21haW47fX1jYXRjaHsvLyBTaWxlbnRseSBjb250aW51ZSB0byBuZXh0IGRvbWFpbiBsZXZlbCBpZiBjb29raWUgYWNjZXNzIGlzIHJlc3RyaWN0ZWQgb3Igc2V0dGluZyBmYWlsc1xuLy8gQmVzdC1lZmZvcnQgY2xlYW51cCB0byBhdm9pZCBsZWFraW5nIHRoZSB0ZXN0IGNvb2tpZVxudHJ5e2Nvb2tpZShjbmFtZSxudWxsLG9wdHMpO31jYXRjaHsvLyBJZ25vcmUgaWYgd2UgYXJlIHVuYWJsZSB0byBkZWxldGUgdGhlIGNvb2tpZVxufX19cmV0dXJuICcnO307XG5cbmNvbnN0IGdldERlZmF1bHRDb29raWVPcHRpb25zPSgpPT57Y29uc3QgdG9wRG9tYWluPWAuJHtkb21haW4oZ2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmKX1gO3JldHVybiB7bWF4YWdlOkRFRkFVTFRfQ09PS0lFX01BWF9BR0VfTVMscGF0aDonLycsZG9tYWluOiF0b3BEb21haW58fHRvcERvbWFpbj09PScuJz91bmRlZmluZWQ6dG9wRG9tYWluLHNhbWVzaXRlOidMYXgnLGVuYWJsZWQ6dHJ1ZX07fTtjb25zdCBnZXREZWZhdWx0TG9jYWxTdG9yYWdlT3B0aW9ucz0oKT0+KHtlbmFibGVkOnRydWV9KTtjb25zdCBnZXREZWZhdWx0U2Vzc2lvblN0b3JhZ2VPcHRpb25zPSgpPT4oe2VuYWJsZWQ6dHJ1ZX0pO2NvbnN0IGdldERlZmF1bHRJbk1lbW9yeVN0b3JhZ2VPcHRpb25zPSgpPT4oe2VuYWJsZWQ6dHJ1ZX0pO1xuXG4vKipcbiAqIEEgc3RvcmFnZSB1dGlsaXR5IHRvIHJldGFpbiB2YWx1ZXMgaW4gbWVtb3J5IHZpYSBTdG9yYWdlIGludGVyZmFjZVxuICovY2xhc3MgSW5NZW1vcnlTdG9yYWdle2lzRW5hYmxlZD10cnVlO2xlbmd0aD0wO2RhdGE9e307Y29uc3RydWN0b3IobG9nZ2VyKXt0aGlzLm9wdGlvbnM9Z2V0RGVmYXVsdEluTWVtb3J5U3RvcmFnZU9wdGlvbnMoKTt0aGlzLmxvZ2dlcj1sb2dnZXI7fWNvbmZpZ3VyZShvcHRpb25zKXt0aGlzLm9wdGlvbnM9bWVyZ2VEZWVwUmlnaHQodGhpcy5vcHRpb25zLG9wdGlvbnM/P3t9KTt0aGlzLmlzRW5hYmxlZD1Cb29sZWFuKHRoaXMub3B0aW9ucy5lbmFibGVkKTtyZXR1cm4gdGhpcy5vcHRpb25zO31zZXRJdGVtKGtleSx2YWx1ZSl7dGhpcy5kYXRhW2tleV09dmFsdWU7dGhpcy5sZW5ndGg9T2JqZWN0LmtleXModGhpcy5kYXRhKS5sZW5ndGg7cmV0dXJuIHZhbHVlO31nZXRJdGVtKGtleSl7aWYoa2V5IGluIHRoaXMuZGF0YSl7cmV0dXJuIHRoaXMuZGF0YVtrZXldO31yZXR1cm4gbnVsbDt9cmVtb3ZlSXRlbShrZXkpe2lmKGtleSBpbiB0aGlzLmRhdGEpe2RlbGV0ZSB0aGlzLmRhdGFba2V5XTt9dGhpcy5sZW5ndGg9T2JqZWN0LmtleXModGhpcy5kYXRhKS5sZW5ndGg7cmV0dXJuIG51bGw7fWNsZWFyKCl7dGhpcy5kYXRhPXt9O3RoaXMubGVuZ3RoPTA7fWtleShpbmRleCl7Y29uc3QgY3VyS2V5cz10aGlzLmtleXMoKTtyZXR1cm4gY3VyS2V5c1tpbmRleF0/P251bGw7fWtleXMoKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhKTt9fWNvbnN0IGRlZmF1bHRJbk1lbW9yeVN0b3JhZ2U9bmV3IEluTWVtb3J5U3RvcmFnZShkZWZhdWx0TG9nZ2VyKTtcblxudmFyIHN0b3JlJDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgc3RvcmUkMT1zdG9yZSQyLmV4cG9ydHM7dmFyIGhhc1JlcXVpcmVkU3RvcmU7ZnVuY3Rpb24gcmVxdWlyZVN0b3JlKCl7aWYoaGFzUmVxdWlyZWRTdG9yZSlyZXR1cm4gc3RvcmUkMi5leHBvcnRzO2hhc1JlcXVpcmVkU3RvcmU9MTsoZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMkMSl7KGZ1bmN0aW9uKGdsb2JhbCxmYWN0b3J5KXttb2R1bGUuZXhwb3J0cz1mYWN0b3J5KCk7fSkoc3RvcmUkMSxmdW5jdGlvbigpe2Z1bmN0aW9uIGlzSlNPTihvYmope29iaj1KU09OLnN0cmluZ2lmeShvYmopO2lmKCEvXlxce1tcXHNcXFNdKlxcfSQvLnRlc3Qob2JqKSl7cmV0dXJuIGZhbHNlO31yZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gc3RyaW5naWZ5KHZhbCl7cmV0dXJuIHZhbD09PXVuZGVmaW5lZHx8dHlwZW9mIHZhbD09PVwiZnVuY3Rpb25cIj92YWwrJyc6SlNPTi5zdHJpbmdpZnkodmFsKTt9ZnVuY3Rpb24gZGVzZXJpYWxpemUodmFsdWUpe2lmKHR5cGVvZiB2YWx1ZSE9PSdzdHJpbmcnKXtyZXR1cm4gdW5kZWZpbmVkO310cnl7cmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO31jYXRjaChlKXtyZXR1cm4gdmFsdWU7fX1mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKXtyZXR1cm4ge30udG9TdHJpbmcuY2FsbCh2YWx1ZSk9PT1cIltvYmplY3QgRnVuY3Rpb25dXCI7fWZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpPT09XCJbb2JqZWN0IEFycmF5XVwiO30vLyBodHRwczovL2dpdGh1Yi5jb20vamF5d2NqbG92ZS9zdG9yZS5qcy9wdWxsLzhcbi8vIEVycm9yOiBRdW90YUV4Y2VlZGVkRXJyb3JcbmZ1bmN0aW9uIGRlYWxJbmNvZ25pdG8oc3RvcmFnZSl7dmFyIF9LRVk9J19Jc19JbmNvZ25pdCcsX1ZBTFVFPSd5ZXMnO3RyeXsvLyBOT1RFOiBzZXQgZGVmYXVsdCBzdG9yYWdlIHdoZW4gbm90IHBhc3NlZCBpblxuaWYoIXN0b3JhZ2Upe3N0b3JhZ2U9d2luZG93LmxvY2FsU3RvcmFnZTt9c3RvcmFnZS5zZXRJdGVtKF9LRVksX1ZBTFVFKTtzdG9yYWdlLnJlbW92ZUl0ZW0oX0tFWSk7fWNhdGNoKGUpe3ZhciBpbk1lbW9yeVN0b3JhZ2U9e307aW5NZW1vcnlTdG9yYWdlLl9kYXRhPXt9O2luTWVtb3J5U3RvcmFnZS5zZXRJdGVtPWZ1bmN0aW9uKGlkLHZhbCl7cmV0dXJuIGluTWVtb3J5U3RvcmFnZS5fZGF0YVtpZF09U3RyaW5nKHZhbCk7fTtpbk1lbW9yeVN0b3JhZ2UuZ2V0SXRlbT1mdW5jdGlvbihpZCl7cmV0dXJuIGluTWVtb3J5U3RvcmFnZS5fZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCk/aW5NZW1vcnlTdG9yYWdlLl9kYXRhW2lkXTp1bmRlZmluZWQ7fTtpbk1lbW9yeVN0b3JhZ2UucmVtb3ZlSXRlbT1mdW5jdGlvbihpZCl7cmV0dXJuIGRlbGV0ZSBpbk1lbW9yeVN0b3JhZ2UuX2RhdGFbaWRdO307aW5NZW1vcnlTdG9yYWdlLmNsZWFyPWZ1bmN0aW9uKCl7cmV0dXJuIGluTWVtb3J5U3RvcmFnZS5fZGF0YT17fTt9O3N0b3JhZ2U9aW5NZW1vcnlTdG9yYWdlO31maW5hbGx5e2lmKHN0b3JhZ2UuZ2V0SXRlbShfS0VZKT09PV9WQUxVRSlzdG9yYWdlLnJlbW92ZUl0ZW0oX0tFWSk7fXJldHVybiBzdG9yYWdlO30vLyBkZWFsIFF1b3RhRXhjZWVkZWRFcnJvciBpZiB1c2VyIHVzZSBpbmNvZ25pdG8gbW9kZSBpbiBicm93c2VyXG52YXIgc3RvcmFnZT1kZWFsSW5jb2duaXRvKCk7ZnVuY3Rpb24gU3RvcmUoKXtpZighKHRoaXMgaW5zdGFuY2VvZiBTdG9yZSkpe3JldHVybiBuZXcgU3RvcmUoKTt9fVN0b3JlLnByb3RvdHlwZT17c2V0OmZ1bmN0aW9uIHNldChrZXksdmFsKXtpZihrZXkmJiFpc0pTT04oa2V5KSl7c3RvcmFnZS5zZXRJdGVtKGtleSxzdHJpbmdpZnkodmFsKSk7fWVsc2UgaWYoaXNKU09OKGtleSkpe2Zvcih2YXIgYSBpbiBrZXkpdGhpcy5zZXQoYSxrZXlbYV0pO31yZXR1cm4gdGhpczt9LGdldDpmdW5jdGlvbiBnZXQoa2V5KXsvLyBSZXR1cm4gYWxsIGVudHJpZXMgaWYgbm8ga2V5XG5pZihrZXk9PT11bmRlZmluZWQpe3ZhciByZXQ9e307dGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSx2YWwpe3JldHVybiByZXRba2V5XT12YWw7fSk7cmV0dXJuIHJldDt9aWYoa2V5LmNoYXJBdCgwKT09PSc/Jyl7cmV0dXJuIHRoaXMuaGFzKGtleS5zdWJzdHIoMSkpO312YXIgYXJncz1hcmd1bWVudHM7aWYoYXJncy5sZW5ndGg+MSl7dmFyIGR0PXt9O2Zvcih2YXIgaT0wLGxlbj1hcmdzLmxlbmd0aDtpPGxlbjtpKyspe3ZhciB2YWx1ZT1kZXNlcmlhbGl6ZShzdG9yYWdlLmdldEl0ZW0oYXJnc1tpXSkpO2lmKHRoaXMuaGFzKGFyZ3NbaV0pKXtkdFthcmdzW2ldXT12YWx1ZTt9fXJldHVybiBkdDt9cmV0dXJuIGRlc2VyaWFsaXplKHN0b3JhZ2UuZ2V0SXRlbShrZXkpKTt9LGNsZWFyOmZ1bmN0aW9uIGNsZWFyKCl7c3RvcmFnZS5jbGVhcigpO3JldHVybiB0aGlzO30scmVtb3ZlOmZ1bmN0aW9uIHJlbW92ZShrZXkpe3ZhciB2YWw9dGhpcy5nZXQoa2V5KTtzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtyZXR1cm4gdmFsO30saGFzOmZ1bmN0aW9uIGhhcyhrZXkpe3JldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZ2V0KCksa2V5KTt9LGtleXM6ZnVuY3Rpb24ga2V5cygpe3ZhciBkPVtdO3RoaXMuZm9yRWFjaChmdW5jdGlvbihrKXtkLnB1c2goayk7fSk7cmV0dXJuIGQ7fSxmb3JFYWNoOmZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2spe2Zvcih2YXIgaT0wLGxlbj1zdG9yYWdlLmxlbmd0aDtpPGxlbjtpKyspe3ZhciBrZXk9c3RvcmFnZS5rZXkoaSk7Y2FsbGJhY2soa2V5LHRoaXMuZ2V0KGtleSkpO31yZXR1cm4gdGhpczt9LHNlYXJjaDpmdW5jdGlvbiBzZWFyY2goc3RyKXt2YXIgYXJyPXRoaXMua2V5cygpLGR0PXt9O2Zvcih2YXIgaT0wLGxlbj1hcnIubGVuZ3RoO2k8bGVuO2krKyl7aWYoYXJyW2ldLmluZGV4T2Yoc3RyKT4tMSlkdFthcnJbaV1dPXRoaXMuZ2V0KGFycltpXSk7fXJldHVybiBkdDt9LGxlbjpmdW5jdGlvbiBsZW4oKXtyZXR1cm4gc3RvcmFnZS5sZW5ndGg7fX07dmFyIF9TdG9yZT1udWxsO2Z1bmN0aW9uIHN0b3JlKGtleSxkYXRhKXt2YXIgYXJnbT1hcmd1bWVudHM7dmFyIGR0PW51bGw7aWYoIV9TdG9yZSlfU3RvcmU9U3RvcmUoKTtpZihhcmdtLmxlbmd0aD09PTApcmV0dXJuIF9TdG9yZS5nZXQoKTtpZihhcmdtLmxlbmd0aD09PTEpe2lmKHR5cGVvZiBrZXk9PT1cInN0cmluZ1wiKXJldHVybiBfU3RvcmUuZ2V0KGtleSk7aWYoaXNKU09OKGtleSkpcmV0dXJuIF9TdG9yZS5zZXQoa2V5KTt9aWYoYXJnbS5sZW5ndGg9PT0yJiZ0eXBlb2Yga2V5PT09XCJzdHJpbmdcIil7aWYoIWRhdGEpcmV0dXJuIF9TdG9yZS5yZW1vdmUoa2V5KTtpZihkYXRhJiZ0eXBlb2YgZGF0YT09PVwic3RyaW5nXCIpcmV0dXJuIF9TdG9yZS5zZXQoa2V5LGRhdGEpO2lmKGRhdGEmJmlzRnVuY3Rpb24oZGF0YSkpe2R0PW51bGw7ZHQ9ZGF0YShrZXksX1N0b3JlLmdldChrZXkpKTtzdG9yZS5zZXQoa2V5LGR0KTt9fWlmKGFyZ20ubGVuZ3RoPT09MiYmaXNBcnJheShrZXkpJiZpc0Z1bmN0aW9uKGRhdGEpKXtmb3IodmFyIGk9MCxsZW49a2V5Lmxlbmd0aDtpPGxlbjtpKyspe2R0PWRhdGEoa2V5W2ldLF9TdG9yZS5nZXQoa2V5W2ldKSk7c3RvcmUuc2V0KGtleVtpXSxkdCk7fX1yZXR1cm4gc3RvcmU7fWZvcih2YXIgYSBpbiBTdG9yZS5wcm90b3R5cGUpc3RvcmVbYV09U3RvcmUucHJvdG90eXBlW2FdO3JldHVybiBzdG9yZTt9KTt9KShzdG9yZSQyKTtyZXR1cm4gc3RvcmUkMi5leHBvcnRzO31cblxudmFyIHN0b3JlRXhwb3J0cyA9IHJlcXVpcmVTdG9yZSgpO1xuY29uc3Qgc3RvcmUgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc3RvcmVFeHBvcnRzKTtcblxuY29uc3QgaXNTdG9yYWdlUXVvdGFFeGNlZWRlZD1lPT57Y29uc3QgbWF0Y2hpbmdOYW1lcz1bJ1F1b3RhRXhjZWVkZWRFcnJvcicsJ05TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEJ107Ly8gRXZlcnl0aGluZyBleGNlcHQgRmlyZWZveCwgRmlyZWZveFxuY29uc3QgbWF0Y2hpbmdDb2Rlcz1bMjIsMTAxNF07aWYoZSBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbil7cmV0dXJuIG1hdGNoaW5nTmFtZXMuaW5jbHVkZXMoZS5uYW1lKXx8bWF0Y2hpbmdDb2Rlcy5pbmNsdWRlcyhlLmNvZGUpO31yZXR1cm4gZmFsc2U7fTsvLyBUT0RPOiBhbHNvIGNoZWNrIGZvciBTZWN1cml0eUVycm9yc1xuLy8gIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvbG9jYWxTdG9yYWdlI2V4Y2VwdGlvbnNcbmNvbnN0IGlzU3RvcmFnZUF2YWlsYWJsZT0odHlwZT1MT0NBTF9TVE9SQUdFLHN0b3JhZ2VJbnN0YW5jZSxsb2dnZXIpPT57bGV0IHN0b3JhZ2U7bGV0IHRlc3REYXRhO2NvbnN0IG1zZ1ByZWZpeD1TVE9SQUdFX1VOQVZBSUxBQklMSVRZX0VSUk9SX1BSRUZJWChDQVBBQklMSVRJRVNfTUFOQUdFUix0eXBlKTtsZXQgcmVhc29uPSd1bmF2YWlsYWJsZSc7bGV0IGlzQWNjZXNzaWJsZT10cnVlO2xldCBlcnJPYmo7dHJ5e3N3aXRjaCh0eXBlKXtjYXNlIE1FTU9SWV9TVE9SQUdFOnJldHVybiB0cnVlO2Nhc2UgQ09PS0lFX1NUT1JBR0U6c3RvcmFnZT1zdG9yYWdlSW5zdGFuY2U7dGVzdERhdGE9U1RPUkFHRV9URVNUX0NPT0tJRTticmVhaztjYXNlIExPQ0FMX1NUT1JBR0U6c3RvcmFnZT1zdG9yYWdlSW5zdGFuY2U/P2dsb2JhbFRoaXMubG9jYWxTdG9yYWdlO3Rlc3REYXRhPVNUT1JBR0VfVEVTVF9MT0NBTF9TVE9SQUdFOy8vIHdhcyBTVE9SQUdFX1RFU1RfTE9DQUxfU1RPUkFHRSBpbiBvdXJzIGFuZCBnZW5lcmF0ZVVVSUQoKSBpbiBzZWdtZW50IHJldHJ5IG9uZVxuYnJlYWs7Y2FzZSBTRVNTSU9OX1NUT1JBR0U6c3RvcmFnZT1zdG9yYWdlSW5zdGFuY2U/P2dsb2JhbFRoaXMuc2Vzc2lvblN0b3JhZ2U7dGVzdERhdGE9U1RPUkFHRV9URVNUX1NFU1NJT05fU1RPUkFHRTticmVhaztkZWZhdWx0OnJldHVybiBmYWxzZTt9aWYoc3RvcmFnZSl7c3RvcmFnZS5zZXRJdGVtKHRlc3REYXRhLCd0cnVlJyk7aWYoc3RvcmFnZS5nZXRJdGVtKHRlc3REYXRhKSl7c3RvcmFnZS5yZW1vdmVJdGVtKHRlc3REYXRhKTtyZXR1cm4gdHJ1ZTt9fWlzQWNjZXNzaWJsZT1mYWxzZTt9Y2F0Y2goZXJyKXtpc0FjY2Vzc2libGU9ZmFsc2U7ZXJyT2JqPWVycjtpZihpc1N0b3JhZ2VRdW90YUV4Y2VlZGVkKGVycikpe3JlYXNvbj0nZnVsbCc7fX1pZighaXNBY2Nlc3NpYmxlKXtsb2dnZXI/Lndhcm4oYCR7bXNnUHJlZml4fSR7cmVhc29ufS5gLGVyck9iaik7fS8vIGlmIHdlJ3ZlIGhhdmUgcmVhY2hlZCBoZXJlLCBpdCBtZWFucyB0aGUgc3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlXG5yZXR1cm4gZmFsc2U7fTtcblxuLy8gIGNoZWNrIGlmIHRoZSBnZXQsIHNldCBvdmVybG9hZHMgYW5kIHNlYXJjaCBtZXRob2RzIGFyZSB1c2VkIGF0IGFsbFxuLy8gIGlmIHdlIGRvLCBlbnN1cmUgd2UgcHJvdmlkZSB0eXBlcyB0byBzdXBwb3J0IG92ZXJsb2FkcyBhcyBwZXIgc3RvcmVqcyBkb2NzXG4vLyAgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3RvcmVqc1xuLyoqXG4gKiBBIHN0b3JhZ2UgdXRpbGl0eSB0byBwZXJzaXN0IHZhbHVlcyBpbiBsb2NhbHN0b3JhZ2UgdmlhIFN0b3JhZ2UgaW50ZXJmYWNlXG4gKi9jbGFzcyBMb2NhbFN0b3JhZ2V7aXNTdXBwb3J0QXZhaWxhYmxlPXRydWU7aXNFbmFibGVkPXRydWU7bGVuZ3RoPTA7Y29uc3RydWN0b3IobG9nZ2VyKXt0aGlzLm9wdGlvbnM9Z2V0RGVmYXVsdExvY2FsU3RvcmFnZU9wdGlvbnMoKTt0aGlzLmxvZ2dlcj1sb2dnZXI7fWNvbmZpZ3VyZShvcHRpb25zKXt0aGlzLm9wdGlvbnM9bWVyZ2VEZWVwUmlnaHQodGhpcy5vcHRpb25zLG9wdGlvbnM/P3t9KTt0aGlzLmlzU3VwcG9ydEF2YWlsYWJsZT1pc1N0b3JhZ2VBdmFpbGFibGUoTE9DQUxfU1RPUkFHRSk7dGhpcy5pc0VuYWJsZWQ9Qm9vbGVhbih0aGlzLm9wdGlvbnMuZW5hYmxlZCYmdGhpcy5pc1N1cHBvcnRBdmFpbGFibGUpO3JldHVybiB0aGlzLm9wdGlvbnM7fXNldEl0ZW0oa2V5LHZhbHVlKXtzdG9yZS5zZXQoa2V5LHZhbHVlKTt0aGlzLmxlbmd0aD1zdG9yZS5sZW4oKTt9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbmdldEl0ZW0oa2V5KXtjb25zdCB2YWx1ZT1zdG9yZS5nZXQoa2V5KTtyZXR1cm4gaXNVbmRlZmluZWQodmFsdWUpP251bGw6dmFsdWU7fXJlbW92ZUl0ZW0oa2V5KXtzdG9yZS5yZW1vdmUoa2V5KTt0aGlzLmxlbmd0aD1zdG9yZS5sZW4oKTt9Y2xlYXIoKXtzdG9yZS5jbGVhcigpO3RoaXMubGVuZ3RoPTA7fWtleShpbmRleCl7Y29uc3QgY3VyS2V5cz10aGlzLmtleXMoKTtyZXR1cm4gY3VyS2V5c1tpbmRleF0/P251bGw7fS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5rZXlzKCl7cmV0dXJuIHN0b3JlLmtleXMoKTt9fWNvbnN0IGRlZmF1bHRMb2NhbFN0b3JhZ2U9bmV3IExvY2FsU3RvcmFnZShkZWZhdWx0TG9nZ2VyKTtcblxuLyoqXG4gKiBBIHN0b3JhZ2UgdXRpbGl0eSB0byBwZXJzaXN0IHZhbHVlcyBpbiBTZXNzaW9uU3RvcmFnZSB2aWEgU3RvcmFnZSBpbnRlcmZhY2VcbiAqL2NsYXNzIFNlc3Npb25TdG9yYWdle2lzU3VwcG9ydEF2YWlsYWJsZT10cnVlO2lzRW5hYmxlZD10cnVlO2xlbmd0aD0wO2NvbnN0cnVjdG9yKGxvZ2dlcil7dGhpcy5vcHRpb25zPWdldERlZmF1bHRTZXNzaW9uU3RvcmFnZU9wdGlvbnMoKTt0aGlzLmxvZ2dlcj1sb2dnZXI7fWNvbmZpZ3VyZShvcHRpb25zKXt0aGlzLm9wdGlvbnM9bWVyZ2VEZWVwUmlnaHQodGhpcy5vcHRpb25zLG9wdGlvbnM/P3t9KTt0aGlzLmlzU3VwcG9ydEF2YWlsYWJsZT1pc1N0b3JhZ2VBdmFpbGFibGUoU0VTU0lPTl9TVE9SQUdFKTsvLyB3aGVuIHN0b3JhZ2UgaXMgYmxvY2tlZCBieSB0aGUgdXNlciwgZXZlbiBhY2Nlc3NpbmcgdGhlIHByb3BlcnR5IHRocm93cyBhbiBlcnJvclxuaWYodGhpcy5pc1N1cHBvcnRBdmFpbGFibGUpe3RoaXMuc3RvcmU9Z2xvYmFsVGhpcy5zZXNzaW9uU3RvcmFnZTt9dGhpcy5pc0VuYWJsZWQ9Qm9vbGVhbih0aGlzLm9wdGlvbnMuZW5hYmxlZCYmdGhpcy5pc1N1cHBvcnRBdmFpbGFibGUpO3JldHVybiB0aGlzLm9wdGlvbnM7fXNldEl0ZW0oa2V5LHZhbHVlKXtpZighdGhpcy5zdG9yZSl7cmV0dXJuO310aGlzLnN0b3JlLnNldEl0ZW0oa2V5LHZhbHVlKTt0aGlzLmxlbmd0aD10aGlzLnN0b3JlLmxlbmd0aDt9Z2V0SXRlbShrZXkpe2lmKCF0aGlzLnN0b3JlKXtyZXR1cm4gbnVsbDt9Y29uc3QgdmFsdWU9dGhpcy5zdG9yZS5nZXRJdGVtKGtleSk7cmV0dXJuIGlzVW5kZWZpbmVkKHZhbHVlKT9udWxsOnZhbHVlO31yZW1vdmVJdGVtKGtleSl7aWYoIXRoaXMuc3RvcmUpe3JldHVybjt9dGhpcy5zdG9yZS5yZW1vdmVJdGVtKGtleSk7dGhpcy5sZW5ndGg9dGhpcy5zdG9yZS5sZW5ndGg7fWNsZWFyKCl7dGhpcy5zdG9yZT8uY2xlYXIoKTt0aGlzLmxlbmd0aD0wO31rZXkoaW5kZXgpe3JldHVybiB0aGlzLnN0b3JlPy5rZXkoaW5kZXgpPz9udWxsO31rZXlzKCl7Y29uc3Qga2V5cz1bXTtpZighdGhpcy5zdG9yZSl7cmV0dXJuIGtleXM7fWZvcihsZXQgaT0wO2k8dGhpcy5zdG9yZS5sZW5ndGg7aSs9MSl7Y29uc3Qga2V5PXRoaXMuc3RvcmUua2V5KGkpO2lmKGtleSE9PW51bGwpe2tleXMucHVzaChrZXkpO319cmV0dXJuIGtleXM7fX1jb25zdCBkZWZhdWx0U2Vzc2lvblN0b3JhZ2U9bmV3IFNlc3Npb25TdG9yYWdlKGRlZmF1bHRMb2dnZXIpO1xuXG4vKipcbiAqIEEgc3RvcmFnZSB1dGlsaXR5IHRvIHBlcnNpc3QgdmFsdWVzIGluIGNvb2tpZXMgdmlhIFN0b3JhZ2UgaW50ZXJmYWNlXG4gKi9jbGFzcyBDb29raWVTdG9yYWdle2lzU3VwcG9ydEF2YWlsYWJsZT10cnVlO2lzRW5hYmxlZD10cnVlO2xlbmd0aD0wO2NvbnN0cnVjdG9yKGxvZ2dlcil7dGhpcy5sb2dnZXI9bG9nZ2VyO31jb25maWd1cmUob3B0aW9ucyl7aWYoIXRoaXMub3B0aW9ucyl7dGhpcy5vcHRpb25zPWdldERlZmF1bHRDb29raWVPcHRpb25zKCk7fXRoaXMub3B0aW9ucz1tZXJnZURlZXBSaWdodCh0aGlzLm9wdGlvbnMsb3B0aW9ucz8/e30pO2lmKHRoaXMub3B0aW9ucy5zYW1lRG9tYWluQ29va2llc09ubHkpe2RlbGV0ZSB0aGlzLm9wdGlvbnMuZG9tYWluO310aGlzLmlzU3VwcG9ydEF2YWlsYWJsZT1pc1N0b3JhZ2VBdmFpbGFibGUoQ09PS0lFX1NUT1JBR0UsdGhpcyk7dGhpcy5pc0VuYWJsZWQ9Qm9vbGVhbih0aGlzLm9wdGlvbnMuZW5hYmxlZCYmdGhpcy5pc1N1cHBvcnRBdmFpbGFibGUpO3JldHVybiB0aGlzLm9wdGlvbnM7fXNldEl0ZW0oa2V5LHZhbHVlKXtjb29raWUoa2V5LHZhbHVlLHRoaXMub3B0aW9ucyx0aGlzLmxvZ2dlcik7dGhpcy5sZW5ndGg9T2JqZWN0LmtleXMoY29va2llKCkpLmxlbmd0aDtyZXR1cm4gdHJ1ZTt9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbmdldEl0ZW0oa2V5KXtjb25zdCB2YWx1ZT1jb29raWUoa2V5KTtyZXR1cm4gaXNVbmRlZmluZWQodmFsdWUpP251bGw6dmFsdWU7fXJlbW92ZUl0ZW0oa2V5KXtjb25zdCByZXN1bHQ9dGhpcy5zZXRJdGVtKGtleSxudWxsKTt0aGlzLmxlbmd0aD1PYmplY3Qua2V5cyhjb29raWUoKSkubGVuZ3RoO3JldHVybiByZXN1bHQ7fS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5jbGVhcigpey8vIE5vdCBpbXBsZW1lbnRlZFxuLy8gZ2V0dGluZyBhIGxpc3Qgb2YgYWxsIGNvb2tpZSBzdG9yYWdlIGtleXMgYW5kIHJlbW92ZSBhbGwgdmFsdWVzXG4vLyBzb3VuZHMgcmlza3kgdG8gZG8gYXMgaXQgd2lsbCB0YWtlIG9uIGFsbCB0b3AgZG9tYWluIGNvb2tpZXNcbi8vIGJldHRlciB0byBleHBsaWNpdGx5IGNsZWFyIHNwZWNpZmljIG9uZXMgaWYgbmVlZGVkXG59a2V5KGluZGV4KXtjb25zdCBjdXJLZXlzPXRoaXMua2V5cygpO3JldHVybiBjdXJLZXlzW2luZGV4XT8/bnVsbDt9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbmtleXMoKXtyZXR1cm4gT2JqZWN0LmtleXMoY29va2llKCkpO319Y29uc3QgZGVmYXVsdENvb2tpZVN0b3JhZ2U9bmV3IENvb2tpZVN0b3JhZ2UoZGVmYXVsdExvZ2dlcik7XG5cbi8qKlxuICogQSB1dGlsaXR5IHRvIHJldHJpZXZlIHRoZSBzdG9yYWdlIHNpbmdsZXRvbiBpbnN0YW5jZSBieSB0eXBlXG4gKi9jb25zdCBnZXRTdG9yYWdlRW5naW5lPXR5cGU9Pntzd2l0Y2godHlwZSl7Y2FzZSBMT0NBTF9TVE9SQUdFOnJldHVybiBkZWZhdWx0TG9jYWxTdG9yYWdlO2Nhc2UgU0VTU0lPTl9TVE9SQUdFOnJldHVybiBkZWZhdWx0U2Vzc2lvblN0b3JhZ2U7Y2FzZSBNRU1PUllfU1RPUkFHRTpyZXR1cm4gZGVmYXVsdEluTWVtb3J5U3RvcmFnZTtjYXNlIENPT0tJRV9TVE9SQUdFOnJldHVybiBkZWZhdWx0Q29va2llU3RvcmFnZTtkZWZhdWx0OnJldHVybiBkZWZhdWx0SW5NZW1vcnlTdG9yYWdlO319Oy8qKlxuICogQ29uZmlndXJlIGNvb2tpZSBzdG9yYWdlIHNpbmdsZXRvblxuICovY29uc3QgY29uZmlndXJlQ29va2llU3RvcmFnZUVuZ2luZT1vcHRpb25zPT57Y29uc3QgY29va2llU3RvcmFnZU9wdGlvbnM9ZGVmYXVsdENvb2tpZVN0b3JhZ2UuY29uZmlndXJlKG9wdGlvbnMpOy8vIFVwZGF0ZSB0aGUgc3RhdGUgd2l0aCB0aGUgZmluYWwgY29va2llIHN0b3JhZ2Ugb3B0aW9uc1xuc3RhdGUuc3RvcmFnZS5jb29raWUudmFsdWU9e21heGFnZTpjb29raWVTdG9yYWdlT3B0aW9ucy5tYXhhZ2UscGF0aDpjb29raWVTdG9yYWdlT3B0aW9ucy5wYXRoLGRvbWFpbjpjb29raWVTdG9yYWdlT3B0aW9ucy5kb21haW4sc2FtZXNpdGU6Y29va2llU3RvcmFnZU9wdGlvbnMuc2FtZXNpdGUsZXhwaXJlczpjb29raWVTdG9yYWdlT3B0aW9ucy5leHBpcmVzLHNlY3VyZTpjb29raWVTdG9yYWdlT3B0aW9ucy5zZWN1cmV9O307LyoqXG4gKiBDb25maWd1cmUgbG9jYWwgc3RvcmFnZSBzaW5nbGV0b25cbiAqL2NvbnN0IGNvbmZpZ3VyZUxvY2FsU3RvcmFnZUVuZ2luZT1vcHRpb25zPT57ZGVmYXVsdExvY2FsU3RvcmFnZS5jb25maWd1cmUob3B0aW9ucyk7fTsvKipcbiAqIENvbmZpZ3VyZSBpbiBtZW1vcnkgc3RvcmFnZSBzaW5nbGV0b25cbiAqL2NvbnN0IGNvbmZpZ3VyZUluTWVtb3J5U3RvcmFnZUVuZ2luZT1vcHRpb25zPT57ZGVmYXVsdEluTWVtb3J5U3RvcmFnZS5jb25maWd1cmUob3B0aW9ucyk7fTsvKipcbiAqIENvbmZpZ3VyZSBzZXNzaW9uIHN0b3JhZ2Ugc2luZ2xldG9uXG4gKi9jb25zdCBjb25maWd1cmVTZXNzaW9uU3RvcmFnZUVuZ2luZT1vcHRpb25zPT57ZGVmYXVsdFNlc3Npb25TdG9yYWdlLmNvbmZpZ3VyZShvcHRpb25zKTt9Oy8qKlxuICogQ29uZmlndXJlIGFsbCBzdG9yYWdlIHNpbmdsZXRvbiBpbnN0YW5jZXNcbiAqL2NvbnN0IGNvbmZpZ3VyZVN0b3JhZ2VFbmdpbmVzPShjb29raWVTdG9yYWdlT3B0aW9ucz17fSxsb2NhbFN0b3JhZ2VPcHRpb25zPXt9LGluTWVtb3J5U3RvcmFnZU9wdGlvbnM9e30sc2Vzc2lvblN0b3JhZ2VPcHRpb25zPXt9KT0+e2NvbmZpZ3VyZUNvb2tpZVN0b3JhZ2VFbmdpbmUoY29va2llU3RvcmFnZU9wdGlvbnMpO2NvbmZpZ3VyZUxvY2FsU3RvcmFnZUVuZ2luZShsb2NhbFN0b3JhZ2VPcHRpb25zKTtjb25maWd1cmVJbk1lbW9yeVN0b3JhZ2VFbmdpbmUoaW5NZW1vcnlTdG9yYWdlT3B0aW9ucyk7Y29uZmlndXJlU2Vzc2lvblN0b3JhZ2VFbmdpbmUoc2Vzc2lvblN0b3JhZ2VPcHRpb25zKTt9O1xuXG4vKipcbiAqIFN0b3JlIEltcGxlbWVudGF0aW9uIHdpdGggZGVkaWNhdGVkIHN0b3JhZ2VcbiAqL2NsYXNzIFN0b3Jle2NvbnN0cnVjdG9yKGNvbmZpZyxlbmdpbmUscGx1Z2luc01hbmFnZXIpe3RoaXMuaWQ9Y29uZmlnLmlkO3RoaXMubmFtZT1jb25maWcubmFtZTt0aGlzLmlzRW5jcnlwdGVkPWNvbmZpZy5pc0VuY3J5cHRlZD8/ZmFsc2U7dGhpcy52YWxpZEtleXM9Y29uZmlnLnZhbGlkS2V5cz8/e307dGhpcy5lbmdpbmU9ZW5naW5lO3RoaXMubm9LZXlWYWxpZGF0aW9uPU9iamVjdC5rZXlzKHRoaXMudmFsaWRLZXlzKS5sZW5ndGg9PT0wO3RoaXMubm9Db21wb3VuZEtleT1jb25maWcubm9Db21wb3VuZEtleTt0aGlzLm9yaWdpbmFsRW5naW5lPXRoaXMuZW5naW5lO3RoaXMuZXJyb3JIYW5kbGVyPWNvbmZpZy5lcnJvckhhbmRsZXI7dGhpcy5sb2dnZXI9Y29uZmlnLmxvZ2dlcjt0aGlzLnBsdWdpbnNNYW5hZ2VyPXBsdWdpbnNNYW5hZ2VyO30vKipcbiAgICogRW5zdXJlIHRoZSBrZXkgaXMgdmFsaWQgYW5kIHdpdGggY29ycmVjdCBmb3JtYXRcbiAgICovY3JlYXRlVmFsaWRLZXkoa2V5KXtjb25zdHtuYW1lLGlkLHZhbGlkS2V5cyxub0tleVZhbGlkYXRpb24sbm9Db21wb3VuZEtleX09dGhpcztpZihub0tleVZhbGlkYXRpb24pe3JldHVybiBub0NvbXBvdW5kS2V5P2tleTpbbmFtZSxpZCxrZXldLmpvaW4oJy4nKTt9Ly8gdmFsaWRhdGUgYW5kIHJldHVybiB1bmRlZmluZWQgaWYgaW52YWxpZCBrZXlcbmxldCBjb21wb3VuZEtleTtPYmplY3QudmFsdWVzKHZhbGlkS2V5cykuZm9yRWFjaCh2YWxpZEtleU5hbWU9PntpZih2YWxpZEtleU5hbWU9PT1rZXkpe2NvbXBvdW5kS2V5PW5vQ29tcG91bmRLZXk/a2V5OltuYW1lLGlkLGtleV0uam9pbignLicpO319KTtyZXR1cm4gY29tcG91bmRLZXk7fS8qKlxuICAgKiBTd2l0Y2ggdG8gaW5NZW1vcnlFbmdpbmUsIGJyaW5naW5nIGFueSBleGlzdGluZyBkYXRhIHdpdGguXG4gICAqL3N3YXBRdWV1ZVN0b3JlVG9Jbk1lbW9yeUVuZ2luZSgpe2NvbnN0e25hbWUsaWQsdmFsaWRLZXlzLG5vQ29tcG91bmRLZXl9PXRoaXM7Y29uc3QgaW5NZW1vcnlTdG9yYWdlPWdldFN0b3JhZ2VFbmdpbmUoTUVNT1JZX1NUT1JBR0UpOy8vIGdyYWIgZXhpc3RpbmcgZGF0YSwgYnV0IG9ubHkgZm9yIHRoaXMgcGFnZSdzIHF1ZXVlIGluc3RhbmNlLCBub3QgYWxsXG4vLyBiZXR0ZXIgdG8ga2VlcCBvdGhlciBxdWV1ZXMgaW4gbG9jYWxzdG9yYWdlIHRvIGJlIGZsdXNoZWQgbGF0ZXJcbi8vIHRoYW4gdG8gcHVsbCB0aGVtIGludG8gbWVtb3J5IGFuZCByZW1vdmUgdGhlbSBmcm9tIGR1cmFibGUgc3RvcmFnZVxuT2JqZWN0LmtleXModmFsaWRLZXlzKS5mb3JFYWNoKGtleT0+e2NvbnN0IHZhbHVlPXRoaXMuZ2V0KHZhbGlkS2V5c1trZXldKTtjb25zdCB2YWxpZEtleT1ub0NvbXBvdW5kS2V5P2tleTpbbmFtZSxpZCxrZXldLmpvaW4oJy4nKTtpbk1lbW9yeVN0b3JhZ2Uuc2V0SXRlbSh2YWxpZEtleSx2YWx1ZSk7Ly8gVE9ETzogYXJlIHdlIHN1cmUgd2Ugd2FudCB0byBkcm9wIGNsaWVudERhdGFcbi8vICBpZiBjb29raWVzIGFyZSBub3QgYXZhaWxhYmxlIGFuZCBsb2NhbHN0b3JhZ2UgaXMgZnVsbD9cbnRoaXMucmVtb3ZlKGtleSk7fSk7dGhpcy5lbmdpbmU9aW5NZW1vcnlTdG9yYWdlO30vKipcbiAgICogU2V0IHZhbHVlIGJ5IGtleS5cbiAgICovc2V0KGtleSx2YWx1ZSl7Y29uc3QgdmFsaWRLZXk9dGhpcy5jcmVhdGVWYWxpZEtleShrZXkpO2lmKCF2YWxpZEtleSl7cmV0dXJuO310cnl7Ly8gc3RvcmVqcyB0aGF0IGlzIHVzZWQgaW4gbG9jYWxzdG9yYWdlIGVuZ2luZSBhbHJlYWR5IHN0cmluZ2lmaWVzIGpzb25cbnRoaXMuZW5naW5lLnNldEl0ZW0odmFsaWRLZXksdGhpcy5lbmNyeXB0KHN0cmluZ2lmeVdpdGhvdXRDaXJjdWxhcih2YWx1ZSxmYWxzZSxbXSx0aGlzLmxvZ2dlcikpKTt9Y2F0Y2goZXJyKXtpZihpc1N0b3JhZ2VRdW90YUV4Y2VlZGVkKGVycikpe3RoaXMubG9nZ2VyLndhcm4oU1RPUkFHRV9RVU9UQV9FWENFRURFRF9XQVJOSU5HKGBTdG9yZSAke3RoaXMuaWR9YCkpOy8vIHN3aXRjaCB0byBpbk1lbW9yeSBlbmdpbmVcbnRoaXMuc3dhcFF1ZXVlU3RvcmVUb0luTWVtb3J5RW5naW5lKCk7Ly8gYW5kIHNhdmUgaXQgdGhlcmVcbnRoaXMuc2V0KGtleSx2YWx1ZSk7fWVsc2Uge2NvbnN0IGN1c3RvbU1lc3NhZ2U9U1RPUkVfREFUQV9TQVZFX0VSUk9SKGtleSk7dGhpcy5vbkVycm9yKGVycixjdXN0b21NZXNzYWdlLGN1c3RvbU1lc3NhZ2UpO319fS8qKlxuICAgKiBHZXQgYnkgS2V5LlxuICAgKi9nZXQoa2V5KXtjb25zdCB2YWxpZEtleT10aGlzLmNyZWF0ZVZhbGlkS2V5KGtleSk7bGV0IGRlY3J5cHRlZFZhbHVlO3RyeXtpZighdmFsaWRLZXkpe3JldHVybiBudWxsO31kZWNyeXB0ZWRWYWx1ZT10aGlzLmRlY3J5cHQodGhpcy5lbmdpbmUuZ2V0SXRlbSh2YWxpZEtleSkpO2lmKGlzTnVsbE9yVW5kZWZpbmVkKGRlY3J5cHRlZFZhbHVlKXx8ZGVjcnlwdGVkVmFsdWU9PT0nJyl7cmV0dXJuIG51bGw7fS8vIHN0b3JlanMgdGhhdCBpcyB1c2VkIGluIGxvY2Fsc3RvcmFnZSBlbmdpbmUgYWxyZWFkeSBkZXNlcmlhbGl6ZXMganNvbiBzdHJpbmdzIGJ1dCBzd2FsbG93cyBlcnJvcnNcbnJldHVybiBKU09OLnBhcnNlKGRlY3J5cHRlZFZhbHVlKTt9Y2F0Y2goZXJyKXtjb25zdCBjdXN0b21NZXNzYWdlPVNUT1JFX0RBVEFfRkVUQ0hfRVJST1Ioa2V5KTt0aGlzLm9uRXJyb3IoZXJyLGN1c3RvbU1lc3NhZ2UsY3VzdG9tTWVzc2FnZSk7cmV0dXJuIG51bGw7fX0vKipcbiAgICogUmVtb3ZlIGJ5IEtleS5cbiAgICovcmVtb3ZlKGtleSl7Y29uc3QgdmFsaWRLZXk9dGhpcy5jcmVhdGVWYWxpZEtleShrZXkpO2lmKHZhbGlkS2V5KXt0aGlzLmVuZ2luZS5yZW1vdmVJdGVtKHZhbGlkS2V5KTt9fS8qKlxuICAgKiBHZXQgb3JpZ2luYWwgZW5naW5lXG4gICAqL2dldE9yaWdpbmFsRW5naW5lKCl7cmV0dXJuIHRoaXMub3JpZ2luYWxFbmdpbmU7fS8qKlxuICAgKiBEZWNyeXB0IHZhbHVlc1xuICAgKi9kZWNyeXB0KHZhbHVlKXtpZihpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkpe3JldHVybiBudWxsO31yZXR1cm4gdGhpcy5jcnlwdG8odmFsdWUsJ2RlY3J5cHQnKTt9LyoqXG4gICAqIEVuY3J5cHQgdmFsdWVcbiAgICovZW5jcnlwdCh2YWx1ZSl7cmV0dXJuIHRoaXMuY3J5cHRvKHZhbHVlLCdlbmNyeXB0Jyk7fS8qKlxuICAgKiBFeHRlbnNpb24gcG9pbnQgdG8gdXNlIHdpdGggZW5jcnlwdGlvbiBwbHVnaW5zXG4gICAqL2NyeXB0byh2YWx1ZSxtb2RlKXtjb25zdCBub0VuY3J5cHRpb249IXRoaXMuaXNFbmNyeXB0ZWR8fCF2YWx1ZXx8dHlwZW9mIHZhbHVlIT09J3N0cmluZyd8fHRyaW0odmFsdWUpPT09Jyc7aWYobm9FbmNyeXB0aW9uKXtyZXR1cm4gdmFsdWU7fWNvbnN0IGV4dGVuc2lvblBvaW50TmFtZT1gc3RvcmFnZS4ke21vZGV9YDtjb25zdCBmb3JtYXR0ZWRWYWx1ZT10aGlzLnBsdWdpbnNNYW5hZ2VyP3RoaXMucGx1Z2luc01hbmFnZXIuaW52b2tlU2luZ2xlKGV4dGVuc2lvblBvaW50TmFtZSx2YWx1ZSk6dmFsdWU7cmV0dXJuIHR5cGVvZiBmb3JtYXR0ZWRWYWx1ZT09PSd1bmRlZmluZWQnP3ZhbHVlOmZvcm1hdHRlZFZhbHVlPz8nJzt9LyoqXG4gICAqIEhhbmRsZSBlcnJvcnNcbiAgICovb25FcnJvcihlcnJvcixjdXN0b21NZXNzYWdlLGdyb3VwaW5nSGFzaCl7dGhpcy5lcnJvckhhbmRsZXIub25FcnJvcih7ZXJyb3IsY29udGV4dDpgU3RvcmUgJHt0aGlzLmlkfWAsY3VzdG9tTWVzc2FnZSxncm91cGluZ0hhc2h9KTt9fVxuXG5jb25zdCBnZXRTdG9yYWdlVHlwZUZyb21QcmVDb25zZW50SWZBcHBsaWNhYmxlPShzdGF0ZSxzZXNzaW9uS2V5KT0+e2xldCBvdmVycmlkZGVuU3RvcmFnZVR5cGU7aWYoc3RhdGUuY29uc2VudHMucHJlQ29uc2VudC52YWx1ZS5lbmFibGVkKXtzd2l0Y2goc3RhdGUuY29uc2VudHMucHJlQ29uc2VudC52YWx1ZS5zdG9yYWdlPy5zdHJhdGVneSl7Y2FzZSAnbm9uZSc6b3ZlcnJpZGRlblN0b3JhZ2VUeXBlPU5PX1NUT1JBR0U7YnJlYWs7Y2FzZSAnc2Vzc2lvbic6aWYoc2Vzc2lvbktleSE9PSdzZXNzaW9uSW5mbycpe292ZXJyaWRkZW5TdG9yYWdlVHlwZT1OT19TVE9SQUdFO31icmVhaztjYXNlICdhbm9ueW1vdXNJZCc6aWYoc2Vzc2lvbktleSE9PSdhbm9ueW1vdXNJZCcpe292ZXJyaWRkZW5TdG9yYWdlVHlwZT1OT19TVE9SQUdFO31icmVhazt9fXJldHVybiBvdmVycmlkZGVuU3RvcmFnZVR5cGU7fTtcblxuLyoqXG4gKiBBIHNlcnZpY2UgdG8gbWFuYWdlIHN0b3JlcyAmIGF2YWlsYWJsZSBzdG9yYWdlIGNsaWVudCBjb25maWd1cmF0aW9uc1xuICovY2xhc3MgU3RvcmVNYW5hZ2Vye3N0b3Jlcz17fTtpc0luaXRpYWxpemVkPWZhbHNlO2NvbnN0cnVjdG9yKHBsdWdpbnNNYW5hZ2VyLGVycm9ySGFuZGxlcixsb2dnZXIpe3RoaXMuZXJyb3JIYW5kbGVyPWVycm9ySGFuZGxlcjt0aGlzLmxvZ2dlcj1sb2dnZXI7dGhpcy5wbHVnaW5zTWFuYWdlcj1wbHVnaW5zTWFuYWdlcjt9LyoqXG4gICAqIENvbmZpZ3VyZSBhdmFpbGFibGUgc3RvcmFnZSBjbGllbnQgaW5zdGFuY2VzXG4gICAqL2luaXQoKXtpZih0aGlzLmlzSW5pdGlhbGl6ZWQpe3JldHVybjt9Y29uc3QgbG9hZE9wdGlvbnM9c3RhdGUubG9hZE9wdGlvbnMudmFsdWU7Y29uc3QgY29uZmlnPXtjb29raWVTdG9yYWdlT3B0aW9uczp7c2FtZXNpdGU6bG9hZE9wdGlvbnMuc2FtZVNpdGVDb29raWUsc2VjdXJlOmxvYWRPcHRpb25zLnNlY3VyZUNvb2tpZSxkb21haW46bG9hZE9wdGlvbnMuc2V0Q29va2llRG9tYWluLHNhbWVEb21haW5Db29raWVzT25seTpsb2FkT3B0aW9ucy5zYW1lRG9tYWluQ29va2llc09ubHl9LGxvY2FsU3RvcmFnZU9wdGlvbnM6e30saW5NZW1vcnlTdG9yYWdlT3B0aW9uczp7fSxzZXNzaW9uU3RvcmFnZU9wdGlvbnM6e319O2NvbmZpZ3VyZVN0b3JhZ2VFbmdpbmVzKHJlbW92ZVVuZGVmaW5lZFZhbHVlcyhtZXJnZURlZXBSaWdodChjb25maWcuY29va2llU3RvcmFnZU9wdGlvbnM/P3t9LHN0YXRlLnN0b3JhZ2UuY29va2llPy52YWx1ZT8/e30pKSxyZW1vdmVVbmRlZmluZWRWYWx1ZXMoY29uZmlnLmxvY2FsU3RvcmFnZU9wdGlvbnMpLHJlbW92ZVVuZGVmaW5lZFZhbHVlcyhjb25maWcuaW5NZW1vcnlTdG9yYWdlT3B0aW9ucykscmVtb3ZlVW5kZWZpbmVkVmFsdWVzKGNvbmZpZy5zZXNzaW9uU3RvcmFnZU9wdGlvbnMpKTt0aGlzLmluaXRDbGllbnREYXRhU3RvcmVzKCk7dGhpcy5pc0luaXRpYWxpemVkPXRydWU7fS8qKlxuICAgKiBDcmVhdGUgc3RvcmUgdG8gcGVyc2lzdCBkYXRhIHVzZWQgYnkgdGhlIFNESyBsaWtlIHNlc3Npb24sIHVzZWQgZGV0YWlscyBldGNcbiAgICovaW5pdENsaWVudERhdGFTdG9yZXMoKXt0aGlzLmluaXRpYWxpemVTdG9yYWdlU3RhdGUoKTsvLyBUT0RPOiBmaWxsIGluIGV4dHJhIGNvbmZpZyB2YWx1ZXMgYW5kIGJyaW5nIHRoZW0gaW4gZnJvbSBTdG9yZU1hbmFnZXJPcHRpb25zIGlmIG5lZWRlZFxuLy8gVE9ETzogc2hvdWxkIHdlIHBhc3MgdGhlIGtleXMgZm9yIGFsbCBpbiBvcmRlciB0byB2YWxpZGF0ZSBvciBsZWF2ZSBmcmVlIGFzIHYxLjE/XG4vLyBJbml0aWFsaXppbmcgYWxsIHRoZSBlbmFibGVkIHN0b3JlIGJlY2F1c2UgcHJldmlvdXMgdXNlciBkYXRhIG1pZ2h0IGJlIGluIGRpZmZlcmVudCBzdG9yYWdlXG4vLyB0aGF0IG5lZWRzIGF1dG8gbWlncmF0aW9uXG5jb25zdCBzdG9yYWdlVHlwZXM9W01FTU9SWV9TVE9SQUdFLExPQ0FMX1NUT1JBR0UsQ09PS0lFX1NUT1JBR0UsU0VTU0lPTl9TVE9SQUdFXTtzdG9yYWdlVHlwZXMuZm9yRWFjaChzdG9yYWdlVHlwZT0+e2lmKGdldFN0b3JhZ2VFbmdpbmUoc3RvcmFnZVR5cGUpPy5pc0VuYWJsZWQpe3RoaXMuc2V0U3RvcmUoe2lkOnN0b3JhZ2VDbGllbnREYXRhU3RvcmVOYW1lTWFwW3N0b3JhZ2VUeXBlXSxuYW1lOnN0b3JhZ2VDbGllbnREYXRhU3RvcmVOYW1lTWFwW3N0b3JhZ2VUeXBlXSxpc0VuY3J5cHRlZDp0cnVlLG5vQ29tcG91bmRLZXk6dHJ1ZSx0eXBlOnN0b3JhZ2VUeXBlLGVycm9ySGFuZGxlcjp0aGlzLmVycm9ySGFuZGxlcixsb2dnZXI6dGhpcy5sb2dnZXJ9KTt9fSk7fWluaXRpYWxpemVTdG9yYWdlU3RhdGUoKXtsZXQgZ2xvYmFsU3RvcmFnZVR5cGU9c3RhdGUuc3RvcmFnZS50eXBlLnZhbHVlO2xldCBlbnRyaWVzT3B0aW9ucz1zdGF0ZS5sb2FkT3B0aW9ucy52YWx1ZS5zdG9yYWdlPy5lbnRyaWVzOy8vIFVzZSB0aGUgc3RvcmFnZSBvcHRpb25zIGZyb20gcG9zdCBjb25zZW50IGlmIGFueXRoaW5nIGlzIGRlZmluZWRcbmNvbnN0IHBvc3RDb25zZW50U3RvcmFnZU9wdHM9c3RhdGUuY29uc2VudHMucG9zdENvbnNlbnQudmFsdWUuc3RvcmFnZTtpZihpc0RlZmluZWQocG9zdENvbnNlbnRTdG9yYWdlT3B0cz8udHlwZSl8fGlzRGVmaW5lZChwb3N0Q29uc2VudFN0b3JhZ2VPcHRzPy5lbnRyaWVzKSl7Z2xvYmFsU3RvcmFnZVR5cGU9cG9zdENvbnNlbnRTdG9yYWdlT3B0cz8udHlwZTtlbnRyaWVzT3B0aW9ucz1wb3N0Q29uc2VudFN0b3JhZ2VPcHRzPy5lbnRyaWVzO31sZXQgdHJ1bHlBbm9ueW1vdXNUcmFja2luZz10cnVlO2xldCBzdG9yYWdlRW50cmllcz17fTtVU0VSX1NFU1NJT05fS0VZUy5mb3JFYWNoKHNlc3Npb25LZXk9Pntjb25zdCBrZXk9c2Vzc2lvbktleTtjb25zdCBzdG9yYWdlS2V5PXNlc3Npb25LZXk7Y29uc3QgY29uZmlndXJlZFN0b3JhZ2VUeXBlPWVudHJpZXNPcHRpb25zPy5ba2V5XT8udHlwZTtjb25zdCBwcmVDb25zZW50U3RvcmFnZVR5cGU9Z2V0U3RvcmFnZVR5cGVGcm9tUHJlQ29uc2VudElmQXBwbGljYWJsZShzdGF0ZSxzZXNzaW9uS2V5KTsvLyBTdG9yYWdlIHR5cGUgcHJlY2VkZW5jZSBvcmRlcjogcHJlLWNvbnNlbnQgc3RyYXRlZ3kgPiBlbnRyeSB0eXBlID4gZ2xvYmFsIHR5cGUgPiBkZWZhdWx0XG5jb25zdCBzdG9yYWdlVHlwZT1wcmVDb25zZW50U3RvcmFnZVR5cGU/P2NvbmZpZ3VyZWRTdG9yYWdlVHlwZT8/Z2xvYmFsU3RvcmFnZVR5cGU/P0RFRkFVTFRfU1RPUkFHRV9UWVBFO2NvbnN0IGZpbmFsU3RvcmFnZVR5cGU9dGhpcy5nZXRSZXNvbHZlZFN0b3JhZ2VUeXBlRm9yRW50cnkoc3RvcmFnZVR5cGUsc2Vzc2lvbktleSk7aWYoZmluYWxTdG9yYWdlVHlwZSE9PU5PX1NUT1JBR0Upe3RydWx5QW5vbnltb3VzVHJhY2tpbmc9ZmFsc2U7fXN0b3JhZ2VFbnRyaWVzPXsuLi5zdG9yYWdlRW50cmllcyxbc2Vzc2lvbktleV06e3R5cGU6ZmluYWxTdG9yYWdlVHlwZSxrZXk6Q09PS0lFX0tFWVNbc3RvcmFnZUtleV19fTt9KTtyKCgpPT57c3RhdGUuc3RvcmFnZS50eXBlLnZhbHVlPWdsb2JhbFN0b3JhZ2VUeXBlO3N0YXRlLnN0b3JhZ2UuZW50cmllcy52YWx1ZT1zdG9yYWdlRW50cmllcztzdGF0ZS5zdG9yYWdlLnRydWx5QW5vbnltb3VzVHJhY2tpbmcudmFsdWU9dHJ1bHlBbm9ueW1vdXNUcmFja2luZzt9KTt9Z2V0UmVzb2x2ZWRTdG9yYWdlVHlwZUZvckVudHJ5KHN0b3JhZ2VUeXBlLHNlc3Npb25LZXkpe2xldCBmaW5hbFN0b3JhZ2VUeXBlPXN0b3JhZ2VUeXBlO3N3aXRjaChzdG9yYWdlVHlwZSl7Y2FzZSBMT0NBTF9TVE9SQUdFOmlmKCFnZXRTdG9yYWdlRW5naW5lKExPQ0FMX1NUT1JBR0UpPy5pc0VuYWJsZWQpe2ZpbmFsU3RvcmFnZVR5cGU9TUVNT1JZX1NUT1JBR0U7fWJyZWFrO2Nhc2UgU0VTU0lPTl9TVE9SQUdFOmlmKCFnZXRTdG9yYWdlRW5naW5lKFNFU1NJT05fU1RPUkFHRSk/LmlzRW5hYmxlZCl7ZmluYWxTdG9yYWdlVHlwZT1NRU1PUllfU1RPUkFHRTt9YnJlYWs7Y2FzZSBNRU1PUllfU1RPUkFHRTpjYXNlIE5PX1NUT1JBR0U6YnJlYWs7Y2FzZSBDT09LSUVfU1RPUkFHRTpkZWZhdWx0Oi8vIEZpcnN0IHRyeSBzZXR0aW5nIHRoZSBzdG9yYWdlIHRvIGNvb2tpZSBlbHNlIHRvIGxvY2FsIHN0b3JhZ2VcbmlmKGdldFN0b3JhZ2VFbmdpbmUoQ09PS0lFX1NUT1JBR0UpPy5pc0VuYWJsZWQpe2ZpbmFsU3RvcmFnZVR5cGU9Q09PS0lFX1NUT1JBR0U7fWVsc2UgaWYoZ2V0U3RvcmFnZUVuZ2luZShMT0NBTF9TVE9SQUdFKT8uaXNFbmFibGVkKXtmaW5hbFN0b3JhZ2VUeXBlPUxPQ0FMX1NUT1JBR0U7fWVsc2UgaWYoZ2V0U3RvcmFnZUVuZ2luZShTRVNTSU9OX1NUT1JBR0UpPy5pc0VuYWJsZWQpe2ZpbmFsU3RvcmFnZVR5cGU9U0VTU0lPTl9TVE9SQUdFO31lbHNlIHtmaW5hbFN0b3JhZ2VUeXBlPU1FTU9SWV9TVE9SQUdFO31icmVhazt9aWYoZmluYWxTdG9yYWdlVHlwZSE9PXN0b3JhZ2VUeXBlKXt0aGlzLmxvZ2dlci53YXJuKFNUT1JBR0VfVU5BVkFJTEFCTEVfV0FSTklORyhTVE9SRV9NQU5BR0VSLHNlc3Npb25LZXksc3RvcmFnZVR5cGUsZmluYWxTdG9yYWdlVHlwZSkpO31yZXR1cm4gZmluYWxTdG9yYWdlVHlwZTt9LyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzdG9yZVxuICAgKi9zZXRTdG9yZShzdG9yZUNvbmZpZyl7Y29uc3Qgc3RvcmFnZUVuZ2luZT1nZXRTdG9yYWdlRW5naW5lKHN0b3JlQ29uZmlnLnR5cGUpO3RoaXMuc3RvcmVzW3N0b3JlQ29uZmlnLmlkXT1uZXcgU3RvcmUoc3RvcmVDb25maWcsc3RvcmFnZUVuZ2luZSx0aGlzLnBsdWdpbnNNYW5hZ2VyKTtyZXR1cm4gdGhpcy5zdG9yZXNbc3RvcmVDb25maWcuaWRdO30vKipcbiAgICogUmV0cmlldmUgYSBzdG9yZVxuICAgKi9nZXRTdG9yZShpZCl7cmV0dXJuIHRoaXMuc3RvcmVzW2lkXTt9fVxuXG5jb25zdCBpc1ZhbGlkU291cmNlQ29uZmlnPXJlcz0+aXNPYmplY3RMaXRlcmFsQW5kTm90TnVsbChyZXMpJiZpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKHJlcy5zb3VyY2UpJiYhaXNOdWxsT3JVbmRlZmluZWQocmVzLnNvdXJjZS5pZCkmJmlzT2JqZWN0TGl0ZXJhbEFuZE5vdE51bGwocmVzLnNvdXJjZS5jb25maWcpJiZBcnJheS5pc0FycmF5KHJlcy5zb3VyY2UuZGVzdGluYXRpb25zKTtjb25zdCBpc1ZhbGlkU3RvcmFnZVR5cGU9c3RvcmFnZVR5cGU9PnR5cGVvZiBzdG9yYWdlVHlwZT09PSdzdHJpbmcnJiZTVVBQT1JURURfU1RPUkFHRV9UWVBFUy5pbmNsdWRlcyhzdG9yYWdlVHlwZSk7Y29uc3QgZ2V0VG9wRG9tYWluPXVybD0+ey8vIENyZWF0ZSBhIFVSTCBvYmplY3RcbmNvbnN0IHVybE9iaj1uZXcgVVJMKHVybCk7Ly8gRXh0cmFjdCB0aGUgaG9zdCBhbmQgcHJvdG9jb2xcbmNvbnN0e2hvc3QscHJvdG9jb2x9PXVybE9iajsvLyBTcGxpdCB0aGUgaG9zdCBpbnRvIHBhcnRzXG5jb25zdCBwYXJ0cz1ob3N0LnNwbGl0KCcuJyk7bGV0IHRvcERvbWFpbjsvLyBIYW5kbGUgZGlmZmVyZW50IGNhc2VzLCBlc3BlY2lhbGx5IGZvciBjby51ayBvciBzaW1pbGFyIFRMRHNcbmlmKHBhcnRzLmxlbmd0aD4yKXsvLyBKb2luIHRoZSBsYXN0IHR3byBwYXJ0cyBmb3IgdGhlIHRvcC1sZXZlbCBkb21haW5cbnRvcERvbWFpbj1gJHtwYXJ0c1twYXJ0cy5sZW5ndGgtMl19LiR7cGFydHNbcGFydHMubGVuZ3RoLTFdfWA7fWVsc2Ugey8vIElmIG9ubHkgdHdvIHBhcnRzIG9yIGxlc3MsIHJldHVybiBhcyBpdCBpc1xudG9wRG9tYWluPWhvc3Q7fXJldHVybiB7dG9wRG9tYWluLHByb3RvY29sfTt9O2NvbnN0IGdldFRvcERvbWFpblVybD11cmw9Pntjb25zdHt0b3BEb21haW4scHJvdG9jb2x9PWdldFRvcERvbWFpbih1cmwpO3JldHVybiBgJHtwcm90b2NvbH0vLyR7dG9wRG9tYWlufWA7fTtjb25zdCBnZXREYXRhU2VydmljZVVybD0oZW5kcG9pbnQsdXNlRXhhY3REb21haW4pPT57Y29uc3QgdXJsPXVzZUV4YWN0RG9tYWluP3dpbmRvdy5sb2NhdGlvbi5vcmlnaW46Z2V0VG9wRG9tYWluVXJsKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtjb25zdCBmb3JtYXR0ZWRFbmRwb2ludD1lbmRwb2ludC5zdGFydHNXaXRoKCcvJyk/ZW5kcG9pbnQuc3Vic3RyaW5nKDEpOmVuZHBvaW50O3JldHVybiBgJHt1cmx9LyR7Zm9ybWF0dGVkRW5kcG9pbnR9YDt9O2NvbnN0IGlzV2VicGFnZVRvcExldmVsRG9tYWluPXByb3ZpZGVkRG9tYWluPT57Y29uc3R7dG9wRG9tYWlufT1nZXRUb3BEb21haW4od2luZG93LmxvY2F0aW9uLmhyZWYpO3JldHVybiB0b3BEb21haW49PT1wcm92aWRlZERvbWFpbjt9O1xuXG4vKipcbiAqIFJlbW92ZXMgdHJhaWxpbmcgc2xhc2ggZnJvbSB1cmxcbiAqIEBwYXJhbSB1cmxcbiAqIEByZXR1cm5zIHVybFxuICovY29uc3QgcmVtb3ZlVHJhaWxpbmdTbGFzaGVzPXVybD0+dXJsPy5lbmRzV2l0aCgnLycpP3JlbW92ZVRyYWlsaW5nU2xhc2hlcyh1cmwuc3Vic3RyaW5nKDAsdXJsLmxlbmd0aC0xKSk6dXJsO2NvbnN0IGdldERvbWFpbj11cmw9Pnt0cnl7Y29uc3QgdXJsT2JqPW5ldyBVUkwodXJsKTtyZXR1cm4gdXJsT2JqLmhvc3Q7fWNhdGNoKGVycm9yKXtyZXR1cm4gbnVsbDt9fTsvKipcbiAqIEdldCB0aGUgcmVmZXJyaW5nIGRvbWFpbiBmcm9tIHRoZSByZWZlcnJlciBVUkxcbiAqIEBwYXJhbSByZWZlcnJlciBQYWdlIHJlZmVycmVyXG4gKiBAcmV0dXJucyBQYWdlIHJlZmVycmluZyBkb21haW5cbiAqL2NvbnN0IGdldFJlZmVycmluZ0RvbWFpbj1yZWZlcnJlcj0+Z2V0RG9tYWluKHJlZmVycmVyKT8/Jyc7LyoqXG4gKiBFeHRyYWN0cyBVVE0gcGFyYW1ldGVycyBmcm9tIHRoZSBVUkxcbiAqIEBwYXJhbSB1cmwgUGFnZSBVUkxcbiAqIEByZXR1cm5zIFVUTSBwYXJhbWV0ZXJzXG4gKi9jb25zdCBleHRyYWN0VVRNUGFyYW1ldGVycz11cmw9Pntjb25zdCByZXN1bHQ9e307dHJ5e2NvbnN0IHVybE9iaj1uZXcgVVJMKHVybCk7Y29uc3QgVVRNX1BSRUZJWD0ndXRtXyc7dXJsT2JqLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSxzUGFyYW0pPT57aWYoc1BhcmFtLnN0YXJ0c1dpdGgoVVRNX1BSRUZJWCkpe2xldCB1dG1QYXJhbT1zUGFyYW0uc3Vic3RyaW5nKFVUTV9QUkVGSVgubGVuZ3RoKTsvLyBOb3Qgc3VyZSB3aHkgd2UncmUgZG9pbmcgdGhpc1xuaWYodXRtUGFyYW09PT0nY2FtcGFpZ24nKXt1dG1QYXJhbT0nbmFtZSc7fXJlc3VsdFt1dG1QYXJhbV09dmFsdWU7fX0pO31jYXRjaChlcnJvcil7Ly8gRG8gbm90aGluZ1xufXJldHVybiByZXN1bHQ7fTsvKipcbiAqIFRvIGdldCB0aGUgVVJMIHVudGlsIHRoZSBoYXNoXG4gKiBAcGFyYW0gdXJsIFRoZSBpbnB1dCBVUkxcbiAqIEByZXR1cm5zIFVSTCB1bnRpbCB0aGUgaGFzaFxuICovY29uc3QgZ2V0VXJsV2l0aG91dEhhc2g9dXJsPT57bGV0IHVybFdpdGhvdXRIYXNoPXVybDt0cnl7Y29uc3QgdXJsT2JqPW5ldyBVUkwodXJsKTt1cmxXaXRob3V0SGFzaD11cmxPYmoub3JpZ2luK3VybE9iai5wYXRobmFtZSt1cmxPYmouc2VhcmNoO31jYXRjaChlcnJvcil7Ly8gRG8gbm90aGluZ1xufXJldHVybiB1cmxXaXRob3V0SGFzaDt9O1xuXG5jb25zdCByZW1vdmVEdXBsaWNhdGVTbGFzaGVzPXN0cj0+c3RyLnJlcGxhY2UoL1xcL3syLH0vZywnLycpOy8qKlxuICogQ2hlY2tzIGlmIHByb3ZpZGVkIHVybCBpcyB2YWxpZCBvciBub3RcbiAqIEBwYXJhbSB1cmxcbiAqIEByZXR1cm5zIHRydWUgaWYgYHVybGAgaXMgdmFsaWQgYW5kIGZhbHNlIG90aGVyd2lzZVxuICovY29uc3QgaXNWYWxpZFVSTD11cmw9PntpZighaXNTdHJpbmcodXJsKSl7cmV0dXJuIGZhbHNlO310cnl7Ly8gSWYgVVJMIGlzIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlciwgd2UgY2FuIHVzZSBpdCB0byB2YWxpZGF0ZSB0aGUgVVJMXG4vLyBPdGhlcndpc2UsIHdlIGNhbiBhdCBsZWFzdCBjaGVjayBpZiB0aGUgVVJMIG1hdGNoZXMgdGhlIHBhdHRlcm5cbmlmKGlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5VUkwpKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG5uZXcgVVJMKHVybCk7fXJldHVybiBVUkxfUEFUVEVSTi50ZXN0KHVybCk7fWNhdGNoKGUpe3JldHVybiBmYWxzZTt9fTtcblxuY29uc3QgREVGQVVMVF9QUkVfQ09OU0VOVF9TVE9SQUdFX1NUUkFURUdZPSdub25lJztjb25zdCBERUZBVUxUX1BSRV9DT05TRU5UX0VWRU5UU19ERUxJVkVSWV9UWVBFPSdpbW1lZGlhdGUnO1xuXG5jb25zdCBpc0Vycm9yUmVwb3J0aW5nRW5hYmxlZD1zb3VyY2VDb25maWc9PnNvdXJjZUNvbmZpZz8uc3RhdHNDb2xsZWN0aW9uPy5lcnJvcnM/LmVuYWJsZWQ9PT10cnVlO2NvbnN0IGlzTWV0cmljc1JlcG9ydGluZ0VuYWJsZWQ9c291cmNlQ29uZmlnPT5zb3VyY2VDb25maWc/LnN0YXRzQ29sbGVjdGlvbj8ubWV0cmljcz8uZW5hYmxlZD09PXRydWU7XG5cbi8qKlxuICogVmFsaWRhdGVzIGFuZCBub3JtYWxpemVzIHRoZSBjb25zZW50IG9wdGlvbnMgcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAqIEBwYXJhbSBvcHRpb25zIENvbnNlbnQgb3B0aW9ucyBwcm92aWRlZCBieSB0aGUgdXNlclxuICogQHJldHVybnMgVmFsaWRhdGVkIGFuZCBub3JtYWxpemVkIGNvbnNlbnQgb3B0aW9uc1xuICovY29uc3QgZ2V0VmFsaWRQb3N0Q29uc2VudE9wdGlvbnM9b3B0aW9ucz0+e2NvbnN0IHZhbGlkT3B0aW9ucz17c2VuZFBhZ2VFdmVudDpmYWxzZSx0cmFja0NvbnNlbnQ6ZmFsc2UsZGlzY2FyZFByZUNvbnNlbnRFdmVudHM6ZmFsc2V9O2lmKGlzT2JqZWN0TGl0ZXJhbEFuZE5vdE51bGwob3B0aW9ucykpe2NvbnN0IGNsb25lZE9wdGlvbnM9Y2xvbmUob3B0aW9ucyk7dmFsaWRPcHRpb25zLnN0b3JhZ2U9Y2xvbmVkT3B0aW9ucy5zdG9yYWdlO2lmKGlzTm9uRW1wdHlPYmplY3QoY2xvbmVkT3B0aW9ucy5pbnRlZ3JhdGlvbnMpKXt2YWxpZE9wdGlvbnMuaW50ZWdyYXRpb25zPWNsb25lZE9wdGlvbnMuaW50ZWdyYXRpb25zO312YWxpZE9wdGlvbnMuZGlzY2FyZFByZUNvbnNlbnRFdmVudHM9Y2xvbmVkT3B0aW9ucy5kaXNjYXJkUHJlQ29uc2VudEV2ZW50cz09PXRydWU7dmFsaWRPcHRpb25zLnNlbmRQYWdlRXZlbnQ9Y2xvbmVkT3B0aW9ucy5zZW5kUGFnZUV2ZW50PT09dHJ1ZTt2YWxpZE9wdGlvbnMudHJhY2tDb25zZW50PWNsb25lZE9wdGlvbnMudHJhY2tDb25zZW50PT09dHJ1ZTtpZihpc05vbkVtcHR5T2JqZWN0KGNsb25lZE9wdGlvbnMuY29uc2VudE1hbmFnZW1lbnQpKXsvLyBPdmVycmlkZSBlbmFibGVkIHZhbHVlIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgdmFsdWVcbnZhbGlkT3B0aW9ucy5jb25zZW50TWFuYWdlbWVudD1tZXJnZURlZXBSaWdodChjbG9uZWRPcHRpb25zLmNvbnNlbnRNYW5hZ2VtZW50LHtlbmFibGVkOnN0YXRlLmNvbnNlbnRzLmVuYWJsZWQudmFsdWV9KTt9fXJldHVybiB2YWxpZE9wdGlvbnM7fTsvKipcbiAqIFZhbGlkYXRlcyBpZiB0aGUgaW5wdXQgaXMgYSB2YWxpZCBjb25zZW50cyBkYXRhXG4gKiBAcGFyYW0gdmFsdWUgSW5wdXQgY29uc2VudHMgZGF0YVxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgaXMgYSB2YWxpZCBjb25zZW50cyBkYXRhIGVsc2UgZmFsc2VcbiAqL2NvbnN0IGlzVmFsaWRDb25zZW50c0RhdGE9dmFsdWU9PmlzTm9uRW1wdHlPYmplY3QodmFsdWUpfHxBcnJheS5pc0FycmF5KHZhbHVlKTsvKipcbiAqIFJldHJpZXZlcyB0aGUgY29ycmVzcG9uZGluZyBwcm92aWRlciBhbmQgcGx1Z2luIG5hbWUgb2YgdGhlIHNlbGVjdGVkIGNvbnNlbnQgbWFuYWdlciBmcm9tIHRoZSBzdXBwb3J0ZWQgY29uc2VudCBtYW5hZ2Vyc1xuICogQHBhcmFtIGNvbnNlbnRNYW5hZ2VtZW50T3B0cyBjb25zZW50IG1hbmFnZW1lbnQgb3B0aW9uc1xuICogQHBhcmFtIGxvZ2dlciBsb2dnZXIgaW5zdGFuY2VcbiAqIEByZXR1cm5zIENvcnJlc3BvbmRpbmcgcHJvdmlkZXIgYW5kIHBsdWdpbiBuYW1lIG9mIHRoZSBzZWxlY3RlZCBjb25zZW50IG1hbmFnZXIgZnJvbSB0aGUgc3VwcG9ydGVkIGNvbnNlbnQgbWFuYWdlcnNcbiAqL2NvbnN0IGdldENvbnNlbnRNYW5hZ2VySW5mbz0oY29uc2VudE1hbmFnZW1lbnRPcHRzLGxvZ2dlcik9PntsZXR7cHJvdmlkZXJ9PWNvbnNlbnRNYW5hZ2VtZW50T3B0cztjb25zdCBjb25zZW50TWFuYWdlclBsdWdpbk5hbWU9cHJvdmlkZXI/Q29uc2VudE1hbmFnZXJzVG9QbHVnaW5OYW1lTWFwW3Byb3ZpZGVyXTp1bmRlZmluZWQ7aWYocHJvdmlkZXImJiFjb25zZW50TWFuYWdlclBsdWdpbk5hbWUpe2xvZ2dlci5lcnJvcihVTlNVUFBPUlRFRF9DT05TRU5UX01BTkFHRVJfRVJST1IoQ09ORklHX01BTkFHRVIscHJvdmlkZXIsQ29uc2VudE1hbmFnZXJzVG9QbHVnaW5OYW1lTWFwKSk7Ly8gUmVzZXQgdGhlIHByb3ZpZGVyIHZhbHVlXG5wcm92aWRlcj11bmRlZmluZWQ7fXJldHVybiB7cHJvdmlkZXIsY29uc2VudE1hbmFnZXJQbHVnaW5OYW1lfTt9Oy8qKlxuICogVmFsaWRhdGVzIGFuZCBjb252ZXJ0cyB0aGUgY29uc2VudCBtYW5hZ2VtZW50IG9wdGlvbnMgaW50byBhIG5vcm1hbGl6ZWQgZm9ybWF0XG4gKiBAcGFyYW0gY29uc2VudE1hbmFnZW1lbnRPcHRzIENvbnNlbnQgbWFuYWdlbWVudCBvcHRpb25zIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gKiBAcGFyYW0gbG9nZ2VyIGxvZ2dlciBpbnN0YW5jZVxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbnNlbnQgbWFuYWdlciBwbHVnaW4gbmFtZSwgaW5pdGlhbGl6ZWQsIGVuYWJsZWQgYW5kIGNvbnNlbnRzIGRhdGFcbiAqL2NvbnN0IGdldENvbnNlbnRNYW5hZ2VtZW50RGF0YT0oY29uc2VudE1hbmFnZW1lbnRPcHRzLGxvZ2dlcik9PntsZXQgY29uc2VudE1hbmFnZXJQbHVnaW5OYW1lO2xldCBhbGxvd2VkQ29uc2VudElkcz1bXTtsZXQgZGVuaWVkQ29uc2VudElkcz1bXTtsZXQgaW5pdGlhbGl6ZWQ9ZmFsc2U7bGV0IHByb3ZpZGVyO2xldCBlbmFibGVkPWNvbnNlbnRNYW5hZ2VtZW50T3B0cz8uZW5hYmxlZD09PXRydWU7aWYoaXNOb25FbXB0eU9iamVjdChjb25zZW50TWFuYWdlbWVudE9wdHMpJiZlbmFibGVkKXsvLyBHZXQgdGhlIGNvcnJlc3BvbmRpbmcgcGx1Z2luIG5hbWUgb2YgdGhlIHNlbGVjdGVkIGNvbnNlbnQgbWFuYWdlciBmcm9tIHRoZSBzdXBwb3J0ZWQgY29uc2VudCBtYW5hZ2Vyc1xuKHtwcm92aWRlcixjb25zZW50TWFuYWdlclBsdWdpbk5hbWV9PWdldENvbnNlbnRNYW5hZ2VySW5mbyhjb25zZW50TWFuYWdlbWVudE9wdHMsbG9nZ2VyKSk7aWYoaXNWYWxpZENvbnNlbnRzRGF0YShjb25zZW50TWFuYWdlbWVudE9wdHMuYWxsb3dlZENvbnNlbnRJZHMpKXthbGxvd2VkQ29uc2VudElkcz1jb25zZW50TWFuYWdlbWVudE9wdHMuYWxsb3dlZENvbnNlbnRJZHM7aW5pdGlhbGl6ZWQ9dHJ1ZTt9aWYoaXNWYWxpZENvbnNlbnRzRGF0YShjb25zZW50TWFuYWdlbWVudE9wdHMuZGVuaWVkQ29uc2VudElkcykpe2RlbmllZENvbnNlbnRJZHM9Y29uc2VudE1hbmFnZW1lbnRPcHRzLmRlbmllZENvbnNlbnRJZHM7aW5pdGlhbGl6ZWQ9dHJ1ZTt9fWNvbnN0IGNvbnNlbnRzRGF0YT17YWxsb3dlZENvbnNlbnRJZHMsZGVuaWVkQ29uc2VudElkc307Ly8gRW5hYmxlIGNvbnNlbnQgbWFuYWdlbWVudCBvbmx5IGlmIGNvbnNlbnQgbWFuYWdlciBpcyBzdXBwb3J0ZWRcbmVuYWJsZWQ9ZW5hYmxlZCYmQm9vbGVhbihjb25zZW50TWFuYWdlclBsdWdpbk5hbWUpO3JldHVybiB7cHJvdmlkZXIsY29uc2VudE1hbmFnZXJQbHVnaW5OYW1lLGluaXRpYWxpemVkLGVuYWJsZWQsY29uc2VudHNEYXRhfTt9O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIFNESyBVUkxcbiAqIEByZXR1cm5zIHNka1VSTFxuICovY29uc3QgZ2V0U0RLVXJsPSgpPT57Ly8gRmlyc3QgdHJ5IHRoZSBuZXcgbWV0aG9kIG9mIGdldHRpbmcgdGhlIFNESyBVUkxcbi8vIGZyb20gdGhlIHNjcmlwdCB0YWdcbmNvbnN0IHNjcmlwdFRhZz1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbZGF0YS1yc2Etd3JpdGUta2V5XScpO2lmKHNjcmlwdFRhZyYmc2NyaXB0VGFnLmRhdGFzZXQucnNhV3JpdGVLZXk9PT1zdGF0ZS5saWZlY3ljbGUud3JpdGVLZXkudmFsdWUpe3JldHVybiBzY3JpcHRUYWcuc3JjO30vLyBJZiB0aGUgbmV3IG1ldGhvZCBmYWlscywgdHJ5IHRoZSBvbGQgbWV0aG9kXG4vLyBUT0RPOiBXZSBuZWVkIHRvIHJlbW92ZSB0aGlzIG9uY2UgYWxsIHRoZSBjdXN0b21lcnMgdXBncmFkZSB0byB0aGVcbi8vIGxhdGVzdCBTREsgbG9hZGluZyBzbmlwcGV0XG5jb25zdCBzY3JpcHRzPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtjb25zdCBzZGtGaWxlTmFtZVJlZ2V4PS8oPzpefFxcLylyc2EoXFwubWluKT9cXC5qcyQvOy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuZm9yKGNvbnN0IHNjcmlwdCBvZiBzY3JpcHRzKXtjb25zdCBzcmM9c2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7aWYoc3JjJiZzZGtGaWxlTmFtZVJlZ2V4LnRlc3Qoc3JjKSl7cmV0dXJuIHNyYzt9fXJldHVybiB1bmRlZmluZWQ7fTsvKipcbiAqIFVwZGF0ZXMgdGhlIHJlcG9ydGluZyBzdGF0ZSB2YXJpYWJsZXMgZnJvbSB0aGUgc291cmNlIGNvbmZpZyBkYXRhXG4gKiBAcGFyYW0gcmVzIFNvdXJjZSBjb25maWdcbiAqIEBwYXJhbSBsb2dnZXIgTG9nZ2VyIGluc3RhbmNlXG4gKi9jb25zdCB1cGRhdGVSZXBvcnRpbmdTdGF0ZT1yZXM9PntzdGF0ZS5yZXBvcnRpbmcuaXNFcnJvclJlcG9ydGluZ0VuYWJsZWQudmFsdWU9aXNFcnJvclJlcG9ydGluZ0VuYWJsZWQocmVzLnNvdXJjZS5jb25maWcpJiYhaXNTREtSdW5uaW5nSW5DaHJvbWVFeHRlbnNpb24oKTtzdGF0ZS5yZXBvcnRpbmcuaXNNZXRyaWNzUmVwb3J0aW5nRW5hYmxlZC52YWx1ZT1pc01ldHJpY3NSZXBvcnRpbmdFbmFibGVkKHJlcy5zb3VyY2UuY29uZmlnKTt9O2NvbnN0IGdldFNlcnZlclNpZGVDb29raWVzU3RhdGVEYXRhPWxvZ2dlcj0+e2NvbnN0e3VzZVNlcnZlclNpZGVDb29raWVzLGRhdGFTZXJ2aWNlRW5kcG9pbnQsc3RvcmFnZTpzdG9yYWdlT3B0c0Zyb21Mb2FkLHNldENvb2tpZURvbWFpbixzYW1lRG9tYWluQ29va2llc09ubHl9PXN0YXRlLmxvYWRPcHRpb25zLnZhbHVlO2xldCBjb29raWVPcHRpb25zPXN0b3JhZ2VPcHRzRnJvbUxvYWQ/LmNvb2tpZTtsZXQgc3NjRW5hYmxlZD1mYWxzZTtsZXQgZmluYWxEYXRhU2VydmljZVVybDtpZih1c2VTZXJ2ZXJTaWRlQ29va2llcyl7c3NjRW5hYmxlZD11c2VTZXJ2ZXJTaWRlQ29va2llcztjb25zdCBwcm92aWRlZENvb2tpZURvbWFpbj1jb29raWVPcHRpb25zLmRvbWFpbj8/c2V0Q29va2llRG9tYWluOy8qKlxuICAgICAqIEJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucywgd2UgZGVjaWRlIHdoZXRoZXIgdG8gdXNlIHRoZSBleGFjdCBkb21haW4gb3Igbm90IHRvIGRldGVybWluZSB0aGUgZGF0YSBzZXJ2aWNlIFVSTDpcbiAgICAgKiAxLiBJZiB0aGUgY29va2llIGRvbWFpbiBpcyBwcm92aWRlZCBhbmQgaXQgaXMgbm90IGEgdG9wLWxldmVsIGRvbWFpbiwgdGhlbiB1c2UgdGhlIGV4YWN0IGRvbWFpblxuICAgICAqIDIuIElmIHRoZSBzYW1lRG9tYWluQ29va2llc09ubHkgZmxhZyBpcyBzZXQgdG8gdHJ1ZSwgdGhlbiB1c2UgdGhlIGV4YWN0IGRvbWFpblxuICAgICAqL2NvbnN0IHVzZUV4YWN0RG9tYWluPWlzRGVmaW5lZChwcm92aWRlZENvb2tpZURvbWFpbikmJiFpc1dlYnBhZ2VUb3BMZXZlbERvbWFpbihyZW1vdmVMZWFkaW5nUGVyaW9kKHByb3ZpZGVkQ29va2llRG9tYWluKSl8fHNhbWVEb21haW5Db29raWVzT25seTtjb25zdCBkYXRhU2VydmljZVVybD1nZXREYXRhU2VydmljZVVybChkYXRhU2VydmljZUVuZHBvaW50Pz9ERUZBVUxUX0RBVEFfU0VSVklDRV9FTkRQT0lOVCx1c2VFeGFjdERvbWFpbik7aWYoaXNWYWxpZFVSTChkYXRhU2VydmljZVVybCkpe2ZpbmFsRGF0YVNlcnZpY2VVcmw9cmVtb3ZlVHJhaWxpbmdTbGFzaGVzKGRhdGFTZXJ2aWNlVXJsKTtjb25zdCBjdXJIb3N0PWdldERvbWFpbih3aW5kb3cubG9jYXRpb24uaHJlZik7Y29uc3QgZGF0YVNlcnZpY2VIb3N0PWdldERvbWFpbihkYXRhU2VydmljZVVybCk7Ly8gSWYgdGhlIGN1cnJlbnQgaG9zdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZGF0YSBzZXJ2aWNlIGhvc3QsIHRoZW4gaXQgaXMgYSBjcm9zcy1zaXRlIHJlcXVlc3Rcbi8vIEZvciBzZXJ2ZXItc2lkZSBjb29raWVzIHRvIHdvcmssIHdlIG5lZWQgdG8gc2V0IHRoZSBTYW1lU2l0ZT1Ob25lIGFuZCBTZWN1cmUgYXR0cmlidXRlc1xuLy8gT25lIHJvdW5kIG9mIGNvb2tpZSBvcHRpb25zIG1hbmlwdWxhdGlvbiBpcyB0YWtpbmcgcGxhY2UgaGVyZVxuLy8gQmFzZWQgb24gdGhlc2Uoc2V0Q29va2llRG9tYWluL3N0b3JhZ2UuY29va2llIG9yIHNhbWVEb21haW5Db29raWVzT25seSkgdHdvIGxvYWQtb3B0aW9ucywgZmluYWwgY29va2llIG9wdGlvbnMgYXJlIHNldCBpbiB0aGUgc3RvcmFnZSBtb2R1bGVcbi8vIFRPRE86IFJlZmFjdG9yIHRoZSBjb29raWUgb3B0aW9ucyBtYW5pcHVsYXRpb24gbG9naWMgaW4gb25lIHBsYWNlXG5pZihjdXJIb3N0IT09ZGF0YVNlcnZpY2VIb3N0KXtjb29raWVPcHRpb25zPXsuLi5jb29raWVPcHRpb25zLHNhbWVzaXRlOidOb25lJyxzZWN1cmU6dHJ1ZX07fS8qKlxuICAgICAgICogSWYgdGhlIHNhbWVEb21haW5Db29raWVzT25seSBmbGFnIGlzIG5vdCBzZXQgYW5kIHRoZSBjb29raWUgZG9tYWluIGlzIHByb3ZpZGVkKG5vdCB0b3AgbGV2ZWwgZG9tYWluKSxcbiAgICAgICAqIGFuZCB0aGUgZGF0YSBzZXJ2aWNlIGhvc3QgaXMgZGlmZmVyZW50IGZyb20gdGhlIHByb3ZpZGVkIGNvb2tpZSBkb21haW4sIHRoZW4gd2UgZGlzYWJsZSBzZXJ2ZXItc2lkZSBjb29raWVzXG4gICAgICAgKiBleDogcHJvdmlkZWQgY29va2llIGRvbWFpbjogJ3JhbmRvbS5jb20nLCBkYXRhIHNlcnZpY2UgaG9zdDogJ3N1Yi5leGFtcGxlLmNvbSdcbiAgICAgICAqL2lmKCFzYW1lRG9tYWluQ29va2llc09ubHkmJnVzZUV4YWN0RG9tYWluJiZkYXRhU2VydmljZUhvc3QhPT1yZW1vdmVMZWFkaW5nUGVyaW9kKHByb3ZpZGVkQ29va2llRG9tYWluKSl7c3NjRW5hYmxlZD1mYWxzZTtsb2dnZXIud2FybihTRVJWRVJfU0lERV9DT09LSUVfRkVBVFVSRV9PVkVSUklERV9XQVJOSU5HKENPTkZJR19NQU5BR0VSLHByb3ZpZGVkQ29va2llRG9tYWluLGRhdGFTZXJ2aWNlSG9zdCkpO319ZWxzZSB7c3NjRW5hYmxlZD1mYWxzZTt9fXJldHVybiB7c3NjRW5hYmxlZCxjb29raWVPcHRpb25zLGZpbmFsRGF0YVNlcnZpY2VVcmx9O307Y29uc3QgdXBkYXRlU3RvcmFnZVN0YXRlRnJvbUxvYWRPcHRpb25zPWxvZ2dlcj0+e2NvbnN0e3N0b3JhZ2U6c3RvcmFnZU9wdHNGcm9tTG9hZH09c3RhdGUubG9hZE9wdGlvbnMudmFsdWU7bGV0IHN0b3JhZ2VUeXBlPXN0b3JhZ2VPcHRzRnJvbUxvYWQ/LnR5cGU7aWYoaXNEZWZpbmVkKHN0b3JhZ2VUeXBlKSYmIWlzVmFsaWRTdG9yYWdlVHlwZShzdG9yYWdlVHlwZSkpe2xvZ2dlci53YXJuKFNUT1JBR0VfVFlQRV9WQUxJREFUSU9OX1dBUk5JTkcoQ09ORklHX01BTkFHRVIsc3RvcmFnZVR5cGUsREVGQVVMVF9TVE9SQUdFX1RZUEUpKTtzdG9yYWdlVHlwZT1ERUZBVUxUX1NUT1JBR0VfVFlQRTt9bGV0IHN0b3JhZ2VFbmNyeXB0aW9uVmVyc2lvbj1zdG9yYWdlT3B0c0Zyb21Mb2FkPy5lbmNyeXB0aW9uPy52ZXJzaW9uO2NvbnN0IGVuY3J5cHRpb25QbHVnaW5OYW1lPXN0b3JhZ2VFbmNyeXB0aW9uVmVyc2lvbiYmU3RvcmFnZUVuY3J5cHRpb25WZXJzaW9uc1RvUGx1Z2luTmFtZU1hcFtzdG9yYWdlRW5jcnlwdGlvblZlcnNpb25dO2lmKCFpc1VuZGVmaW5lZChzdG9yYWdlRW5jcnlwdGlvblZlcnNpb24pJiZpc1VuZGVmaW5lZChlbmNyeXB0aW9uUGx1Z2luTmFtZSkpey8vIHNldCB0aGUgZGVmYXVsdCBlbmNyeXB0aW9uIHBsdWdpblxubG9nZ2VyLndhcm4oVU5TVVBQT1JURURfU1RPUkFHRV9FTkNSWVBUSU9OX1ZFUlNJT05fV0FSTklORyhDT05GSUdfTUFOQUdFUixzdG9yYWdlRW5jcnlwdGlvblZlcnNpb24sU3RvcmFnZUVuY3J5cHRpb25WZXJzaW9uc1RvUGx1Z2luTmFtZU1hcCxERUZBVUxUX1NUT1JBR0VfRU5DUllQVElPTl9WRVJTSU9OKSk7c3RvcmFnZUVuY3J5cHRpb25WZXJzaW9uPURFRkFVTFRfU1RPUkFHRV9FTkNSWVBUSU9OX1ZFUlNJT047fWVsc2UgaWYoaXNVbmRlZmluZWQoc3RvcmFnZUVuY3J5cHRpb25WZXJzaW9uKSl7c3RvcmFnZUVuY3J5cHRpb25WZXJzaW9uPURFRkFVTFRfU1RPUkFHRV9FTkNSWVBUSU9OX1ZFUlNJT047fS8vIEFsbG93IG1pZ3JhdGlvbiBvbmx5IGlmIHRoZSBjb25maWd1cmVkIGVuY3J5cHRpb24gdmVyc2lvbiBpcyB0aGUgZGVmYXVsdCBlbmNyeXB0aW9uIHZlcnNpb25cbmNvbnN0IGNvbmZpZ3VyZWRNaWdyYXRpb25WYWx1ZT1zdG9yYWdlT3B0c0Zyb21Mb2FkPy5taWdyYXRlO2NvbnN0IGZpbmFsTWlncmF0aW9uVmFsPWNvbmZpZ3VyZWRNaWdyYXRpb25WYWx1ZSYmc3RvcmFnZUVuY3J5cHRpb25WZXJzaW9uPT09REVGQVVMVF9TVE9SQUdFX0VOQ1JZUFRJT05fVkVSU0lPTjtpZihjb25maWd1cmVkTWlncmF0aW9uVmFsdWU9PT10cnVlJiZmaW5hbE1pZ3JhdGlvblZhbCE9PWNvbmZpZ3VyZWRNaWdyYXRpb25WYWx1ZSl7bG9nZ2VyLndhcm4oU1RPUkFHRV9EQVRBX01JR1JBVElPTl9PVkVSUklERV9XQVJOSU5HKENPTkZJR19NQU5BR0VSLHN0b3JhZ2VFbmNyeXB0aW9uVmVyc2lvbixERUZBVUxUX1NUT1JBR0VfRU5DUllQVElPTl9WRVJTSU9OKSk7fWNvbnN0e3NzY0VuYWJsZWQsZmluYWxEYXRhU2VydmljZVVybCxjb29raWVPcHRpb25zfT1nZXRTZXJ2ZXJTaWRlQ29va2llc1N0YXRlRGF0YShsb2dnZXIpO3IoKCk9PntzdGF0ZS5zdG9yYWdlLnR5cGUudmFsdWU9c3RvcmFnZVR5cGU7c3RhdGUuc3RvcmFnZS5jb29raWUudmFsdWU9Y29va2llT3B0aW9ucztzdGF0ZS5zZXJ2ZXJDb29raWVzLmlzRW5hYmxlZFNlcnZlclNpZGVDb29raWVzLnZhbHVlPXNzY0VuYWJsZWQ7c3RhdGUuc2VydmVyQ29va2llcy5kYXRhU2VydmljZVVybC52YWx1ZT1maW5hbERhdGFTZXJ2aWNlVXJsO3N0YXRlLnN0b3JhZ2UuZW5jcnlwdGlvblBsdWdpbk5hbWUudmFsdWU9U3RvcmFnZUVuY3J5cHRpb25WZXJzaW9uc1RvUGx1Z2luTmFtZU1hcFtzdG9yYWdlRW5jcnlwdGlvblZlcnNpb25dO3N0YXRlLnN0b3JhZ2UubWlncmF0ZS52YWx1ZT1maW5hbE1pZ3JhdGlvblZhbDt9KTt9O2NvbnN0IHVwZGF0ZUNvbnNlbnRzU3RhdGVGcm9tTG9hZE9wdGlvbnM9bG9nZ2VyPT57Y29uc3R7cHJvdmlkZXIsY29uc2VudE1hbmFnZXJQbHVnaW5OYW1lLGluaXRpYWxpemVkLGVuYWJsZWQsY29uc2VudHNEYXRhfT1nZXRDb25zZW50TWFuYWdlbWVudERhdGEoc3RhdGUubG9hZE9wdGlvbnMudmFsdWUuY29uc2VudE1hbmFnZW1lbnQsbG9nZ2VyKTsvLyBQcmUtY29uc2VudFxuY29uc3QgcHJlQ29uc2VudE9wdHM9c3RhdGUubG9hZE9wdGlvbnMudmFsdWUucHJlQ29uc2VudDtsZXQgc3RvcmFnZVN0cmF0ZWd5PXByZUNvbnNlbnRPcHRzPy5zdG9yYWdlPy5zdHJhdGVneT8/REVGQVVMVF9QUkVfQ09OU0VOVF9TVE9SQUdFX1NUUkFURUdZO2NvbnN0IFN0b3JhZ2VTdHJhdGVnaWVzPVsnbm9uZScsJ3Nlc3Npb24nLCdhbm9ueW1vdXNJZCddO2lmKGlzRGVmaW5lZChzdG9yYWdlU3RyYXRlZ3kpJiYhU3RvcmFnZVN0cmF0ZWdpZXMuaW5jbHVkZXMoc3RvcmFnZVN0cmF0ZWd5KSl7c3RvcmFnZVN0cmF0ZWd5PURFRkFVTFRfUFJFX0NPTlNFTlRfU1RPUkFHRV9TVFJBVEVHWTtsb2dnZXIud2FybihVTlNVUFBPUlRFRF9QUkVfQ09OU0VOVF9TVE9SQUdFX1NUUkFURUdZKENPTkZJR19NQU5BR0VSLHByZUNvbnNlbnRPcHRzPy5zdG9yYWdlPy5zdHJhdGVneSxERUZBVUxUX1BSRV9DT05TRU5UX1NUT1JBR0VfU1RSQVRFR1kpKTt9bGV0IGV2ZW50c0RlbGl2ZXJ5VHlwZT1wcmVDb25zZW50T3B0cz8uZXZlbnRzPy5kZWxpdmVyeT8/REVGQVVMVF9QUkVfQ09OU0VOVF9FVkVOVFNfREVMSVZFUllfVFlQRTtjb25zdCBkZWxpdmVyeVR5cGVzPVsnaW1tZWRpYXRlJywnYnVmZmVyJ107aWYoaXNEZWZpbmVkKGV2ZW50c0RlbGl2ZXJ5VHlwZSkmJiFkZWxpdmVyeVR5cGVzLmluY2x1ZGVzKGV2ZW50c0RlbGl2ZXJ5VHlwZSkpe2V2ZW50c0RlbGl2ZXJ5VHlwZT1ERUZBVUxUX1BSRV9DT05TRU5UX0VWRU5UU19ERUxJVkVSWV9UWVBFO2xvZ2dlci53YXJuKFVOU1VQUE9SVEVEX1BSRV9DT05TRU5UX0VWRU5UU19ERUxJVkVSWV9UWVBFKENPTkZJR19NQU5BR0VSLHByZUNvbnNlbnRPcHRzPy5ldmVudHM/LmRlbGl2ZXJ5LERFRkFVTFRfUFJFX0NPTlNFTlRfRVZFTlRTX0RFTElWRVJZX1RZUEUpKTt9cigoKT0+e3N0YXRlLmNvbnNlbnRzLmFjdGl2ZUNvbnNlbnRNYW5hZ2VyUGx1Z2luTmFtZS52YWx1ZT1jb25zZW50TWFuYWdlclBsdWdpbk5hbWU7c3RhdGUuY29uc2VudHMuaW5pdGlhbGl6ZWQudmFsdWU9aW5pdGlhbGl6ZWQ7c3RhdGUuY29uc2VudHMuZW5hYmxlZC52YWx1ZT1lbmFibGVkO3N0YXRlLmNvbnNlbnRzLmRhdGEudmFsdWU9Y29uc2VudHNEYXRhO3N0YXRlLmNvbnNlbnRzLnByb3ZpZGVyLnZhbHVlPXByb3ZpZGVyO3N0YXRlLmNvbnNlbnRzLnByZUNvbnNlbnQudmFsdWU9ey8vIE9ubHkgZW5hYmxlIHByZS1jb25zZW50IGlmIGl0IGlzIGV4cGxpY2l0bHkgZW5hYmxlZCBhbmRcbi8vIGlmIGl0IGlzIG5vdCBhbHJlYWR5IGluaXRpYWxpemVkIGFuZFxuLy8gaWYgY29uc2VudCBtYW5hZ2VtZW50IGlzIGVuYWJsZWRcbmVuYWJsZWQ6c3RhdGUubG9hZE9wdGlvbnMudmFsdWUucHJlQ29uc2VudD8uZW5hYmxlZD09PXRydWUmJmluaXRpYWxpemVkPT09ZmFsc2UmJmVuYWJsZWQ9PT10cnVlLHN0b3JhZ2U6e3N0cmF0ZWd5OnN0b3JhZ2VTdHJhdGVneX0sZXZlbnRzOntkZWxpdmVyeTpldmVudHNEZWxpdmVyeVR5cGV9fTt9KTt9Oy8qKlxuICogRGV0ZXJtaW5lcyB0aGUgY29uc2VudCBtYW5hZ2VtZW50IHN0YXRlIHZhcmlhYmxlcyBmcm9tIHRoZSBzb3VyY2UgY29uZmlnIGRhdGFcbiAqIEBwYXJhbSByZXNwIFNvdXJjZSBjb25maWcgcmVzcG9uc2VcbiAqIEBwYXJhbSBsb2dnZXIgTG9nZ2VyIGluc3RhbmNlXG4gKi9jb25zdCB1cGRhdGVDb25zZW50c1N0YXRlPXJlc3A9PntsZXQgcmVzb2x1dGlvblN0cmF0ZWd5PXN0YXRlLmNvbnNlbnRzLnJlc29sdXRpb25TdHJhdGVneS52YWx1ZTtsZXQgY21wTWV0YWRhdGE7aWYoaXNPYmplY3RMaXRlcmFsQW5kTm90TnVsbChyZXNwLmNvbnNlbnRNYW5hZ2VtZW50TWV0YWRhdGEpKXtpZihzdGF0ZS5jb25zZW50cy5wcm92aWRlci52YWx1ZSl7cmVzb2x1dGlvblN0cmF0ZWd5PXJlc3AuY29uc2VudE1hbmFnZW1lbnRNZXRhZGF0YS5wcm92aWRlcnMuZmluZChwPT5wLnByb3ZpZGVyPT09c3RhdGUuY29uc2VudHMucHJvdmlkZXIudmFsdWUpPy5yZXNvbHV0aW9uU3RyYXRlZ3k/P3N0YXRlLmNvbnNlbnRzLnJlc29sdXRpb25TdHJhdGVneS52YWx1ZTt9Y21wTWV0YWRhdGE9cmVzcC5jb25zZW50TWFuYWdlbWVudE1ldGFkYXRhO30vLyBJZiB0aGUgcHJvdmlkZXIgaXMgY3VzdG9tLCB0aGVuIHRoZSByZXNvbHV0aW9uIHN0cmF0ZWd5IGlzIG5vdCBhcHBsaWNhYmxlXG5pZihzdGF0ZS5jb25zZW50cy5wcm92aWRlci52YWx1ZT09PSdjdXN0b20nKXtyZXNvbHV0aW9uU3RyYXRlZ3k9dW5kZWZpbmVkO31yKCgpPT57c3RhdGUuY29uc2VudHMubWV0YWRhdGEudmFsdWU9Y2xvbmUoY21wTWV0YWRhdGEpO3N0YXRlLmNvbnNlbnRzLnJlc29sdXRpb25TdHJhdGVneS52YWx1ZT1yZXNvbHV0aW9uU3RyYXRlZ3k7fSk7fTtjb25zdCB1cGRhdGVEYXRhUGxhbmVFdmVudHNTdGF0ZUZyb21Mb2FkT3B0aW9ucz1sb2dnZXI9PntpZihzdGF0ZS5kYXRhUGxhbmVFdmVudHMuZGVsaXZlcnlFbmFibGVkLnZhbHVlKXtjb25zdCBkZWZhdWx0RXZlbnRzUXVldWVQbHVnaW5OYW1lPSdYaHJRdWV1ZSc7bGV0IGV2ZW50c1F1ZXVlUGx1Z2luTmFtZT1kZWZhdWx0RXZlbnRzUXVldWVQbHVnaW5OYW1lO2lmKHN0YXRlLmxvYWRPcHRpb25zLnZhbHVlLnVzZUJlYWNvbil7aWYoc3RhdGUuY2FwYWJpbGl0aWVzLmlzQmVhY29uQXZhaWxhYmxlLnZhbHVlKXtldmVudHNRdWV1ZVBsdWdpbk5hbWU9J0JlYWNvblF1ZXVlJzt9ZWxzZSB7ZXZlbnRzUXVldWVQbHVnaW5OYW1lPWRlZmF1bHRFdmVudHNRdWV1ZVBsdWdpbk5hbWU7bG9nZ2VyLndhcm4oVU5TVVBQT1JURURfQkVBQ09OX0FQSV9XQVJOSU5HKENPTkZJR19NQU5BR0VSKSk7fX1yKCgpPT57c3RhdGUuZGF0YVBsYW5lRXZlbnRzLmV2ZW50c1F1ZXVlUGx1Z2luTmFtZS52YWx1ZT1ldmVudHNRdWV1ZVBsdWdpbk5hbWU7fSk7fX07Y29uc3QgZ2V0U291cmNlQ29uZmlnVVJMPShjb25maWdVcmwsd3JpdGVLZXksbG9ja0ludGVncmF0aW9uc1ZlcnNpb24sbG9ja1BsdWdpbnNWZXJzaW9uLGxvZ2dlcik9Pntjb25zdCBkZWZTZWFyY2hQYXJhbXM9bmV3IFVSTFNlYXJjaFBhcmFtcyh7cDpNT0RVTEVfVFlQRSx2OkFQUF9WRVJTSU9OLGJ1aWxkOkJVSUxEX1RZUEUsd3JpdGVLZXksbG9ja0ludGVncmF0aW9uc1ZlcnNpb246bG9ja0ludGVncmF0aW9uc1ZlcnNpb24udG9TdHJpbmcoKSxsb2NrUGx1Z2luc1ZlcnNpb246bG9ja1BsdWdpbnNWZXJzaW9uLnRvU3RyaW5nKCl9KTtsZXQgb3JpZ2luPURFRkFVTFRfQ09ORklHX0JFX1VSTDtsZXQgc2VhcmNoUGFyYW1zPWRlZlNlYXJjaFBhcmFtcztsZXQgcGF0aG5hbWU9Jy9zb3VyY2VDb25maWcvJztsZXQgaGFzaD0nJztpZihpc1ZhbGlkVVJMKGNvbmZpZ1VybCkpe2NvbnN0IGNvbmZpZ1VybEluc3RhbmNlPW5ldyBVUkwoY29uZmlnVXJsKTtpZighcmVtb3ZlVHJhaWxpbmdTbGFzaGVzKGNvbmZpZ1VybEluc3RhbmNlLnBhdGhuYW1lKS5lbmRzV2l0aCgnL3NvdXJjZUNvbmZpZycpKXtjb25maWdVcmxJbnN0YW5jZS5wYXRobmFtZT1gJHtyZW1vdmVUcmFpbGluZ1NsYXNoZXMoY29uZmlnVXJsSW5zdGFuY2UucGF0aG5hbWUpfS9zb3VyY2VDb25maWcvYDt9Y29uZmlnVXJsSW5zdGFuY2UucGF0aG5hbWU9cmVtb3ZlRHVwbGljYXRlU2xhc2hlcyhjb25maWdVcmxJbnN0YW5jZS5wYXRobmFtZSk7ZGVmU2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLGtleSk9PntpZihjb25maWdVcmxJbnN0YW5jZS5zZWFyY2hQYXJhbXMuZ2V0KGtleSk9PT1udWxsKXtjb25maWdVcmxJbnN0YW5jZS5zZWFyY2hQYXJhbXMuc2V0KGtleSx2YWx1ZSk7fX0pO29yaWdpbj1jb25maWdVcmxJbnN0YW5jZS5vcmlnaW47cGF0aG5hbWU9Y29uZmlnVXJsSW5zdGFuY2UucGF0aG5hbWU7c2VhcmNoUGFyYW1zPWNvbmZpZ1VybEluc3RhbmNlLnNlYXJjaFBhcmFtcztoYXNoPWNvbmZpZ1VybEluc3RhbmNlLmhhc2g7fWVsc2Uge2xvZ2dlci53YXJuKElOVkFMSURfQ09ORklHX1VSTF9XQVJOSU5HKENPTkZJR19NQU5BR0VSLGNvbmZpZ1VybCkpO31yZXR1cm4gYCR7b3JpZ2lufSR7cGF0aG5hbWV9PyR7c2VhcmNoUGFyYW1zfSR7aGFzaH1gO307LyoqXG4gKiBUcmFuc2Zvcm1zIGRlc3RpbmF0aW9ucyBjb25maWcgZnJvbSBzb3VyY2UgY29uZmlnIHJlc3BvbnNlIHRvIERlc3RpbmF0aW9uIGZvcm1hdFxuICogQHBhcmFtIGRlc3RpbmF0aW9ucyBBcnJheSBvZiBkZXN0aW5hdGlvbiBpdGVtcyBmcm9tIGNvbmZpZyByZXNwb25zZVxuICogQHJldHVybnMgQXJyYXkgb2YgdHJhbnNmb3JtZWQgRGVzdGluYXRpb24gb2JqZWN0c1xuICovY29uc3QgZ2V0RGVzdGluYXRpb25zRnJvbUNvbmZpZz1kZXN0aW5hdGlvbnM9PmRlc3RpbmF0aW9ucy5tYXAoZGVzdGluYXRpb249Pih7aWQ6ZGVzdGluYXRpb24uaWQsZGlzcGxheU5hbWU6ZGVzdGluYXRpb24uZGVzdGluYXRpb25EZWZpbml0aW9uLmRpc3BsYXlOYW1lLGVuYWJsZWQ6ZGVzdGluYXRpb24uZW5hYmxlZCxjb25maWc6ZGVzdGluYXRpb24uY29uZmlnLHNob3VsZEFwcGx5RGV2aWNlTW9kZVRyYW5zZm9ybWF0aW9uOmRlc3RpbmF0aW9uLnNob3VsZEFwcGx5RGV2aWNlTW9kZVRyYW5zZm9ybWF0aW9uPz9mYWxzZSxwcm9wYWdhdGVFdmVudHNVbnRyYW5zZm9ybWVkT25FcnJvcjpkZXN0aW5hdGlvbi5wcm9wYWdhdGVFdmVudHNVbnRyYW5zZm9ybWVkT25FcnJvcj8/ZmFsc2UsdXNlckZyaWVuZGx5SWQ6Z2V0RGVzdGluYXRpb25Vc2VyRnJpZW5kbHlJZChkZXN0aW5hdGlvbi5kZXN0aW5hdGlvbkRlZmluaXRpb24uZGlzcGxheU5hbWUsZGVzdGluYXRpb24uaWQpLGlzQ3VzdG9tSW50ZWdyYXRpb246ZGVzdGluYXRpb24uZGVzdGluYXRpb25EZWZpbml0aW9uLmRpc3BsYXlOYW1lPT09Q1VTVE9NX0RFVklDRV9NT0RFX0RFU1RJTkFUSU9OX0RJU1BMQVlfTkFNRX0pKTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB0aGUgYmFzZSBVUkwgZm9yIHRoZSBpbnRlZ3JhdGlvbnMgb3IgcGx1Z2lucyBTREtcbiAqIEBwYXJhbSBjb21wb25lbnRUeXBlIFRoZSB0eXBlIG9mIHRoZSBjb21wb25lbnQgKGludGVncmF0aW9ucyBvciBwbHVnaW5zKVxuICogQHBhcmFtIHBhdGhTdWZmaXggVGhlIHBhdGggc3VmZml4IHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBiYXNlIFVSTCAoanMtaW50ZWdyYXRpb25zIG9yIHBsdWdpbnMpXG4gKiBAcGFyYW0gZGVmYXVsdENvbXBvbmVudFVybCBUaGUgZGVmYXVsdCBVUkwgdG8gYmUgdXNlZCBpZiB0aGUgdXNlciBoYXMgbm90IHByb3ZpZGVkIGEgY3VzdG9tIFVSTFxuICogQHBhcmFtIGN1cnJlbnRTZGtWZXJzaW9uIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIFNES1xuICogQHBhcmFtIGxvY2tWZXJzaW9uIEZsYWcgdG8gbG9jayB0aGUgdmVyc2lvbiBvZiB0aGUgY29tcG9uZW50XG4gKiBAcGFyYW0gdXJsRnJvbUxvYWRPcHRpb25zIFRoZSBVUkwgcHJvdmlkZWQgYnkgdGhlIHVzZXIgaW4gdGhlIGxvYWQgb3B0aW9uc1xuICogQHBhcmFtIGxvZ2dlciBMb2dnZXIgaW5zdGFuY2VcbiAqIEByZXR1cm5zIFRoZSBiYXNlIFVSTCBmb3IgdGhlIGludGVncmF0aW9ucyBvciBwbHVnaW5zIFNES1xuICovY29uc3QgZ2V0U0RLQ29tcG9uZW50QmFzZVVSTD0oY29tcG9uZW50VHlwZSxwYXRoU3VmZml4LGRlZmF1bHRDb21wb25lbnRVcmwsY3VycmVudFNka1ZlcnNpb24sbG9ja1ZlcnNpb24sdXJsRnJvbUxvYWRPcHRpb25zLGxvZ2dlcik9PntsZXQgc2RrQ29tcG9uZW50QmFzZVVSTDsvLyBJZiB0aGUgdXNlciBoYXMgcHJvdmlkZWQgYSBjdXN0b20gVVJMLCB0aGVuIHZhbGlkYXRlLCBjbGVhbiB1cCBhbmQgdXNlIGl0XG5pZih1cmxGcm9tTG9hZE9wdGlvbnMpe2lmKCFpc1ZhbGlkVVJMKHVybEZyb21Mb2FkT3B0aW9ucykpe2xvZ2dlci5lcnJvcihDT01QT05FTlRfQkFTRV9VUkxfRVJST1IoQ09ORklHX01BTkFHRVIsY29tcG9uZW50VHlwZSx1cmxGcm9tTG9hZE9wdGlvbnMpKTtyZXR1cm4gbnVsbDt9c2RrQ29tcG9uZW50QmFzZVVSTD1yZW1vdmVUcmFpbGluZ1NsYXNoZXModXJsRnJvbUxvYWRPcHRpb25zKTt9ZWxzZSB7c2RrQ29tcG9uZW50QmFzZVVSTD1kZWZhdWx0Q29tcG9uZW50VXJsOy8vIFdlIGNhbiBhdXRvbWF0aWNhbGx5IGRldGVybWluZSB0aGUgYmFzZSBVUkwgb25seSBmb3IgQ0ROIGluc3RhbGxhdGlvbnNcbmlmKHN0YXRlLmNvbnRleHQuYXBwLnZhbHVlLmluc3RhbGxUeXBlPT09J2Nkbicpe2NvbnN0IHNka1VSTD1nZXRTREtVcmwoKTtpZihzZGtVUkwpey8vIEV4dHJhY3QgdGhlIGJhc2UgVVJMIGZyb20gdGhlIGNvcmUgU0RLIGZpbGUgVVJMXG4vLyBhbmQgYXBwZW5kIHRoZSBwYXRoIHN1ZmZpeCB0byBpdFxuc2RrQ29tcG9uZW50QmFzZVVSTD1zZGtVUkwuc3BsaXQoJy8nKS5zbGljZSgwLC0xKS5jb25jYXQocGF0aFN1ZmZpeCkuam9pbignLycpO319fS8vIElmIHRoZSB2ZXJzaW9uIG5lZWRzIHRvIGJlIGxvY2tlZCwgdGhlbiByZXBsYWNlIHRoZSBtYWpvciB2ZXJzaW9uIGluIHRoZSBVUkxcbi8vIHdpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgU0RLXG5pZihsb2NrVmVyc2lvbil7c2RrQ29tcG9uZW50QmFzZVVSTD1zZGtDb21wb25lbnRCYXNlVVJMLnJlcGxhY2UobmV3IFJlZ0V4cChgLyR7Q0ROX0FSQ0hfVkVSU0lPTl9ESVJ9LyR7QlVJTERfVFlQRX0vJHtwYXRoU3VmZml4fSRgKSxgLyR7Y3VycmVudFNka1ZlcnNpb259LyR7QlVJTERfVFlQRX0vJHtwYXRoU3VmZml4fWApO31yZXR1cm4gc2RrQ29tcG9uZW50QmFzZVVSTDt9Oy8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgaW50ZWdyYXRpb24gU0RLIGxvYWRpbmcgcGF0aFxuICogQHBhcmFtIGN1cnJlbnRTZGtWZXJzaW9uIEN1cnJlbnQgU0RLIHZlcnNpb25cbiAqIEBwYXJhbSBsb2NrSW50ZWdyYXRpb25zVmVyc2lvbiBGbGFnIHRvIGxvY2sgdGhlIGludGVncmF0aW9ucyB2ZXJzaW9uXG4gKiBAcGFyYW0gaW50ZWdyYXRpb25zVXJsRnJvbUxvYWRPcHRpb25zIFVSTCB0byBsb2FkIHRoZSBpbnRlZ3JhdGlvbnMgZnJvbSBhcyBwcm92aWRlZCBieSB0aGUgdXNlclxuICogQHBhcmFtIGxvZ2dlciBMb2dnZXIgaW5zdGFuY2VcbiAqIEByZXR1cm5zXG4gKi9jb25zdCBnZXRJbnRlZ3JhdGlvbnNDRE5QYXRoPShjdXJyZW50U2RrVmVyc2lvbixsb2NrSW50ZWdyYXRpb25zVmVyc2lvbixpbnRlZ3JhdGlvbnNVcmxGcm9tTG9hZE9wdGlvbnMsbG9nZ2VyKT0+Z2V0U0RLQ29tcG9uZW50QmFzZVVSTCgnaW50ZWdyYXRpb25zJyxDRE5fSU5UX0RJUixERUZBVUxUX0lOVEVHUkFUSU9OX1NES1NfVVJMLGN1cnJlbnRTZGtWZXJzaW9uLGxvY2tJbnRlZ3JhdGlvbnNWZXJzaW9uLGludGVncmF0aW9uc1VybEZyb21Mb2FkT3B0aW9ucyxsb2dnZXIpOy8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgcGx1Z2lucyBTREsgbG9hZGluZyBwYXRoXG4gKiBAcGFyYW0gY3VycmVudFNka1ZlcnNpb24gQ3VycmVudCBTREsgdmVyc2lvblxuICogQHBhcmFtIGxvY2tQbHVnaW5zVmVyc2lvbiBGbGFnIHRvIGxvY2sgdGhlIHBsdWdpbnMgdmVyc2lvblxuICogQHBhcmFtIHBsdWdpbnNVcmxGcm9tTG9hZE9wdGlvbnMgVVJMIHRvIGxvYWQgdGhlIHBsdWdpbnMgZnJvbSBhcyBwcm92aWRlZCBieSB0aGUgdXNlclxuICogQHBhcmFtIGxvZ2dlciBMb2dnZXIgaW5zdGFuY2VcbiAqIEByZXR1cm5zIEZpbmFsIHBsdWdpbnMgQ0ROIHBhdGhcbiAqL2NvbnN0IGdldFBsdWdpbnNDRE5QYXRoPShjdXJyZW50U2RrVmVyc2lvbixsb2NrUGx1Z2luc1ZlcnNpb24scGx1Z2luc1VybEZyb21Mb2FkT3B0aW9ucyxsb2dnZXIpPT5nZXRTREtDb21wb25lbnRCYXNlVVJMKCdwbHVnaW5zJyxDRE5fUExVR0lOU19ESVIsREVGQVVMVF9QTFVHSU5TX1VSTCxjdXJyZW50U2RrVmVyc2lvbixsb2NrUGx1Z2luc1ZlcnNpb24scGx1Z2luc1VybEZyb21Mb2FkT3B0aW9ucyxsb2dnZXIpO1xuXG5jbGFzcyBDb25maWdNYW5hZ2Vye2NvbnN0cnVjdG9yKGh0dHBDbGllbnQsZXJyb3JIYW5kbGVyLGxvZ2dlcil7dGhpcy5lcnJvckhhbmRsZXI9ZXJyb3JIYW5kbGVyO3RoaXMubG9nZ2VyPWxvZ2dlcjt0aGlzLmh0dHBDbGllbnQ9aHR0cENsaWVudDt0aGlzLm9uRXJyb3I9dGhpcy5vbkVycm9yLmJpbmQodGhpcyk7dGhpcy5wcm9jZXNzQ29uZmlnPXRoaXMucHJvY2Vzc0NvbmZpZy5iaW5kKHRoaXMpO31hdHRhY2hFZmZlY3RzKCl7RSgoKT0+e3RoaXMubG9nZ2VyLnNldE1pbkxvZ0xldmVsKHN0YXRlLmxpZmVjeWNsZS5sb2dMZXZlbC52YWx1ZSk7fSk7fS8qKlxuICAgKiBBIGZ1bmN0aW9uIHRvIHZhbGlkYXRlLCBjb25zdHJ1Y3QgYW5kIHN0b3JlIGxvYWRPcHRpb24sIGxpZmVjeWNsZSwgc291cmNlIGFuZCBkZXN0aW5hdGlvblxuICAgKiBjb25maWcgcmVsYXRlZCBpbmZvcm1hdGlvbiBpbiBnbG9iYWwgc3RhdGVcbiAgICovaW5pdCgpe2NvbnN0e2xvZ0xldmVsLGNvbmZpZ1VybCxsb2NrSW50ZWdyYXRpb25zVmVyc2lvbixsb2NrUGx1Z2luc1ZlcnNpb24sZGVzdFNES0Jhc2VVUkwscGx1Z2luc1NES0Jhc2VVUkwsaW50ZWdyYXRpb25zfT1zdGF0ZS5sb2FkT3B0aW9ucy52YWx1ZTsvLyBkZXRlcm1pbmUgdGhlIHBhdGggdG8gZmV0Y2ggaW50ZWdyYXRpb24gU0RLIGZyb21cbmNvbnN0IGludGdDZG5Vcmw9Z2V0SW50ZWdyYXRpb25zQ0ROUGF0aChBUFBfVkVSU0lPTixsb2NrSW50ZWdyYXRpb25zVmVyc2lvbixkZXN0U0RLQmFzZVVSTCx0aGlzLmxvZ2dlcik7aWYoaXNOdWxsKGludGdDZG5VcmwpKXtyZXR1cm47fWxldCBwbHVnaW5zQ0ROUGF0aDt7Ly8gZGV0ZXJtaW5lIHRoZSBwYXRoIHRvIGZldGNoIHJlbW90ZSBwbHVnaW5zIGZyb21cbnBsdWdpbnNDRE5QYXRoPWdldFBsdWdpbnNDRE5QYXRoKEFQUF9WRVJTSU9OLGxvY2tQbHVnaW5zVmVyc2lvbixwbHVnaW5zU0RLQmFzZVVSTCx0aGlzLmxvZ2dlcik7fWlmKHBsdWdpbnNDRE5QYXRoPT09bnVsbCl7cmV0dXJuO310aGlzLmF0dGFjaEVmZmVjdHMoKTtzdGF0ZS5saWZlY3ljbGUuYWN0aXZlRGF0YXBsYW5lVXJsLnZhbHVlPXJlbW92ZVRyYWlsaW5nU2xhc2hlcyhzdGF0ZS5saWZlY3ljbGUuZGF0YVBsYW5lVXJsLnZhbHVlKTt1cGRhdGVTdG9yYWdlU3RhdGVGcm9tTG9hZE9wdGlvbnModGhpcy5sb2dnZXIpO3VwZGF0ZUNvbnNlbnRzU3RhdGVGcm9tTG9hZE9wdGlvbnModGhpcy5sb2dnZXIpO3VwZGF0ZURhdGFQbGFuZUV2ZW50c1N0YXRlRnJvbUxvYWRPcHRpb25zKHRoaXMubG9nZ2VyKTsvLyBzZXQgYXBwbGljYXRpb24gbGlmZWN5Y2xlIHN0YXRlIGluIGdsb2JhbCBzdGF0ZVxucigoKT0+e3N0YXRlLmxpZmVjeWNsZS5pbnRlZ3JhdGlvbnNDRE5QYXRoLnZhbHVlPWludGdDZG5Vcmw7c3RhdGUubGlmZWN5Y2xlLnBsdWdpbnNDRE5QYXRoLnZhbHVlPXBsdWdpbnNDRE5QYXRoO2lmKGxvZ0xldmVsKXtzdGF0ZS5saWZlY3ljbGUubG9nTGV2ZWwudmFsdWU9bG9nTGV2ZWw7fXN0YXRlLmxpZmVjeWNsZS5zb3VyY2VDb25maWdVcmwudmFsdWU9Z2V0U291cmNlQ29uZmlnVVJMKGNvbmZpZ1VybCxzdGF0ZS5saWZlY3ljbGUud3JpdGVLZXkudmFsdWUsbG9ja0ludGVncmF0aW9uc1ZlcnNpb24sbG9ja1BsdWdpbnNWZXJzaW9uLHRoaXMubG9nZ2VyKTtzdGF0ZS5tZXRyaWNzLm1ldHJpY3NTZXJ2aWNlVXJsLnZhbHVlPWAke3N0YXRlLmxpZmVjeWNsZS5hY3RpdmVEYXRhcGxhbmVVcmwudmFsdWV9LyR7TUVUUklDU19TRVJWSUNFX0VORFBPSU5UfWA7Ly8gRGF0YSBpbiB0aGUgbG9hZE9wdGlvbnMgc3RhdGUgaXMgYWxyZWFkeSBub3JtYWxpemVkXG5zdGF0ZS5uYXRpdmVEZXN0aW5hdGlvbnMubG9hZE9ubHlJbnRlZ3JhdGlvbnMudmFsdWU9aW50ZWdyYXRpb25zO30pO3RoaXMuZ2V0Q29uZmlnKCk7fS8qKlxuICAgKiBIYW5kbGUgZXJyb3JzXG4gICAqL29uRXJyb3IoZXJyb3IsY3VzdG9tTWVzc2FnZSxncm91cGluZ0hhc2gpe3RoaXMuZXJyb3JIYW5kbGVyLm9uRXJyb3Ioe2Vycm9yLGNvbnRleHQ6Q09ORklHX01BTkFHRVIsY3VzdG9tTWVzc2FnZSxncm91cGluZ0hhc2h9KTt9LyoqXG4gICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBvbmNlIHdlIGZldGNoIHRoZSBzb3VyY2UgY29uZmlnIHJlc3BvbnNlLlxuICAgKiBVc2UgdG8gY29uc3RydWN0IGFuZCBzdG9yZSBpbmZvcm1hdGlvbiB0aGF0IGFyZSBkZXBlbmRlbnQgb24gdGhlIHNvdXJjZUNvbmZpZy5cbiAgICovcHJvY2Vzc0NvbmZpZyhyZXNwb25zZSxkZXRhaWxzKXsvLyBUT0RPOiBhZGQgcmV0cnkgbG9naWMgd2l0aCBiYWNrb2ZmIGJhc2VkIG9uIHJlamVjdGlvbkRldGFpbHMueGhyLnN0YXR1c1xuLy8gV2UgY2FuIHVzZSBpc0VyclJldHJ5YWJsZSB1dGlsaXR5IG1ldGhvZFxuaWYoIWlzRGVmaW5lZChyZXNwb25zZSkpe2lmKGlzRGVmaW5lZChkZXRhaWxzKSl7dGhpcy5vbkVycm9yKGRldGFpbHMuZXJyb3IsU09VUkNFX0NPTkZJR19GRVRDSF9FUlJPUik7fWVsc2Uge3RoaXMub25FcnJvcihuZXcgRXJyb3IoU09VUkNFX0NPTkZJR19GRVRDSF9FUlJPUikpO31yZXR1cm47fWxldCByZXM7dHJ5e2lmKGlzU3RyaW5nKHJlc3BvbnNlKSl7cmVzPUpTT04ucGFyc2UocmVzcG9uc2UpO31lbHNlIHtyZXM9cmVzcG9uc2U7fX1jYXRjaChlcnIpe3RoaXMub25FcnJvcihlcnIsU09VUkNFX0NPTkZJR19SRVNPTFVUSU9OX0VSUk9SKTtyZXR1cm47fWlmKCFpc1ZhbGlkU291cmNlQ29uZmlnKHJlcykpe3RoaXMub25FcnJvcihuZXcgRXJyb3IoU09VUkNFX0NPTkZJR19SRVNPTFVUSU9OX0VSUk9SKSk7cmV0dXJuO30vLyBMb2cgZXJyb3IgYW5kIGFib3J0IGlmIHNvdXJjZSBpcyBkaXNhYmxlZFxuaWYocmVzLnNvdXJjZS5lbmFibGVkPT09ZmFsc2Upe3RoaXMubG9nZ2VyLmVycm9yKFNPVVJDRV9ESVNBQkxFRF9FUlJPUik7cmV0dXJuO30vLyBzZXQgdGhlIHZhbHVlcyBpbiBzdGF0ZSBmb3IgcmVwb3J0aW5nIHNsaWNlXG51cGRhdGVSZXBvcnRpbmdTdGF0ZShyZXMpO2NvbnN0IG5hdGl2ZURlc3RpbmF0aW9ucz1yZXMuc291cmNlLmRlc3RpbmF0aW9ucy5sZW5ndGg+MD9nZXREZXN0aW5hdGlvbnNGcm9tQ29uZmlnKHJlcy5zb3VyY2UuZGVzdGluYXRpb25zKTpbXTsvLyBzZXQgaW4gdGhlIHN0YXRlIC0tPiBzb3VyY2UsIGRlc3RpbmF0aW9uLCBsaWZlY3ljbGUsIHJlcG9ydGluZ1xucigoKT0+ey8vIHNldCBzb3VyY2UgcmVsYXRlZCBpbmZvcm1hdGlvbiBpbiBzdGF0ZVxuc3RhdGUuc291cmNlLnZhbHVlPXtjb25maWc6cmVzLnNvdXJjZS5jb25maWcsbmFtZTpyZXMuc291cmNlLm5hbWUsaWQ6cmVzLnNvdXJjZS5pZCx3b3Jrc3BhY2VJZDpyZXMuc291cmNlLndvcmtzcGFjZUlkfTsvLyBzZXQgZGV2aWNlIG1vZGUgZGVzdGluYXRpb24gcmVsYXRlZCBpbmZvcm1hdGlvbiBpbiBzdGF0ZVxuc3RhdGUubmF0aXZlRGVzdGluYXRpb25zLmNvbmZpZ3VyZWREZXN0aW5hdGlvbnMudmFsdWU9bmF0aXZlRGVzdGluYXRpb25zOy8vIHNldCB0aGUgZGVzaXJlZCBvcHRpb25hbCBwbHVnaW5zXG5zdGF0ZS5wbHVnaW5zLnBsdWdpbnNUb0xvYWRGcm9tQ29uZmlnLnZhbHVlPXN0YXRlLmxvYWRPcHRpb25zLnZhbHVlLnBsdWdpbnM/P1tdO3VwZGF0ZUNvbnNlbnRzU3RhdGUocmVzKTsvLyBzZXQgYXBwbGljYXRpb24gbGlmZWN5Y2xlIHN0YXRlXG5zdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlPSdjb25maWd1cmVkJzt9KTt9LyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gZmV0Y2ggc291cmNlIGNvbmZpZyBlaXRoZXIgZnJvbSAvc291cmNlQ29uZmlnIGVuZHBvaW50XG4gICAqIG9yIGZyb20gZ2V0U291cmNlQ29uZmlnIGxvYWQgb3B0aW9uXG4gICAqIEByZXR1cm5zXG4gICAqL2dldENvbmZpZygpe2NvbnN0IHNvdXJjZUNvbmZpZ0Z1bmM9c3RhdGUubG9hZE9wdGlvbnMudmFsdWUuZ2V0U291cmNlQ29uZmlnO2lmKHNvdXJjZUNvbmZpZ0Z1bmMpe2lmKCFpc0Z1bmN0aW9uKHNvdXJjZUNvbmZpZ0Z1bmMpKXt0aGlzLmxvZ2dlci5lcnJvcihTT1VSQ0VfQ09ORklHX09QVElPTl9FUlJPUihDT05GSUdfTUFOQUdFUikpO3JldHVybjt9Ly8gRmV0Y2ggc291cmNlIGNvbmZpZyBmcm9tIHRoZSBmdW5jdGlvblxuY29uc3QgcmVzPXNvdXJjZUNvbmZpZ0Z1bmMoKTtpZihyZXMgaW5zdGFuY2VvZiBQcm9taXNlKXtyZXMudGhlbihwUmVzPT50aGlzLnByb2Nlc3NDb25maWcocFJlcykpLmNhdGNoKGVycj0+e3RoaXMub25FcnJvcihlcnIsJ1NvdXJjZUNvbmZpZycpO30pO31lbHNlIHt0aGlzLnByb2Nlc3NDb25maWcocmVzKTt9fWVsc2Ugey8vIEZldGNoIHNvdXJjZSBjb25maWd1cmF0aW9uIGZyb20gdGhlIGNvbmZpZ3VyZWQgVVJMXG50aGlzLmh0dHBDbGllbnQuZ2V0QXN5bmNEYXRhKHt1cmw6c3RhdGUubGlmZWN5Y2xlLnNvdXJjZUNvbmZpZ1VybC52YWx1ZSxvcHRpb25zOntoZWFkZXJzOnsnQ29udGVudC1UeXBlJzp1bmRlZmluZWR9fSxjYWxsYmFjazp0aGlzLnByb2Nlc3NDb25maWd9KTt9fX1cblxuLyoqXG4gKiBUbyBnZXQgdGhlIHRpbWV6b25lIG9mIHRoZSB1c2VyXG4gKlxuICogQHJldHVybnMgc3RyaW5nXG4gKi9jb25zdCBnZXRUaW1lem9uZT0oKT0+ey8vIE5vdCBzdXNjZXB0aWJsZSB0byBzdXBlci1saW5lYXIgYmFja3RyYWNraW5nXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29uYXJqcy9zbG93LXJlZ2V4XG5jb25zdCB0aW1lem9uZT0vKFtBLVpdK1srLV1cXGQrKS8uZXhlYyhuZXcgRGF0ZSgpLnRvU3RyaW5nKCkpO3JldHVybiB0aW1lem9uZT8uWzFdP3RpbWV6b25lWzFdOidOQSc7fTtcblxuLyoqXG4gKiBHZXQgdGhlIHJlZmVycmVyIFVSTFxuICogQHJldHVybnMgVGhlIHJlZmVycmVyIFVSTFxuICovY29uc3QgZ2V0UmVmZXJyZXI9KGdldERvY3VtZW50PSgpPT5kb2N1bWVudCk9PmdldERvY3VtZW50KCk/LnJlZmVycmVyfHwnJGRpcmVjdCc7LyoqXG4gKiBUbyBnZXQgdGhlIGNhbm9uaWNhbCBVUkwgb2YgdGhlIHBhZ2VcbiAqIEByZXR1cm5zIGNhbm9uaWNhbCBVUkxcbiAqL2NvbnN0IGdldENhbm9uaWNhbFVybD0oZ2V0RG9jdW1lbnQ9KCk9PmRvY3VtZW50KT0+e2NvbnN0IGRvY0luc3RhbmNlPWdldERvY3VtZW50KCk7Y29uc3QgdGFncz1kb2NJbnN0YW5jZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpO2xldCBjYW5vbmljYWxVcmw9Jyc7Zm9yKGxldCBpPTA7dGFnc1tpXTtpKz0xKXtjb25zdCB0YWc9dGFnc1tpXTtpZih0YWcuZ2V0QXR0cmlidXRlKCdyZWwnKT09PSdjYW5vbmljYWwnJiYhY2Fub25pY2FsVXJsKXtjYW5vbmljYWxVcmw9dGFnLmdldEF0dHJpYnV0ZSgnaHJlZicpPz8nJzticmVhazt9fXJldHVybiBjYW5vbmljYWxVcmw7fTtjb25zdCBnZXRVc2VyQWdlbnQ9KGdldE5hdmlnYXRvcj0oKT0+Z2xvYmFsVGhpcy5uYXZpZ2F0b3IpPT57Y29uc3QgbmF2aWdhdG9yPWdldE5hdmlnYXRvcigpO2lmKGlzVW5kZWZpbmVkKG5hdmlnYXRvcikpe3JldHVybiBudWxsO31sZXR7dXNlckFnZW50fT1uYXZpZ2F0b3I7Y29uc3R7YnJhdmV9PW5hdmlnYXRvcjsvLyBGb3Igc3VwcG9ydGluZyBCcmF2ZSBicm93c2VyIGRldGVjdGlvbixcbi8vIGFkZCBcIkJyYXZlLzx2ZXJzaW9uPlwiIHRvIHRoZSB1c2VyIGFnZW50IHdpdGggdGhlIHZlcnNpb24gdmFsdWUgZnJvbSB0aGUgQ2hyb21lIGNvbXBvbmVudFxuaWYoYnJhdmUmJk9iamVjdC5nZXRQcm90b3R5cGVPZihicmF2ZSkuaXNCcmF2ZSl7Ly8gRXhhbXBsZTpcbi8vIE1vemlsbGEvNS4wIChNYWNpbnRvc2g7IEludGVsIE1hYyBPUyBYIDEwXzE1XzcpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8xMDMuMC41MDYwLjExNCBTYWZhcmkvNTM3LjM2XG5jb25zdCBtYXRjaGVkQXJyPXVzZXJBZ2VudC5tYXRjaCgvKGNocm9tZSlcXC8oW1xcdy5dKykvaSk7aWYobWF0Y2hlZEFycil7dXNlckFnZW50PWAke3VzZXJBZ2VudH0gQnJhdmUvJHttYXRjaGVkQXJyWzJdfWA7fX1yZXR1cm4gdXNlckFnZW50O307Y29uc3QgZ2V0TGFuZ3VhZ2U9KGdldE5hdmlnYXRvcj0oKT0+Z2xvYmFsVGhpcy5uYXZpZ2F0b3IpPT57Y29uc3QgbmF2aWdhdG9yPWdldE5hdmlnYXRvcigpO2lmKGlzVW5kZWZpbmVkKG5hdmlnYXRvcikpe3JldHVybiBudWxsO31yZXR1cm4gbmF2aWdhdG9yLmxhbmd1YWdlPz9uYXZpZ2F0b3IuYnJvd3Nlckxhbmd1YWdlO307LyoqXG4gKiBEZWZhdWx0IHBhZ2UgcHJvcGVydGllc1xuICogQHJldHVybnMgRGVmYXVsdCBwYWdlIHByb3BlcnRpZXNcbiAqL2NvbnN0IGdldERlZmF1bHRQYWdlUHJvcGVydGllcz0oZ2V0TG9jYXRpb249KCk9Pmdsb2JhbFRoaXMubG9jYXRpb24sZ2V0RG9jdW1lbnQ9KCk9PmRvY3VtZW50KT0+e2NvbnN0IGxvY2F0aW9uPWdldExvY2F0aW9uKCk7Y29uc3QgY2Fub25pY2FsVXJsPWdldENhbm9uaWNhbFVybChnZXREb2N1bWVudCk7bGV0IHBhdGg9bG9jYXRpb24ucGF0aG5hbWU7Y29uc3R7aHJlZjp0YWJVcmx9PWxvY2F0aW9uO2xldCBwYWdlVXJsPXRhYlVybDtjb25zdHtzZWFyY2h9PWxvY2F0aW9uOy8vIElmIHZhbGlkIGNhbm9uaWNhbCBVUkwgaXMgcHJvdmlkZWQgdXNlIHRoaXMgYXMgcGFnZSBVUkwuXG5pZihjYW5vbmljYWxVcmwpe3RyeXtjb25zdCB1cmxPYmo9bmV3IFVSTChjYW5vbmljYWxVcmwpOy8vIElmIGV4aXN0aW5nLCBxdWVyeSBwYXJhbXMgb2YgY2Fub25pY2FsIFVSTCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgbG9jYXRpb24uc2VhcmNoIG9uZXNcbmlmKHVybE9iai5zZWFyY2g9PT0nJyl7cGFnZVVybD1jYW5vbmljYWxVcmwrc2VhcmNoO31lbHNlIHtwYWdlVXJsPWNhbm9uaWNhbFVybDt9cGF0aD11cmxPYmoucGF0aG5hbWU7fWNhdGNoKGVycil7Ly8gRG8gbm90aGluZ1xufX1jb25zdCB1cmw9Z2V0VXJsV2l0aG91dEhhc2gocGFnZVVybCk7Y29uc3R7dGl0bGV9PWdldERvY3VtZW50KCk7Y29uc3QgcmVmZXJyZXI9Z2V0UmVmZXJyZXIoZ2V0RG9jdW1lbnQpO3JldHVybiB7cGF0aCxyZWZlcnJlcixyZWZlcnJpbmdfZG9tYWluOmdldFJlZmVycmluZ0RvbWFpbihyZWZlcnJlciksc2VhcmNoLHRpdGxlLHVybCx0YWJfdXJsOnRhYlVybH07fTtcblxuY29uc3QgZ2V0VXNlckFnZW50Q2xpZW50SGludD0oY2FsbGJhY2ssbGV2ZWw9J25vbmUnKT0+e2lmKGxldmVsPT09J25vbmUnKXtjYWxsYmFjayh1bmRlZmluZWQpO31pZihsZXZlbD09PSdkZWZhdWx0Jyl7Y2FsbGJhY2sobmF2aWdhdG9yLnVzZXJBZ2VudERhdGEpO31pZihsZXZlbD09PSdmdWxsJyl7bmF2aWdhdG9yLnVzZXJBZ2VudERhdGE/LmdldEhpZ2hFbnRyb3B5VmFsdWVzKFsnYXJjaGl0ZWN0dXJlJywnYml0bmVzcycsJ2JyYW5kcycsJ21vYmlsZScsJ21vZGVsJywncGxhdGZvcm0nLCdwbGF0Zm9ybVZlcnNpb24nLCd1YUZ1bGxWZXJzaW9uJywnZnVsbFZlcnNpb25MaXN0Jywnd293NjQnXSkudGhlbih1YT0+e2NhbGxiYWNrKHVhKTt9KS5jYXRjaCgoKT0+e2NhbGxiYWNrKCk7fSk7fX07XG5cbmNvbnN0IGlzRGF0YXNldEF2YWlsYWJsZT0oKT0+e2NvbnN0IHRlc3RFbGVtZW50PWdsb2JhbFRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7dGVzdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWEtYicsJ2MnKTtyZXR1cm4gdGVzdEVsZW1lbnQuZGF0YXNldD90ZXN0RWxlbWVudC5kYXRhc2V0LmFCPT09J2MnOmZhbHNlO307Y29uc3QgbGVnYWN5SlNFbmdpbmVSZXF1aXJlZFBvbHlmaWxscz17Ly8gSWRlYWxseSwgd2Ugc2hvdWxkIHNlcGFyYXRlIHRoZSBjaGVja3MgZm9yIFVSTCBhbmQgVVJMU2VhcmNoUGFyYW1zIGJ1dFxuLy8gdGhlIHBvbHlmaWxsIHNlcnZpY2Ugc2VydmVzIHRoZW0gdW5kZXIgdGhlIHNhbWUgZmVhdHVyZSBuYW1lLCBcIlVSTFwiLlxuVVJMOigpPT4haXNGdW5jdGlvbihnbG9iYWxUaGlzLlVSTCl8fCFpc0Z1bmN0aW9uKGdsb2JhbFRoaXMuVVJMU2VhcmNoUGFyYW1zKSxQcm9taXNlOigpPT4haXNGdW5jdGlvbihnbG9iYWxUaGlzLlByb21pc2UpLCdOdW1iZXIuaXNOYU4nOigpPT4haXNGdW5jdGlvbihnbG9iYWxUaGlzLk51bWJlci5pc05hTiksJ051bWJlci5pc0ludGVnZXInOigpPT4haXNGdW5jdGlvbihnbG9iYWxUaGlzLk51bWJlci5pc0ludGVnZXIpLCdBcnJheS5mcm9tJzooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5BcnJheS5mcm9tKSwnQXJyYXkucHJvdG90eXBlLmZpbmQnOigpPT4haXNGdW5jdGlvbihnbG9iYWxUaGlzLkFycmF5LnByb3RvdHlwZS5maW5kKSwnQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzJzooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5BcnJheS5wcm90b3R5cGUuaW5jbHVkZXMpLCdTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoJzooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5TdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKSwnU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoJzooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5TdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpLCdTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzJzooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5TdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKSwnU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlQWxsJzooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5TdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwpLCdTdHJpbmcuZnJvbUNvZGVQb2ludCc6KCk9PiFpc0Z1bmN0aW9uKGdsb2JhbFRoaXMuU3RyaW5nLmZyb21Db2RlUG9pbnQpLCdPYmplY3QuZW50cmllcyc6KCk9PiFpc0Z1bmN0aW9uKGdsb2JhbFRoaXMuT2JqZWN0LmVudHJpZXMpLCdPYmplY3QudmFsdWVzJzooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5PYmplY3QudmFsdWVzKSwnT2JqZWN0LmFzc2lnbic6KCk9PiFpc0Z1bmN0aW9uKGdsb2JhbFRoaXMuT2JqZWN0LmFzc2lnbiksJ09iamVjdC5mcm9tRW50cmllcyc6KCk9PiFpc0Z1bmN0aW9uKGdsb2JhbFRoaXMuT2JqZWN0LmZyb21FbnRyaWVzKSwnRWxlbWVudC5wcm90b3R5cGUuZGF0YXNldCc6KCk9PiFpc0RhdGFzZXRBdmFpbGFibGUoKSwvLyBJZGVhbGx5LCB3ZSBzaG91bGQgc2VwYXJhdGUgdGhlIGNoZWNrcyBmb3IgVGV4dEVuY29kZXIgYW5kIFRleHREZWNvZGVyIGJ1dFxuLy8gdGhlIHBvbHlmaWxsIHNlcnZpY2Ugc2VydmVzIHRoZW0gdW5kZXIgdGhlIHNhbWUgZmVhdHVyZSBuYW1lLCBcIlRleHRFbmNvZGVyXCIuXG5UZXh0RW5jb2RlcjooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5UZXh0RW5jb2Rlcil8fCFpc0Z1bmN0aW9uKGdsb2JhbFRoaXMuVGV4dERlY29kZXIpLHJlcXVlc3RBbmltYXRpb25GcmFtZTooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpfHwhaXNGdW5jdGlvbihnbG9iYWxUaGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSxDdXN0b21FdmVudDooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5DdXN0b21FdmVudCksJ25hdmlnYXRvci5zZW5kQmVhY29uJzooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5uYXZpZ2F0b3Iuc2VuZEJlYWNvbiksLy8gTm90ZSwgdGhlIHBvbHlmaWxsIHNlcnZpY2Ugc2VydmVzIGJvdGggQXJyYXlCdWZmZXIgYW5kIFVpbnQ4QXJyYXkgdW5kZXIgdGhlIHNhbWUgZmVhdHVyZSBuYW1lLCBcIkFycmF5QnVmZmVyXCIuXG5BcnJheUJ1ZmZlcjooKT0+IWlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5VaW50OEFycmF5KSxTZXQ6KCk9PiFpc0Z1bmN0aW9uKGdsb2JhbFRoaXMuU2V0KSxhdG9iOigpPT4haXNGdW5jdGlvbihnbG9iYWxUaGlzLmF0b2IpfTtjb25zdCBpc0xlZ2FjeUpTRW5naW5lPSgpPT57Y29uc3QgcmVxdWlyZWRDYXBhYmlsaXRpZXNMaXN0PU9iamVjdC5rZXlzKGxlZ2FjeUpTRW5naW5lUmVxdWlyZWRQb2x5ZmlsbHMpO2xldCBuZWVkc1BvbHlmaWxsPWZhbHNlOy8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWZvci1sb29wICovZm9yKGxldCBpPTA7aTxyZXF1aXJlZENhcGFiaWxpdGllc0xpc3QubGVuZ3RoO2krKyl7Y29uc3QgaXNDYXBhYmlsaXR5TWlzc2luZz1sZWdhY3lKU0VuZ2luZVJlcXVpcmVkUG9seWZpbGxzW3JlcXVpcmVkQ2FwYWJpbGl0aWVzTGlzdFtpXV07aWYoaXNGdW5jdGlvbihpc0NhcGFiaWxpdHlNaXNzaW5nKSYmaXNDYXBhYmlsaXR5TWlzc2luZygpKXtuZWVkc1BvbHlmaWxsPXRydWU7YnJlYWs7fX1yZXR1cm4gbmVlZHNQb2x5ZmlsbDt9O1xuXG5jb25zdCBwb2x5ZmlsbElvU2RrVXJsPSdodHRwczovL3BvbHlmaWxsLWZhc3RseS5pby92My9wb2x5ZmlsbC5taW4uanMnO2NvbnN0IFBPTFlGSUxMX1VSTD1gJHtwb2x5ZmlsbElvU2RrVXJsfT92ZXJzaW9uPTMuMTExLjAmZmVhdHVyZXM9JHtPYmplY3Qua2V5cyhsZWdhY3lKU0VuZ2luZVJlcXVpcmVkUG9seWZpbGxzKS5qb2luKCclMkMnKX1gO2NvbnN0IFBPTFlGSUxMX0xPQURfVElNRU9VVD0xMCoxMDAwOy8vIDEwIHNlY29uZHNcbmNvbnN0IFBPTFlGSUxMX1NDUklQVF9JRD0ncnVkZGVyc3RhY2tQb2x5ZmlsbCc7XG5cbmNvbnN0IGhhc0NyeXB0bz0oKT0+IWlzTnVsbE9yVW5kZWZpbmVkKGdsb2JhbFRoaXMuY3J5cHRvKSYmaXNGdW5jdGlvbihnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpOy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0IC0tIFdlIGFyZSBjaGVja2luZyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBuYXZpZ2F0b3IudXNlckFnZW50RGF0YVxuY29uc3QgaGFzVUFDbGllbnRIaW50cz0oKT0+IWlzTnVsbE9yVW5kZWZpbmVkKGdsb2JhbFRoaXMubmF2aWdhdG9yLnVzZXJBZ2VudERhdGEpO2NvbnN0IGhhc0JlYWNvbj0oKT0+IWlzTnVsbE9yVW5kZWZpbmVkKGdsb2JhbFRoaXMubmF2aWdhdG9yLnNlbmRCZWFjb24pJiZpc0Z1bmN0aW9uKGdsb2JhbFRoaXMubmF2aWdhdG9yLnNlbmRCZWFjb24pO1xuXG5jb25zdCBnZXRTY3JlZW5EZXRhaWxzPSgpPT57bGV0IHNjcmVlbkRldGFpbHM9e2RlbnNpdHk6MCx3aWR0aDowLGhlaWdodDowLGlubmVyV2lkdGg6MCxpbm5lckhlaWdodDowfTtzY3JlZW5EZXRhaWxzPXt3aWR0aDpnbG9iYWxUaGlzLnNjcmVlbi53aWR0aCxoZWlnaHQ6Z2xvYmFsVGhpcy5zY3JlZW4uaGVpZ2h0LGRlbnNpdHk6Z2xvYmFsVGhpcy5kZXZpY2VQaXhlbFJhdGlvLGlubmVyV2lkdGg6Z2xvYmFsVGhpcy5pbm5lcldpZHRoLGlubmVySGVpZ2h0Omdsb2JhbFRoaXMuaW5uZXJIZWlnaHR9O3JldHVybiBzY3JlZW5EZXRhaWxzO307XG5cbmNsYXNzIENhcGFiaWxpdGllc01hbmFnZXJ7Y29uc3RydWN0b3IoaHR0cENsaWVudCxlcnJvckhhbmRsZXIsbG9nZ2VyKXt0aGlzLmh0dHBDbGllbnQ9aHR0cENsaWVudDt0aGlzLmVycm9ySGFuZGxlcj1lcnJvckhhbmRsZXI7dGhpcy5sb2dnZXI9bG9nZ2VyO3RoaXMuZXh0ZXJuYWxTcmNMb2FkZXI9bmV3IEV4dGVybmFsU3JjTG9hZGVyKHRoaXMubG9nZ2VyKTt0aGlzLm9uRXJyb3I9dGhpcy5vbkVycm9yLmJpbmQodGhpcyk7dGhpcy5vblJlYWR5PXRoaXMub25SZWFkeS5iaW5kKHRoaXMpO31pbml0KCl7dGhpcy5wcmVwYXJlQnJvd3NlckNhcGFiaWxpdGllcygpO3RoaXMuYXR0YWNoV2luZG93TGlzdGVuZXJzKCk7fS8qKlxuICAgKiBEZXRlY3Qgc3VwcG9ydGVkIGNhcGFiaWxpdGllcyBhbmQgc2V0IHZhbHVlcyBpbiBzdGF0ZVxuICAgKi8vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuZGV0ZWN0QnJvd3NlckNhcGFiaWxpdGllcygpe3IoKCk9PnsvLyBTdG9yYWdlIHJlbGF0ZWQgZGV0YWlsc1xuc3RhdGUuY2FwYWJpbGl0aWVzLnN0b3JhZ2UuaXNDb29raWVTdG9yYWdlQXZhaWxhYmxlLnZhbHVlPWlzU3RvcmFnZUF2YWlsYWJsZShDT09LSUVfU1RPUkFHRSxnZXRTdG9yYWdlRW5naW5lKENPT0tJRV9TVE9SQUdFKSx0aGlzLmxvZ2dlcik7c3RhdGUuY2FwYWJpbGl0aWVzLnN0b3JhZ2UuaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUudmFsdWU9aXNTdG9yYWdlQXZhaWxhYmxlKExPQ0FMX1NUT1JBR0UsdW5kZWZpbmVkLHRoaXMubG9nZ2VyKTtzdGF0ZS5jYXBhYmlsaXRpZXMuc3RvcmFnZS5pc1Nlc3Npb25TdG9yYWdlQXZhaWxhYmxlLnZhbHVlPWlzU3RvcmFnZUF2YWlsYWJsZShTRVNTSU9OX1NUT1JBR0UsdW5kZWZpbmVkLHRoaXMubG9nZ2VyKTsvLyBCcm93c2VyIGZlYXR1cmUgZGV0ZWN0aW9uIGRldGFpbHNcbnN0YXRlLmNhcGFiaWxpdGllcy5pc0JlYWNvbkF2YWlsYWJsZS52YWx1ZT1oYXNCZWFjb24oKTtzdGF0ZS5jYXBhYmlsaXRpZXMuaXNVYUNIQXZhaWxhYmxlLnZhbHVlPWhhc1VBQ2xpZW50SGludHMoKTtzdGF0ZS5jYXBhYmlsaXRpZXMuaXNDcnlwdG9BdmFpbGFibGUudmFsdWU9aGFzQ3J5cHRvKCk7c3RhdGUuY2FwYWJpbGl0aWVzLmlzSUUxMS52YWx1ZT1pc0lFMTEoKTtzdGF0ZS5jYXBhYmlsaXRpZXMuaXNPbmxpbmUudmFsdWU9Z2xvYmFsVGhpcy5uYXZpZ2F0b3Iub25MaW5lOy8vIEdldCBwYWdlIGNvbnRleHQgZGV0YWlsc1xuc3RhdGUuY29udGV4dC51c2VyQWdlbnQudmFsdWU9Z2V0VXNlckFnZW50KCk7c3RhdGUuY29udGV4dC5sb2NhbGUudmFsdWU9Z2V0TGFuZ3VhZ2UoKTtzdGF0ZS5jb250ZXh0LnNjcmVlbi52YWx1ZT1nZXRTY3JlZW5EZXRhaWxzKCk7c3RhdGUuY29udGV4dC50aW1lem9uZS52YWx1ZT1nZXRUaW1lem9uZSgpO2lmKGhhc1VBQ2xpZW50SGludHMoKSl7Z2V0VXNlckFnZW50Q2xpZW50SGludCh1YWNoPT57c3RhdGUuY29udGV4dFsndWEtY2gnXS52YWx1ZT11YWNoO30sc3RhdGUubG9hZE9wdGlvbnMudmFsdWUudWFDaFRyYWNrTGV2ZWwpO319KTsvLyBBZCBibG9ja2VyIGRldGVjdGlvblxuRSgoKT0+e2lmKHN0YXRlLmxvYWRPcHRpb25zLnZhbHVlLnNlbmRBZGJsb2NrUGFnZT09PXRydWUmJnN0YXRlLmxpZmVjeWNsZS5zb3VyY2VDb25maWdVcmwudmFsdWUhPT11bmRlZmluZWQpe2RldGVjdEFkQmxvY2tlcnModGhpcy5odHRwQ2xpZW50KTt9fSk7fS8qKlxuICAgKiBEZXRlY3QgaWYgcG9seWZpbGxzIGFyZSByZXF1aXJlZCBhbmQgdGhlbiBsb2FkIHNjcmlwdCBmcm9tIHBvbHlmaWxsIFVSTFxuICAgKi9wcmVwYXJlQnJvd3NlckNhcGFiaWxpdGllcygpe3N0YXRlLmNhcGFiaWxpdGllcy5pc0xlZ2FjeURPTS52YWx1ZT1pc0xlZ2FjeUpTRW5naW5lKCk7Y29uc3QgY3VzdG9tUG9seWZpbGxVcmw9c3RhdGUubG9hZE9wdGlvbnMudmFsdWUucG9seWZpbGxVUkw7bGV0IHBvbHlmaWxsVXJsPVBPTFlGSUxMX1VSTDtpZihpc0RlZmluZWRBbmROb3ROdWxsKGN1c3RvbVBvbHlmaWxsVXJsKSl7aWYoaXNWYWxpZFVSTChjdXN0b21Qb2x5ZmlsbFVybCkpe3BvbHlmaWxsVXJsPWN1c3RvbVBvbHlmaWxsVXJsO31lbHNlIHt0aGlzLmxvZ2dlci53YXJuKElOVkFMSURfUE9MWUZJTExfVVJMX1dBUk5JTkcoQ0FQQUJJTElUSUVTX01BTkFHRVIsY3VzdG9tUG9seWZpbGxVcmwpKTt9fWNvbnN0IHNob3VsZExvYWRQb2x5ZmlsbD1zdGF0ZS5sb2FkT3B0aW9ucy52YWx1ZS5wb2x5ZmlsbElmUmVxdWlyZWQmJnN0YXRlLmNhcGFiaWxpdGllcy5pc0xlZ2FjeURPTS52YWx1ZSYmaXNWYWxpZFVSTChwb2x5ZmlsbFVybCk7aWYoc2hvdWxkTG9hZFBvbHlmaWxsKXtjb25zdCBpc0RlZmF1bHRQb2x5ZmlsbFNlcnZpY2U9cG9seWZpbGxVcmwhPT1zdGF0ZS5sb2FkT3B0aW9ucy52YWx1ZS5wb2x5ZmlsbFVSTDtpZihpc0RlZmF1bHRQb2x5ZmlsbFNlcnZpY2Upey8vIHdyaXRlIGtleSBzcGVjaWZpYyBjYWxsYmFja1xuLy8gTk9URTogd2UncmUgbm90IHB1dHRpbmcgdGhpcyBpbnRvIFJ1ZGRlclN0YWNrR2xvYmFscyBhcyBwcm92aWRpbmcgdGhlIHByb3BlcnR5IHBhdGggdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGluIHRoZSBwb2x5ZmlsbCBVUkwgaXMgbm90IHBvc3NpYmxlXG5jb25zdCBwb2x5ZmlsbENhbGxiYWNrTmFtZT1gUlNfcG9seWZpbGxDYWxsYmFja18ke3N0YXRlLmxpZmVjeWNsZS53cml0ZUtleS52YWx1ZX1gO2NvbnN0IHBvbHlmaWxsQ2FsbGJhY2s9KCk9Pnt0aGlzLm9uUmVhZHkoKTsvLyBSZW1vdmUgdGhlIGVudHJ5IGZyb20gd2luZG93IHNvIHdlIGRvbid0IGxlYXZlIHJvb20gZm9yIGNhbGxpbmcgaXQgYWdhaW5cbmRlbGV0ZSBnbG9iYWxUaGlzW3BvbHlmaWxsQ2FsbGJhY2tOYW1lXTt9O2dsb2JhbFRoaXNbcG9seWZpbGxDYWxsYmFja05hbWVdPXBvbHlmaWxsQ2FsbGJhY2s7cG9seWZpbGxVcmw9YCR7cG9seWZpbGxVcmx9JmNhbGxiYWNrPSR7cG9seWZpbGxDYWxsYmFja05hbWV9YDt9dGhpcy5leHRlcm5hbFNyY0xvYWRlci5sb2FkSlNGaWxlKHt1cmw6cG9seWZpbGxVcmwsaWQ6UE9MWUZJTExfU0NSSVBUX0lELGFzeW5jOnRydWUsdGltZW91dDpQT0xZRklMTF9MT0FEX1RJTUVPVVQsY2FsbGJhY2s6c2NyaXB0SWQ9PntpZighc2NyaXB0SWQpe3RoaXMub25FcnJvcihuZXcgRXJyb3IoUE9MWUZJTExfU0NSSVBUX0xPQURfRVJST1IoUE9MWUZJTExfU0NSSVBUX0lELHBvbHlmaWxsVXJsKSkpO31lbHNlIGlmKCFpc0RlZmF1bHRQb2x5ZmlsbFNlcnZpY2Upe3RoaXMub25SZWFkeSgpO319fSk7fWVsc2Uge3RoaXMub25SZWFkeSgpO319LyoqXG4gICAqIEF0dGFjaCBsaXN0ZW5lcnMgdG8gd2luZG93IHRvIG9ic2VydmUgZXZlbnQgdGhhdCB1cGRhdGUgY2FwYWJpbGl0aWVzIHN0YXRlIHZhbHVlc1xuICAgKi9hdHRhY2hXaW5kb3dMaXN0ZW5lcnMoKXtnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCgpPT57c3RhdGUuY2FwYWJpbGl0aWVzLmlzT25saW5lLnZhbHVlPWZhbHNlO30pO2dsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywoKT0+e3N0YXRlLmNhcGFiaWxpdGllcy5pc09ubGluZS52YWx1ZT10cnVlO30pO2dsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJyxkZWJvdW5jZSgoKT0+e3N0YXRlLmNvbnRleHQuc2NyZWVuLnZhbHVlPWdldFNjcmVlbkRldGFpbHMoKTt9LHRoaXMpKTt9LyoqXG4gICAqIFNldCB0aGUgbGlmZWN5Y2xlIHN0YXR1cyB0byBuZXh0IHBoYXNlXG4gICAqLy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5vblJlYWR5KCl7dGhpcy5kZXRlY3RCcm93c2VyQ2FwYWJpbGl0aWVzKCk7c3RhdGUubGlmZWN5Y2xlLnN0YXR1cy52YWx1ZT0nYnJvd3NlckNhcGFiaWxpdGllc1JlYWR5Jzt9LyoqXG4gICAqIEhhbmRsZXMgZXJyb3JcbiAgICogQHBhcmFtIGVycm9yIFRoZSBlcnJvciBvYmplY3RcbiAgICovb25FcnJvcihlcnJvcixncm91cGluZ0hhc2gpe3RoaXMuZXJyb3JIYW5kbGVyLm9uRXJyb3Ioe2Vycm9yLGNvbnRleHQ6Q0FQQUJJTElUSUVTX01BTkFHRVIsZ3JvdXBpbmdIYXNofSk7fX1cblxuY29uc3QgQ0hBTk5FTD0nd2ViJzsvLyBUaGVzZSBhcmUgdGhlIHRvcC1sZXZlbCBlbGVtZW50cyBpbiB0aGUgc3RhbmRhcmQgUnVkZGVyU3RhY2sgZXZlbnQgc3BlY1xuY29uc3QgVE9QX0xFVkVMX0VMRU1FTlRTPVsnaW50ZWdyYXRpb25zJywnYW5vbnltb3VzSWQnLCdvcmlnaW5hbFRpbWVzdGFtcCddOy8vIFJlc2VydmVkIGVsZW1lbnRzIGluIHRoZSBjb250ZXh0IG9mIHN0YW5kYXJkIFJ1ZGRlclN0YWNrIGV2ZW50IHNwZWNcbi8vIFR5cGljYWxseSwgdGhlc2UgZWxlbWVudHMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHVzZXJcbmNvbnN0IENPTlRFWFRfUkVTRVJWRURfRUxFTUVOVFM9WydsaWJyYXJ5JywnY29uc2VudE1hbmFnZW1lbnQnLCd1c2VyQWdlbnQnLCd1YS1jaCcsJ3NjcmVlbiddOy8vIFJlc2VydmVkIGVsZW1lbnRzIGluIHRoZSBzdGFuZGFyZCBSdWRkZXJTdGFjayBldmVudCBzcGVjXG5jb25zdCBSRVNFUlZFRF9FTEVNRU5UUz1bJ2lkJywnYW5vbnltb3VzX2lkJywndXNlcl9pZCcsJ3NlbnRfYXQnLCd0aW1lc3RhbXAnLCdyZWNlaXZlZF9hdCcsJ29yaWdpbmFsX3RpbWVzdGFtcCcsJ2V2ZW50JywnZXZlbnRfdGV4dCcsJ2NoYW5uZWwnLCdjb250ZXh0X2lwJywnY29udGV4dF9yZXF1ZXN0X2lwJywnY29udGV4dF9wYXNzZWRfaXAnLCdncm91cF9pZCcsJ3ByZXZpb3VzX2lkJ107XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjaGVjayBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlciBvciBub3RcbiAqIEBwYXJhbSBudW0gaW5wdXQgdmFsdWVcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL2NvbnN0IGlzTnVtYmVyPW51bT0+dHlwZW9mIG51bT09PSdudW1iZXInJiYhTnVtYmVyLmlzTmFOKG51bSk7LyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNoZWNrIGdpdmVuIG51bWJlciBoYXMgbWluaW11bSBsZW5ndGggb3Igbm90XG4gKiBAcGFyYW0gbWluaW11bUxlbmd0aCAgICAgbWluaW11bSBsZW5ndGhcbiAqIEBwYXJhbSBudW0gICAgICAgICAgICAgICBpbnB1dCBudW1iZXJcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL2NvbnN0IGhhc01pbkxlbmd0aD0obWluaW11bUxlbmd0aCxudW0pPT5udW0udG9TdHJpbmcoKS5sZW5ndGg+PW1pbmltdW1MZW5ndGg7LyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNoZWNrIGdpdmVuIHZhbHVlIGlzIGEgcG9zaXRpdmUgaW50ZWdlciBvciBub3RcbiAqIEBwYXJhbSBudW0gaW5wdXQgdmFsdWVcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL2NvbnN0IGlzUG9zaXRpdmVJbnRlZ2VyPW51bT0+aXNOdW1iZXIobnVtKSYmbnVtPj0wJiZOdW1iZXIuaXNJbnRlZ2VyKG51bSk7XG5cbmNvbnN0IE1JTl9TRVNTSU9OX0lEX0xFTkdUSD0xMDtjb25zdCBpc0N1dE9mZlRpbWVFeGNlZWRlZD1zZXNzaW9uSW5mbz0+e2NvbnN0e2N1dE9mZn09c2Vzc2lvbkluZm87Y29uc3QgdGltZXN0YW1wPURhdGUubm93KCk7cmV0dXJuIEJvb2xlYW4oY3V0T2ZmPy5lbmFibGVkJiZjdXRPZmYuZXhwaXJlc0F0JiZ0aW1lc3RhbXA+Y3V0T2ZmLmV4cGlyZXNBdCk7fTsvKipcbiAqIEEgZnVuY3Rpb24gdG8gdmFsaWRhdGUgd2hldGhlciB0aGUgY3VycmVudCBhdXRvIHRyYWNraW5nIHNlc3Npb24gaGFzIGV4cGlyZWQgb3Igbm90LlxuICogSXQgY2hlY2tzIGZvciB0aGUgY3VycmVudCBzZXNzaW9uIGV4cGlyeSBhbmQgdGhlIGN1dCBvZmYgdGltZSBleHBpcnkuXG4gKiBAcGFyYW0gc2Vzc2lvbkluZm8gc2Vzc2lvbiBpbmZvXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9jb25zdCBoYXNTZXNzaW9uRXhwaXJlZD1zZXNzaW9uSW5mbz0+e2NvbnN0IGlzQ3VycmVudFNlc3Npb25FeHBpcmVkPUJvb2xlYW4oIXNlc3Npb25JbmZvLmV4cGlyZXNBdHx8RGF0ZS5ub3coKT5zZXNzaW9uSW5mby5leHBpcmVzQXQpO3JldHVybiBpc0N1cnJlbnRTZXNzaW9uRXhwaXJlZHx8aXNDdXRPZmZUaW1lRXhjZWVkZWQoc2Vzc2lvbkluZm8pO307LyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHNlc3Npb24gaWRcbiAqIEByZXR1cm5zIG51bWJlclxuICovY29uc3QgZ2VuZXJhdGVTZXNzaW9uSWQ9KCk9PkRhdGUubm93KCk7LyoqXG4gKiBGdW5jdGlvbiB0byB2YWxpZGF0ZSB1c2VyIHByb3ZpZGVkIHNlc3Npb25JZFxuICogQHBhcmFtIHtudW1iZXJ9IHNlc3Npb25JZFxuICogQHBhcmFtIGxvZ2dlciBsb2dnZXJcbiAqIEByZXR1cm5zXG4gKi9jb25zdCBpc01hbnVhbFNlc3Npb25JZFZhbGlkPShzZXNzaW9uSWQsbG9nZ2VyKT0+e2lmKCFzZXNzaW9uSWR8fCFpc1Bvc2l0aXZlSW50ZWdlcihzZXNzaW9uSWQpfHwhaGFzTWluTGVuZ3RoKE1JTl9TRVNTSU9OX0lEX0xFTkdUSCxzZXNzaW9uSWQpKXtsb2dnZXIud2FybihJTlZBTElEX1NFU1NJT05fSURfV0FSTklORyhVU0VSX1NFU1NJT05fTUFOQUdFUixzZXNzaW9uSWQsTUlOX1NFU1NJT05fSURfTEVOR1RIKSk7cmV0dXJuIGZhbHNlO31yZXR1cm4gdHJ1ZTt9O2NvbnN0IGdldEN1dE9mZkV4cGlyYXRpb25UaW1lc3RhbXA9Y3V0T2ZmPT57aWYoIWN1dE9mZj8uZW5hYmxlZCl7cmV0dXJuIHVuZGVmaW5lZDt9cmV0dXJuIGN1dE9mZi5leHBpcmVzQXQ/Pyhpc1Bvc2l0aXZlSW50ZWdlcihjdXRPZmYuZHVyYXRpb24pP0RhdGUubm93KCkrY3V0T2ZmLmR1cmF0aW9uOnVuZGVmaW5lZCk7fTsvKipcbiAqIEEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgbmV3IGF1dG8gdHJhY2tpbmcgc2Vzc2lvblxuICogQHBhcmFtIHNlc3Npb25JbmZvIHNlc3Npb24gaW5mb1xuICogQHJldHVybnMgU2Vzc2lvbkluZm9cbiAqL2NvbnN0IGdlbmVyYXRlQXV0b1RyYWNraW5nU2Vzc2lvbj1zZXNzaW9uSW5mbz0+e2NvbnN0e3RpbWVvdXQsY3V0T2ZmfT1zZXNzaW9uSW5mbztjb25zdCB0aW1lc3RhbXA9RGF0ZS5ub3coKTtyZXR1cm4ge2lkOnRpbWVzdGFtcCwvLyBzZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wXG5leHBpcmVzQXQ6dGltZXN0YW1wK3RpbWVvdXQsLy8gc2V0IHRoZSBleHBpcnkgdGltZSBvZiB0aGUgc2Vzc2lvblxudGltZW91dCxhdXRvVHJhY2s6dHJ1ZSwuLi4oY3V0T2ZmJiZ7Y3V0T2ZmfSl9O307LyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIG5ldyBtYW51YWwgdHJhY2tpbmcgc2Vzc2lvblxuICogQHBhcmFtIGlkIFByb3ZpZGVkIHNlc3Npb25JZFxuICogQHBhcmFtIGxvZ2dlciBMb2dnZXIgbW9kdWxlXG4gKiBAcmV0dXJucyBTZXNzaW9uSW5mb1xuICovY29uc3QgZ2VuZXJhdGVNYW51YWxUcmFja2luZ1Nlc3Npb249KGlkLGxvZ2dlcik9Pntjb25zdCBzZXNzaW9uSWQ9aXNNYW51YWxTZXNzaW9uSWRWYWxpZChpZCxsb2dnZXIpP2lkOmdlbmVyYXRlU2Vzc2lvbklkKCk7cmV0dXJuIHtpZDpzZXNzaW9uSWQsc2Vzc2lvblN0YXJ0OnVuZGVmaW5lZCxtYW51YWxUcmFjazp0cnVlfTt9O2NvbnN0IGlzU3RvcmFnZVR5cGVWYWxpZEZvclN0b3JpbmdEYXRhPXN0b3JhZ2VUeXBlPT5Cb29sZWFuKHN0b3JhZ2VUeXBlPT09Q09PS0lFX1NUT1JBR0V8fHN0b3JhZ2VUeXBlPT09TE9DQUxfU1RPUkFHRXx8c3RvcmFnZVR5cGU9PT1TRVNTSU9OX1NUT1JBR0V8fHN0b3JhZ2VUeXBlPT09TUVNT1JZX1NUT1JBR0UpOy8qKlxuICogR2VuZXJhdGUgYSBuZXcgYW5vbnltb3VzSWRcbiAqIEByZXR1cm5zIHN0cmluZyBhbm9ueW1vdXNJRFxuICovY29uc3QgZ2VuZXJhdGVBbm9ueW1vdXNJZD0oKT0+Z2VuZXJhdGVVVUlEKCk7Y29uc3QgZ2V0RmluYWxSZXNldE9wdGlvbnM9b3B0aW9ucz0+ey8vIExlZ2FjeSBiZWhhdmlvcjogdG9nZ2xlIG9ubHkgYW5vbnltb3VzSWQgd2l0aG91dCBtdXRhdGluZyBkZWZhdWx0c1xuaWYoaXNCb29sZWFuKG9wdGlvbnMpKXtjb25zdHtlbnRyaWVzLC4uLnJlc3R9PURFRkFVTFRfUkVTRVRfT1BUSU9OUztyZXR1cm4gey4uLnJlc3QsZW50cmllczp7Li4uZW50cmllcyxhbm9ueW1vdXNJZDpvcHRpb25zfX07fS8vIE92ZXJyaWRlIGFueSBkZWZhdWx0cyB3aXRoIHRoZSB1c2VyIHByb3ZpZGVkIG9wdGlvbnNcbmlmKGlzT2JqZWN0TGl0ZXJhbEFuZE5vdE51bGwob3B0aW9ucykmJmlzT2JqZWN0TGl0ZXJhbEFuZE5vdE51bGwob3B0aW9ucy5lbnRyaWVzKSl7cmV0dXJuIG1lcmdlRGVlcFJpZ2h0KERFRkFVTFRfUkVTRVRfT1BUSU9OUyxvcHRpb25zKTt9cmV0dXJuIHsuLi5ERUZBVUxUX1JFU0VUX09QVElPTlN9O307XG5cbi8qKlxuICogVG8gZ2V0IHRoZSBwYWdlIHByb3BlcnRpZXMgZm9yIGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0gcGFnZVByb3BzIFBhZ2UgcHJvcGVydGllc1xuICogQHJldHVybnMgcGFnZSBwcm9wZXJ0aWVzIG9iamVjdCBmb3IgY29udGV4dFxuICovY29uc3QgZ2V0Q29udGV4dFBhZ2VQcm9wZXJ0aWVzPXBhZ2VQcm9wcz0+ey8vIE5lZWQgdG8gZ2V0IHVwZGF0ZWQgcGFnZSBkZXRhaWxzIG9uIGVhY2ggZXZlbnQgYXMgYW4gZXZlbnQgdG8gbm90aWZ5IG9uIFNQQSBVUkwgY2hhbmdlcyBkb2VzIG5vdCBzZWVtIHRvIGV4aXN0XG5jb25zdCBjdXJQYWdlUHJvcHM9Z2V0RGVmYXVsdFBhZ2VQcm9wZXJ0aWVzKCk7Y29uc3QgY3R4UGFnZVByb3BzPXt9O09iamVjdC5rZXlzKGN1clBhZ2VQcm9wcykuZm9yRWFjaChrZXk9PntjdHhQYWdlUHJvcHNba2V5XT1wYWdlUHJvcHM/LltrZXldfHxjdXJQYWdlUHJvcHNba2V5XTt9KTtjdHhQYWdlUHJvcHMuaW5pdGlhbF9yZWZlcnJlcj1wYWdlUHJvcHM/LmluaXRpYWxfcmVmZXJyZXJ8fHN0YXRlLnNlc3Npb24uaW5pdGlhbFJlZmVycmVyLnZhbHVlO2N0eFBhZ2VQcm9wcy5pbml0aWFsX3JlZmVycmluZ19kb21haW49cGFnZVByb3BzPy5pbml0aWFsX3JlZmVycmluZ19kb21haW58fHN0YXRlLnNlc3Npb24uaW5pdGlhbFJlZmVycmluZ0RvbWFpbi52YWx1ZTtyZXR1cm4gY3R4UGFnZVByb3BzO307LyoqXG4gKiBBZGQgYW55IG1pc3NpbmcgZGVmYXVsdCBwYWdlIHByb3BlcnRpZXMgdXNpbmcgdmFsdWVzIGZyb20gb3B0aW9ucyBhbmQgZGVmYXVsdHNcbiAqIEBwYXJhbSBwcm9wZXJ0aWVzIElucHV0IHBhZ2UgcHJvcGVydGllc1xuICogQHBhcmFtIG9wdGlvbnMgQVBJIG9wdGlvbnNcbiAqL2NvbnN0IGdldFVwZGF0ZWRQYWdlUHJvcGVydGllcz0ocHJvcGVydGllcyxvcHRpb25zKT0+e2NvbnN0IG9wdGlvbnNQYWdlUHJvcHM9b3B0aW9ucz8ucGFnZXx8e307Y29uc3QgcGFnZVByb3BzPXByb3BlcnRpZXM7Ly8gTmVlZCB0byBnZXQgdXBkYXRlZCBwYWdlIGRldGFpbHMgb24gZWFjaCBldmVudCBhcyBhbiBldmVudCB0byBub3RpZnkgb24gU1BBIFVSTCBjaGFuZ2VzIGRvZXMgbm90IHNlZW0gdG8gZXhpc3RcbmNvbnN0IGN1clBhZ2VQcm9wcz1nZXREZWZhdWx0UGFnZVByb3BlcnRpZXMoKTtPYmplY3Qua2V5cyhjdXJQYWdlUHJvcHMpLmZvckVhY2goa2V5PT57aWYoaXNVbmRlZmluZWQocGFnZVByb3BzW2tleV0pKXtwYWdlUHJvcHNba2V5XT1vcHRpb25zUGFnZVByb3BzW2tleV18fGN1clBhZ2VQcm9wc1trZXldO319KTtpZihpc1VuZGVmaW5lZChwYWdlUHJvcHMuaW5pdGlhbF9yZWZlcnJlcikpe3BhZ2VQcm9wcy5pbml0aWFsX3JlZmVycmVyPW9wdGlvbnNQYWdlUHJvcHMuaW5pdGlhbF9yZWZlcnJlcnx8c3RhdGUuc2Vzc2lvbi5pbml0aWFsUmVmZXJyZXIudmFsdWU7fWlmKGlzVW5kZWZpbmVkKHBhZ2VQcm9wcy5pbml0aWFsX3JlZmVycmluZ19kb21haW4pKXtwYWdlUHJvcHMuaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWluPW9wdGlvbnNQYWdlUHJvcHMuaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWlufHxzdGF0ZS5zZXNzaW9uLmluaXRpYWxSZWZlcnJpbmdEb21haW4udmFsdWU7fXJldHVybiBwYWdlUHJvcHM7fTsvKipcbiAqIFV0aWxpdHkgdG8gY2hlY2sgZm9yIHJlc2VydmVkIGtleXMgaW4gdGhlIGlucHV0IG9iamVjdFxuICogQHBhcmFtIG9iaiBHZW5lcmljIG9iamVjdFxuICogQHBhcmFtIHBhcmVudEtleVBhdGggT2JqZWN0J3MgcGFyZW50IGtleSBwYXRoXG4gKiBAcGFyYW0gbG9nZ2VyIExvZ2dlciBpbnN0YW5jZVxuICovY29uc3QgY2hlY2tGb3JSZXNlcnZlZEVsZW1lbnRzSW5PYmplY3Q9KG9iaixwYXJlbnRLZXlQYXRoLGxvZ2dlcik9PntpZihpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKG9iaikpe09iamVjdC5rZXlzKG9iaikuZm9yRWFjaChwcm9wZXJ0eT0+e2lmKFJFU0VSVkVEX0VMRU1FTlRTLmluY2x1ZGVzKHByb3BlcnR5KXx8UkVTRVJWRURfRUxFTUVOVFMuaW5jbHVkZXMocHJvcGVydHkudG9Mb3dlckNhc2UoKSkpe2xvZ2dlci53YXJuKFJFU0VSVkVEX0tFWVdPUkRfV0FSTklORyhFVkVOVF9NQU5BR0VSLHByb3BlcnR5LHBhcmVudEtleVBhdGgsUkVTRVJWRURfRUxFTUVOVFMpKTt9fSk7fX07LyoqXG4gKiBDaGVja3MgZm9yIHJlc2VydmVkIGtleXMgaW4gdHJhaXRzLCBwcm9wZXJ0aWVzLCBhbmQgY29udGV4dHVhbCB0cmFpdHNcbiAqIEBwYXJhbSBydWRkZXJFdmVudCBHZW5lcmF0ZWQgcnVkZGVyIGV2ZW50XG4gKiBAcGFyYW0gbG9nZ2VyIExvZ2dlciBpbnN0YW5jZVxuICovY29uc3QgY2hlY2tGb3JSZXNlcnZlZEVsZW1lbnRzPShydWRkZXJFdmVudCxsb2dnZXIpPT57Ly8gIHByb3BlcnRpZXMsIHRyYWl0cywgY29udGV4dHVhbFRyYWl0cyBhcmUgZWl0aGVyIHVuZGVmaW5lZCBvciBvYmplY3RcbmNvbnN0e3Byb3BlcnRpZXMsdHJhaXRzLGNvbnRleHR9PXJ1ZGRlckV2ZW50O2NvbnN0e3RyYWl0czpjb250ZXh0dWFsVHJhaXRzfT1jb250ZXh0O2NoZWNrRm9yUmVzZXJ2ZWRFbGVtZW50c0luT2JqZWN0KHByb3BlcnRpZXMsJ3Byb3BlcnRpZXMnLGxvZ2dlcik7Y2hlY2tGb3JSZXNlcnZlZEVsZW1lbnRzSW5PYmplY3QodHJhaXRzLCd0cmFpdHMnLGxvZ2dlcik7Y2hlY2tGb3JSZXNlcnZlZEVsZW1lbnRzSW5PYmplY3QoY29udGV4dHVhbFRyYWl0cywnY29udGV4dC50cmFpdHMnLGxvZ2dlcik7fTsvKipcbiAqIE92ZXJyaWRlcyB0aGUgdG9wLWxldmVsIGV2ZW50IHByb3BlcnRpZXMgd2l0aCBkYXRhIGZyb20gQVBJIG9wdGlvbnNcbiAqIEBwYXJhbSBydWRkZXJFdmVudCBHZW5lcmF0ZWQgcnVkZGVyIGV2ZW50XG4gKiBAcGFyYW0gb3B0aW9ucyBBUEkgb3B0aW9uc1xuICovY29uc3QgdXBkYXRlVG9wTGV2ZWxFdmVudEVsZW1lbnRzPShydWRkZXJFdmVudCxvcHRpb25zKT0+e2lmKG9wdGlvbnMuYW5vbnltb3VzSWQmJmlzU3RyaW5nKG9wdGlvbnMuYW5vbnltb3VzSWQpKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbnJ1ZGRlckV2ZW50LmFub255bW91c0lkPW9wdGlvbnMuYW5vbnltb3VzSWQ7fWlmKGlzTm9uRW1wdHlPYmplY3Qob3B0aW9ucy5pbnRlZ3JhdGlvbnMpKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbnJ1ZGRlckV2ZW50LmludGVncmF0aW9ucz1vcHRpb25zLmludGVncmF0aW9uczt9aWYob3B0aW9ucy5vcmlnaW5hbFRpbWVzdGFtcCYmaXNTdHJpbmcob3B0aW9ucy5vcmlnaW5hbFRpbWVzdGFtcCkpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxucnVkZGVyRXZlbnQub3JpZ2luYWxUaW1lc3RhbXA9b3B0aW9ucy5vcmlnaW5hbFRpbWVzdGFtcDt9fTsvKipcbiAqIFRvIG1lcmdlIHRoZSBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGluIEFQSSBvcHRpb25zIHdpdGggZXhpc3RpbmcgZGF0YVxuICogQHBhcmFtIHJ1ZGRlckNvbnRleHQgR2VuZXJhdGVkIHJ1ZGRlciBldmVudFxuICogQHBhcmFtIG9wdGlvbnMgQVBJIG9wdGlvbnNcbiAqIEBwYXJhbSBsb2dnZXIgTG9nZ2VyIGluc3RhbmNlXG4gKi9jb25zdCBnZXRNZXJnZWRDb250ZXh0PShydWRkZXJDb250ZXh0LG9wdGlvbnMsbG9nZ2VyKT0+e2xldCBjb250ZXh0PXJ1ZGRlckNvbnRleHQ7T2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChrZXk9PntpZighVE9QX0xFVkVMX0VMRU1FTlRTLmluY2x1ZGVzKGtleSkmJiFDT05URVhUX1JFU0VSVkVEX0VMRU1FTlRTLmluY2x1ZGVzKGtleSkpe2lmKGtleSE9PSdjb250ZXh0Jyl7Y29udGV4dD1tZXJnZURlZXBSaWdodChjb250ZXh0LHtba2V5XTpvcHRpb25zW2tleV19KTt9ZWxzZSBpZighaXNVbmRlZmluZWQob3B0aW9uc1trZXldKSYmaXNPYmplY3RMaXRlcmFsQW5kTm90TnVsbChvcHRpb25zW2tleV0pKXtjb25zdCB0ZW1wQ29udGV4dD17fTtPYmplY3Qua2V5cyhvcHRpb25zW2tleV0pLmZvckVhY2goZT0+e2lmKCFDT05URVhUX1JFU0VSVkVEX0VMRU1FTlRTLmluY2x1ZGVzKGUpKXt0ZW1wQ29udGV4dFtlXT1vcHRpb25zW2tleV1bZV07fX0pO2NvbnRleHQ9bWVyZ2VEZWVwUmlnaHQoY29udGV4dCx7Li4udGVtcENvbnRleHR9KTt9ZWxzZSB7bG9nZ2VyLndhcm4oSU5WQUxJRF9DT05URVhUX09CSkVDVF9XQVJOSU5HKEVWRU5UX01BTkFHRVIpKTt9fX0pO3JldHVybiBjb250ZXh0O307LyoqXG4gKiBVcGRhdGVzIHJ1ZGRlciBldmVudCBvYmplY3Qgd2l0aCBkYXRhIGZyb20gdGhlIEFQSSBvcHRpb25zXG4gKiBAcGFyYW0gcnVkZGVyRXZlbnQgR2VuZXJhdGVkIHJ1ZGRlciBldmVudFxuICogQHBhcmFtIG9wdGlvbnMgQVBJIG9wdGlvbnNcbiAqL2NvbnN0IHByb2Nlc3NPcHRpb25zPShydWRkZXJFdmVudCxvcHRpb25zLGxvZ2dlcik9PnsvLyBPbmx5IGFsbG93IG9iamVjdCB0eXBlIGZvciBvcHRpb25zXG5pZihpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKG9wdGlvbnMpKXt1cGRhdGVUb3BMZXZlbEV2ZW50RWxlbWVudHMocnVkZGVyRXZlbnQsb3B0aW9ucyk7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5ydWRkZXJFdmVudC5jb250ZXh0PWdldE1lcmdlZENvbnRleHQocnVkZGVyRXZlbnQuY29udGV4dCxvcHRpb25zLGxvZ2dlcik7fX07LyoqXG4gKiBSZXR1cm5zIHRoZSBmaW5hbCBpbnRlZ3JhdGlvbnMgY29uZmlnIGZvciB0aGUgZXZlbnQgYmFzZWQgb24gdGhlIGdsb2JhbCBjb25maWcgYW5kIGV2ZW50J3MgY29uZmlnXG4gKiBAcGFyYW0gaW50ZWdyYXRpb25zQ29uZmlnIEV2ZW50J3MgaW50ZWdyYXRpb25zIGNvbmZpZ1xuICogQHJldHVybnMgRmluYWwgaW50ZWdyYXRpb25zIGNvbmZpZ1xuICovY29uc3QgZ2V0RXZlbnRJbnRlZ3JhdGlvbnNDb25maWc9aW50ZWdyYXRpb25zQ29uZmlnPT57bGV0IGZpbmFsSW50Z0NvbmZpZztpZihzdGF0ZS5sb2FkT3B0aW9ucy52YWx1ZS51c2VHbG9iYWxJbnRlZ3JhdGlvbnNDb25maWdJbkV2ZW50cyl7Ly8gUHJlZmVyIHRoZSBpbnRlZ3JhdGlvbnMgb2JqZWN0IGZyb20gdGhlIGNvbnNlbnQgQVBJIHJlc3BvbnNlIG92ZXIgdGhlIGxvYWQgQVBJIGludGVncmF0aW9ucyBvYmplY3RcbmZpbmFsSW50Z0NvbmZpZz1zdGF0ZS5jb25zZW50cy5wb3N0Q29uc2VudC52YWx1ZS5pbnRlZ3JhdGlvbnM/P3N0YXRlLm5hdGl2ZURlc3RpbmF0aW9ucy5sb2FkT25seUludGVncmF0aW9ucy52YWx1ZTt9ZWxzZSBpZihpbnRlZ3JhdGlvbnNDb25maWcpe2ZpbmFsSW50Z0NvbmZpZz1pbnRlZ3JhdGlvbnNDb25maWc7fWVsc2Uge2ZpbmFsSW50Z0NvbmZpZz1ERUZBVUxUX0lOVEVHUkFUSU9OU19DT05GSUc7fXJldHVybiBjbG9uZShmaW5hbEludGdDb25maWcpO307LyoqXG4gKiBFbnJpY2ggdGhlIGJhc2UgZXZlbnQgb2JqZWN0IHdpdGggZGF0YSBmcm9tIHN0YXRlIGFuZCB0aGUgQVBJIG9wdGlvbnNcbiAqIEBwYXJhbSBydWRkZXJFdmVudCBSdWRkZXJFdmVudCBvYmplY3RcbiAqIEBwYXJhbSBvcHRpb25zIEFQSSBvcHRpb25zXG4gKiBAcGFyYW0gcGFnZVByb3BzIFBhZ2UgcHJvcGVydGllc1xuICogQHBhcmFtIGxvZ2dlciBsb2dnZXJcbiAqIEByZXR1cm5zIEVucmljaGVkIFJ1ZGRlckV2ZW50IG9iamVjdFxuICovY29uc3QgZ2V0RW5yaWNoZWRFdmVudD0ocnVkZGVyRXZlbnQsb3B0aW9ucyxwYWdlUHJvcHMsbG9nZ2VyKT0+e2NvbnN0IGNvbW1vbkV2ZW50RGF0YT17Y2hhbm5lbDpDSEFOTkVMLGNvbnRleHQ6e3RyYWl0czpjbG9uZShzdGF0ZS5zZXNzaW9uLnVzZXJUcmFpdHMudmFsdWUpLHNlc3Npb25JZDpzdGF0ZS5zZXNzaW9uLnNlc3Npb25JbmZvLnZhbHVlLmlkfHx1bmRlZmluZWQsc2Vzc2lvblN0YXJ0OnN0YXRlLnNlc3Npb24uc2Vzc2lvbkluZm8udmFsdWUuc2Vzc2lvblN0YXJ0fHx1bmRlZmluZWQsLy8gQWRkICdjb25zZW50TWFuYWdlbWVudCcgb25seSBpZiBjb25zZW50IG1hbmFnZW1lbnQgaXMgZW5hYmxlZFxuLi4uKHN0YXRlLmNvbnNlbnRzLmVuYWJsZWQudmFsdWUmJntjb25zZW50TWFuYWdlbWVudDp7ZGVuaWVkQ29uc2VudElkczpjbG9uZShzdGF0ZS5jb25zZW50cy5kYXRhLnZhbHVlLmRlbmllZENvbnNlbnRJZHMpLGFsbG93ZWRDb25zZW50SWRzOmNsb25lKHN0YXRlLmNvbnNlbnRzLmRhdGEudmFsdWUuYWxsb3dlZENvbnNlbnRJZHMpLHByb3ZpZGVyOnN0YXRlLmNvbnNlbnRzLnByb3ZpZGVyLnZhbHVlLHJlc29sdXRpb25TdHJhdGVneTpzdGF0ZS5jb25zZW50cy5yZXNvbHV0aW9uU3RyYXRlZ3kudmFsdWV9fSksJ3VhLWNoJzpzdGF0ZS5jb250ZXh0Wyd1YS1jaCddLnZhbHVlLGFwcDpzdGF0ZS5jb250ZXh0LmFwcC52YWx1ZSxsaWJyYXJ5OnN0YXRlLmNvbnRleHQubGlicmFyeS52YWx1ZSx1c2VyQWdlbnQ6c3RhdGUuY29udGV4dC51c2VyQWdlbnQudmFsdWUsb3M6c3RhdGUuY29udGV4dC5vcy52YWx1ZSxsb2NhbGU6c3RhdGUuY29udGV4dC5sb2NhbGUudmFsdWUsc2NyZWVuOnN0YXRlLmNvbnRleHQuc2NyZWVuLnZhbHVlLGNhbXBhaWduOmV4dHJhY3RVVE1QYXJhbWV0ZXJzKGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZikscGFnZTpnZXRDb250ZXh0UGFnZVByb3BlcnRpZXMocGFnZVByb3BzKSx0aW1lem9uZTpzdGF0ZS5jb250ZXh0LnRpbWV6b25lLnZhbHVlLC8vIEFkZCBhdXRvIHRyYWNraW5nIGluZm9ybWF0aW9uXG4uLi4oc3RhdGUuYXV0b1RyYWNrLmVuYWJsZWQudmFsdWUmJnthdXRvVHJhY2s6ey4uLihzdGF0ZS5hdXRvVHJhY2sucGFnZUxpZmVjeWNsZS5lbmFibGVkLnZhbHVlJiZ7cGFnZTp7cGFnZVZpZXdJZDpzdGF0ZS5hdXRvVHJhY2sucGFnZUxpZmVjeWNsZS5wYWdlVmlld0lkLnZhbHVlfX0pfX0pfSxvcmlnaW5hbFRpbWVzdGFtcDpnZXRDdXJyZW50VGltZUZvcm1hdHRlZCgpLG1lc3NhZ2VJZDpnZW5lcmF0ZVVVSUQoKSx1c2VySWQ6cnVkZGVyRXZlbnQudXNlcklkfHxzdGF0ZS5zZXNzaW9uLnVzZXJJZC52YWx1ZX07aWYoIWlzU3RvcmFnZVR5cGVWYWxpZEZvclN0b3JpbmdEYXRhKHN0YXRlLnN0b3JhZ2UuZW50cmllcy52YWx1ZS5hbm9ueW1vdXNJZD8udHlwZSkpey8vIEdlbmVyYXRlIG5ldyBhbm9ueW1vdXMgaWQgZm9yIGVhY2ggcmVxdWVzdFxuY29tbW9uRXZlbnREYXRhLmFub255bW91c0lkPWdlbmVyYXRlQW5vbnltb3VzSWQoKTt9ZWxzZSB7Ly8gVHlwZSBjYXN0aW5nIHRvIHN0cmluZyBhcyB0aGUgdXNlciBzZXNzaW9uIG1hbmFnZXIgd2lsbCB0YWtlIGNhcmUgb2YgaW5pdGlhbGl6aW5nIHRoZSB2YWx1ZVxuY29tbW9uRXZlbnREYXRhLmFub255bW91c0lkPXN0YXRlLnNlc3Npb24uYW5vbnltb3VzSWQudmFsdWU7fS8vIHNldCB0cnVseSBhbm9ueW1vdXMgdHJhY2tpbmcgZmxhZ1xuaWYoc3RhdGUuc3RvcmFnZS50cnVseUFub255bW91c1RyYWNraW5nLnZhbHVlKXtjb21tb25FdmVudERhdGEuY29udGV4dC50cnVseUFub255bW91c1RyYWNraW5nPXRydWU7fWlmKHJ1ZGRlckV2ZW50LnR5cGU9PT0naWRlbnRpZnknKXtjb21tb25FdmVudERhdGEuY29udGV4dC50cmFpdHM9c3RhdGUuc3RvcmFnZS5lbnRyaWVzLnZhbHVlLnVzZXJUcmFpdHM/LnR5cGUhPT1OT19TVE9SQUdFP2Nsb25lKHN0YXRlLnNlc3Npb24udXNlclRyYWl0cy52YWx1ZSk6cnVkZGVyRXZlbnQuY29udGV4dC50cmFpdHM7fWlmKHJ1ZGRlckV2ZW50LnR5cGU9PT0nZ3JvdXAnKXtpZihydWRkZXJFdmVudC5ncm91cElkfHxzdGF0ZS5zZXNzaW9uLmdyb3VwSWQudmFsdWUpe2NvbW1vbkV2ZW50RGF0YS5ncm91cElkPXJ1ZGRlckV2ZW50Lmdyb3VwSWR8fHN0YXRlLnNlc3Npb24uZ3JvdXBJZC52YWx1ZTt9aWYocnVkZGVyRXZlbnQudHJhaXRzfHxzdGF0ZS5zZXNzaW9uLmdyb3VwVHJhaXRzLnZhbHVlKXtjb21tb25FdmVudERhdGEudHJhaXRzPXN0YXRlLnN0b3JhZ2UuZW50cmllcy52YWx1ZS5ncm91cFRyYWl0cz8udHlwZSE9PU5PX1NUT1JBR0U/Y2xvbmUoc3RhdGUuc2Vzc2lvbi5ncm91cFRyYWl0cy52YWx1ZSk6cnVkZGVyRXZlbnQudHJhaXRzO319Y29uc3QgcHJvY2Vzc2VkRXZlbnQ9bWVyZ2VEZWVwUmlnaHQocnVkZGVyRXZlbnQsY29tbW9uRXZlbnREYXRhKTsvLyBTZXQgdGhlIGRlZmF1bHQgdmFsdWVzIGZvciB0aGUgZXZlbnQgcHJvcGVydGllc1xuLy8gbWF0Y2hpbmcgd2l0aCB2MS4xIHBheWxvYWRcbmlmKHByb2Nlc3NlZEV2ZW50LmV2ZW50PT09dW5kZWZpbmVkKXtwcm9jZXNzZWRFdmVudC5ldmVudD1udWxsO31pZihwcm9jZXNzZWRFdmVudC5wcm9wZXJ0aWVzPT09dW5kZWZpbmVkKXtwcm9jZXNzZWRFdmVudC5wcm9wZXJ0aWVzPW51bGw7fXByb2Nlc3NPcHRpb25zKHByb2Nlc3NlZEV2ZW50LG9wdGlvbnMsbG9nZ2VyKTtjaGVja0ZvclJlc2VydmVkRWxlbWVudHMocHJvY2Vzc2VkRXZlbnQsbG9nZ2VyKTsvLyBVcGRhdGUgdGhlIGludGVncmF0aW9ucyBjb25maWcgZm9yIHRoZSBldmVudFxucHJvY2Vzc2VkRXZlbnQuaW50ZWdyYXRpb25zPWdldEV2ZW50SW50ZWdyYXRpb25zQ29uZmlnKHByb2Nlc3NlZEV2ZW50LmludGVncmF0aW9ucyk7cmV0dXJuIHByb2Nlc3NlZEV2ZW50O307XG5cbmNsYXNzIFJ1ZGRlckV2ZW50RmFjdG9yeXtjb25zdHJ1Y3Rvcihsb2dnZXIpe3RoaXMubG9nZ2VyPWxvZ2dlcjt9LyoqXG4gICAqIEdlbmVyYXRlIGEgJ3BhZ2UnIGV2ZW50IGJhc2VkIG9uIHRoZSB1c2VyLWlucHV0IGZpZWxkc1xuICAgKiBAcGFyYW0gY2F0ZWdvcnkgUGFnZSdzIGNhdGVnb3J5XG4gICAqIEBwYXJhbSBuYW1lIFBhZ2UgbmFtZVxuICAgKiBAcGFyYW0gcHJvcGVydGllcyBQYWdlIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIG9wdGlvbnMgQVBJIG9wdGlvbnNcbiAgICovZ2VuZXJhdGVQYWdlRXZlbnQoY2F0ZWdvcnksbmFtZSxwcm9wZXJ0aWVzLG9wdGlvbnMpe2xldCBwcm9wcz1wcm9wZXJ0aWVzPz97fTtwcm9wcz1nZXRVcGRhdGVkUGFnZVByb3BlcnRpZXMocHJvcHMsb3B0aW9ucyk7Y29uc3QgcGFnZUV2ZW50PXtwcm9wZXJ0aWVzOnByb3BzLG5hbWUsY2F0ZWdvcnksdHlwZToncGFnZSd9O3JldHVybiBnZXRFbnJpY2hlZEV2ZW50KHBhZ2VFdmVudCxvcHRpb25zLHByb3BzLHRoaXMubG9nZ2VyKTt9LyoqXG4gICAqIEdlbmVyYXRlIGEgJ3RyYWNrJyBldmVudCBiYXNlZCBvbiB0aGUgdXNlci1pbnB1dCBmaWVsZHNcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBwcm9wZXJ0aWVzIEV2ZW50IHByb3BlcnRpZXNcbiAgICogQHBhcmFtIG9wdGlvbnMgQVBJIG9wdGlvbnNcbiAgICovZ2VuZXJhdGVUcmFja0V2ZW50KGV2ZW50LHByb3BlcnRpZXMsb3B0aW9ucyl7Y29uc3QgdHJhY2tFdmVudD17cHJvcGVydGllcyxldmVudCx0eXBlOid0cmFjayd9O3JldHVybiBnZXRFbnJpY2hlZEV2ZW50KHRyYWNrRXZlbnQsb3B0aW9ucyx1bmRlZmluZWQsdGhpcy5sb2dnZXIpO30vKipcbiAgICogR2VuZXJhdGUgYW4gJ2lkZW50aWZ5JyBldmVudCBiYXNlZCBvbiB0aGUgdXNlci1pbnB1dCBmaWVsZHNcbiAgICogQHBhcmFtIHVzZXJJZCBOZXcgdXNlciBJRFxuICAgKiBAcGFyYW0gdHJhaXRzIG5ldyB0cmFpdHNcbiAgICogQHBhcmFtIG9wdGlvbnMgQVBJIG9wdGlvbnNcbiAgICovZ2VuZXJhdGVJZGVudGlmeUV2ZW50KHVzZXJJZCx0cmFpdHMsb3B0aW9ucyl7Y29uc3QgaWRlbnRpZnlFdmVudD17dXNlcklkLHR5cGU6J2lkZW50aWZ5Jyxjb250ZXh0Ont0cmFpdHN9fTtyZXR1cm4gZ2V0RW5yaWNoZWRFdmVudChpZGVudGlmeUV2ZW50LG9wdGlvbnMsdW5kZWZpbmVkLHRoaXMubG9nZ2VyKTt9LyoqXG4gICAqIEdlbmVyYXRlIGFuICdhbGlhcycgZXZlbnQgYmFzZWQgb24gdGhlIHVzZXItaW5wdXQgZmllbGRzXG4gICAqIEBwYXJhbSB0byBOZXcgdXNlciBJRFxuICAgKiBAcGFyYW0gZnJvbSBPbGQgdXNlciBJRFxuICAgKiBAcGFyYW0gb3B0aW9ucyBBUEkgb3B0aW9uc1xuICAgKi9nZW5lcmF0ZUFsaWFzRXZlbnQodG8sZnJvbSxvcHRpb25zKXtjb25zdCBhbGlhc0V2ZW50PXtwcmV2aW91c0lkOmZyb20sdHlwZTonYWxpYXMnfTtjb25zdCBlbnJpY2hlZEV2ZW50PWdldEVucmljaGVkRXZlbnQoYWxpYXNFdmVudCxvcHRpb25zLHVuZGVmaW5lZCx0aGlzLmxvZ2dlcik7Ly8gb3ZlcnJpZGUgdGhlIFVzZXIgSUQgZnJvbSB0aGUgQVBJIGlucHV0c1xuZW5yaWNoZWRFdmVudC51c2VySWQ9dG8/P2VucmljaGVkRXZlbnQudXNlcklkO3JldHVybiBlbnJpY2hlZEV2ZW50O30vKipcbiAgICogR2VuZXJhdGUgYSAnZ3JvdXAnIGV2ZW50IGJhc2VkIG9uIHRoZSB1c2VyLWlucHV0IGZpZWxkc1xuICAgKiBAcGFyYW0gZ3JvdXBJZCBOZXcgZ3JvdXAgSURcbiAgICogQHBhcmFtIHRyYWl0cyBuZXcgZ3JvdXAgdHJhaXRzXG4gICAqIEBwYXJhbSBvcHRpb25zIEFQSSBvcHRpb25zXG4gICAqL2dlbmVyYXRlR3JvdXBFdmVudChncm91cElkLHRyYWl0cyxvcHRpb25zKXtjb25zdCBncm91cEV2ZW50PXt0eXBlOidncm91cCd9O2lmKGdyb3VwSWQpe2dyb3VwRXZlbnQuZ3JvdXBJZD1ncm91cElkO31pZih0cmFpdHMpe2dyb3VwRXZlbnQudHJhaXRzPXRyYWl0czt9cmV0dXJuIGdldEVucmljaGVkRXZlbnQoZ3JvdXBFdmVudCxvcHRpb25zLHVuZGVmaW5lZCx0aGlzLmxvZ2dlcik7fS8qKlxuICAgKiBHZW5lcmF0ZXMgYSBuZXcgUnVkZGVyRXZlbnQgb2JqZWN0IGJhc2VkIG9uIHRoZSB1c2VyLWlucHV0IGZpZWxkc1xuICAgKiBAcGFyYW0gZXZlbnQgQVBJIGV2ZW50IHBhcmFtZXRlcnMgb2JqZWN0XG4gICAqIEByZXR1cm5zIEEgUnVkZGVyRXZlbnQgb2JqZWN0XG4gICAqL2NyZWF0ZShldmVudCl7bGV0IGV2ZW50T2JqO3N3aXRjaChldmVudC50eXBlKXtjYXNlICdwYWdlJzpldmVudE9iaj10aGlzLmdlbmVyYXRlUGFnZUV2ZW50KGV2ZW50LmNhdGVnb3J5LGV2ZW50Lm5hbWUsZXZlbnQucHJvcGVydGllcyxldmVudC5vcHRpb25zKTticmVhaztjYXNlICd0cmFjayc6ZXZlbnRPYmo9dGhpcy5nZW5lcmF0ZVRyYWNrRXZlbnQoZXZlbnQubmFtZSxldmVudC5wcm9wZXJ0aWVzLGV2ZW50Lm9wdGlvbnMpO2JyZWFrO2Nhc2UgJ2lkZW50aWZ5JzpldmVudE9iaj10aGlzLmdlbmVyYXRlSWRlbnRpZnlFdmVudChldmVudC51c2VySWQsZXZlbnQudHJhaXRzLGV2ZW50Lm9wdGlvbnMpO2JyZWFrO2Nhc2UgJ2FsaWFzJzpldmVudE9iaj10aGlzLmdlbmVyYXRlQWxpYXNFdmVudChldmVudC50byxldmVudC5mcm9tLGV2ZW50Lm9wdGlvbnMpO2JyZWFrO2Nhc2UgJ2dyb3VwJzpkZWZhdWx0OmV2ZW50T2JqPXRoaXMuZ2VuZXJhdGVHcm91cEV2ZW50KGV2ZW50Lmdyb3VwSWQsZXZlbnQudHJhaXRzLGV2ZW50Lm9wdGlvbnMpO2JyZWFrO31yZXR1cm4gZXZlbnRPYmo7fX1cblxuLyoqXG4gKiBBIHNlcnZpY2UgdG8gZ2VuZXJhdGUgdmFsaWQgZXZlbnQgcGF5bG9hZHMgYW5kIHF1ZXVlIHRoZW0gZm9yIHByb2Nlc3NpbmdcbiAqL2NsYXNzIEV2ZW50TWFuYWdlcnsvKipcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50UmVwb3NpdG9yeSBFdmVudCByZXBvc2l0b3J5IGluc3RhbmNlXG4gICAqIEBwYXJhbSB1c2VyU2Vzc2lvbk1hbmFnZXIgVXNlclNlc3Npb24gTWFuYWdlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0gZXJyb3JIYW5kbGVyIEVycm9yIGhhbmRsZXIgb2JqZWN0XG4gICAqIEBwYXJhbSBsb2dnZXIgTG9nZ2VyIG9iamVjdFxuICAgKi9jb25zdHJ1Y3RvcihldmVudFJlcG9zaXRvcnksdXNlclNlc3Npb25NYW5hZ2VyLGVycm9ySGFuZGxlcixsb2dnZXIpe3RoaXMuZXZlbnRSZXBvc2l0b3J5PWV2ZW50UmVwb3NpdG9yeTt0aGlzLnVzZXJTZXNzaW9uTWFuYWdlcj11c2VyU2Vzc2lvbk1hbmFnZXI7dGhpcy5lcnJvckhhbmRsZXI9ZXJyb3JIYW5kbGVyO3RoaXMubG9nZ2VyPWxvZ2dlcjt0aGlzLmV2ZW50RmFjdG9yeT1uZXcgUnVkZGVyRXZlbnRGYWN0b3J5KHRoaXMubG9nZ2VyKTt9LyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBldmVudCBtYW5hZ2VyXG4gICAqL2luaXQoKXt0aGlzLmV2ZW50UmVwb3NpdG9yeS5pbml0KCk7fXJlc3VtZSgpe3RoaXMuZXZlbnRSZXBvc2l0b3J5LnJlc3VtZSgpO30vKipcbiAgICogQ29uc3VtZXMgYSBuZXcgaW5jb21pbmcgZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50IEluY29taW5nIGV2ZW50IGRhdGFcbiAgICovYWRkRXZlbnQoZXZlbnQpe3RoaXMudXNlclNlc3Npb25NYW5hZ2VyLnJlZnJlc2hTZXNzaW9uKCk7Y29uc3QgcnVkZGVyRXZlbnQ9dGhpcy5ldmVudEZhY3RvcnkuY3JlYXRlKGV2ZW50KTt0aGlzLmV2ZW50UmVwb3NpdG9yeS5lbnF1ZXVlKHJ1ZGRlckV2ZW50LGV2ZW50LmNhbGxiYWNrKTt9fVxuXG5jbGFzcyBVc2VyU2Vzc2lvbk1hbmFnZXJ7LyoqXG4gICAqIFRyYWNrcyB3aGV0aGVyIGEgc2VydmVyLXNpZGUgY29va2llIHNldHRpbmcgcmVxdWVzdCBpcyBpbiBwcm9ncmVzcyBvciBub3QuXG4gICAqL2NvbnN0cnVjdG9yKHBsdWdpbnNNYW5hZ2VyLHN0b3JlTWFuYWdlcixodHRwQ2xpZW50LGVycm9ySGFuZGxlcixsb2dnZXIpe3RoaXMuc3RvcmVNYW5hZ2VyPXN0b3JlTWFuYWdlcjt0aGlzLnBsdWdpbnNNYW5hZ2VyPXBsdWdpbnNNYW5hZ2VyO3RoaXMubG9nZ2VyPWxvZ2dlcjt0aGlzLmVycm9ySGFuZGxlcj1lcnJvckhhbmRsZXI7dGhpcy5odHRwQ2xpZW50PWh0dHBDbGllbnQ7dGhpcy5vbkVycm9yPXRoaXMub25FcnJvci5iaW5kKHRoaXMpO3RoaXMuc2VydmVyU2lkZUNvb2tpZURlYm91bmNlRnVuY3M9e307dGhpcy5zZXJ2ZXJTaWRlQ29va2llc1JlcXVlc3RJblByb2dyZXNzPXt9O30vKipcbiAgICogSW5pdGlhbGl6ZSBVc2VyIHNlc3Npb24gd2l0aCB2YWx1ZXMgZnJvbSBzdG9yYWdlXG4gICAqL2luaXQoKXt0aGlzLnN5bmNTdG9yYWdlRGF0YVRvU3RhdGUoKTsvLyBSZWdpc3RlciB0aGUgZWZmZWN0IHRvIHN5bmMgd2l0aCBzdG9yYWdlXG50aGlzLnJlZ2lzdGVyRWZmZWN0cygpO31zeW5jU3RvcmFnZURhdGFUb1N0YXRlKCl7dGhpcy5taWdyYXRlU3RvcmFnZUlmTmVlZGVkKCk7dGhpcy5taWdyYXRlRGF0YUZyb21QcmV2aW91c1N0b3JhZ2UoKTsvLyBnZXQgdGhlIHZhbHVlcyBmcm9tIHN0b3JhZ2UgYW5kIHNldCBpdCBhZ2FpblxudGhpcy5zZXRVc2VySWQodGhpcy5nZXRVc2VySWQoKSk7dGhpcy5zZXRVc2VyVHJhaXRzKHRoaXMuZ2V0VXNlclRyYWl0cygpKTt0aGlzLnNldEdyb3VwSWQodGhpcy5nZXRHcm91cElkKCkpO3RoaXMuc2V0R3JvdXBUcmFpdHModGhpcy5nZXRHcm91cFRyYWl0cygpKTtjb25zdHtleHRlcm5hbEFub255bW91c0lkQ29va2llTmFtZSxhbm9ueW1vdXNJZE9wdGlvbnN9PXN0YXRlLmxvYWRPcHRpb25zLnZhbHVlO2xldCBleHRlcm5hbEFub255bW91c0lkO2lmKGlzRGVmaW5lZEFuZE5vdE51bGwoZXh0ZXJuYWxBbm9ueW1vdXNJZENvb2tpZU5hbWUpJiZ0eXBlb2YgZXh0ZXJuYWxBbm9ueW1vdXNJZENvb2tpZU5hbWU9PT0nc3RyaW5nJyl7ZXh0ZXJuYWxBbm9ueW1vdXNJZD10aGlzLmdldEV4dGVybmFsQW5vbnltb3VzSWRCeUNvb2tpZU5hbWUoZXh0ZXJuYWxBbm9ueW1vdXNJZENvb2tpZU5hbWUpO310aGlzLnNldEFub255bW91c0lkKGV4dGVybmFsQW5vbnltb3VzSWQ/P3RoaXMuZ2V0QW5vbnltb3VzSWQoYW5vbnltb3VzSWRPcHRpb25zKSk7dGhpcy5zZXRBdXRoVG9rZW4odGhpcy5nZXRBdXRoVG9rZW4oKSk7dGhpcy5zZXRJbml0aWFsUmVmZXJyZXJJbmZvKCk7dGhpcy5jb25maWd1cmVTZXNzaW9uVHJhY2tpbmcoKTt9Y29uZmlndXJlU2Vzc2lvblRyYWNraW5nKCl7bGV0IHNlc3Npb25JbmZvO2lmKHRoaXMuaXNQZXJzaXN0ZW5jZUVuYWJsZWRGb3JTdG9yYWdlRW50cnkoJ3Nlc3Npb25JbmZvJykpe2NvbnN0IGNvbmZpZ3VyZWRTZXNzaW9uVHJhY2tpbmdJbmZvPXRoaXMuZ2V0Q29uZmlndXJlZFNlc3Npb25UcmFja2luZ0luZm8oKTtjb25zdCBpbml0aWFsU2Vzc2lvbkluZm89dGhpcy5nZXRTZXNzaW9uSW5mbygpPz9ERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVMuc2Vzc2lvbkluZm87Ly8gTWVyZ2UgdGhlIHNlc3Npb24gaW5mbyBmcm9tIHRoZSBzdG9yYWdlIGFuZCB0aGUgY29uZmlndXJhdGlvblxuc2Vzc2lvbkluZm89ey8vIElmIG1hbnVhbFRyYWNrIGlzIHNldCB0byB0cnVlIGluIHRoZSBzdG9yYWdlLCB0aGVuIGRvIG5vdCBlbmFibGUgYXV0byB0cmFja2luZyBldmVuIGlmIGNvbmZpZ3VyZWQuXG4vLyBPbmNlIG1hbnVhbCB0cmFja2luZyBlbmRzIChlbmRTZXNzaW9uIGlzIGNhbGxlZCksIGF1dG8gdHJhY2tpbmcgd2lsbCBiZSBlbmFibGVkIGluIHRoZSBuZXh0IFNESyBydW4uXG5hdXRvVHJhY2s6Y29uZmlndXJlZFNlc3Npb25UcmFja2luZ0luZm8uYXV0b1RyYWNrJiZpbml0aWFsU2Vzc2lvbkluZm8ubWFudWFsVHJhY2shPT10cnVlLHRpbWVvdXQ6Y29uZmlndXJlZFNlc3Npb25UcmFja2luZ0luZm8udGltZW91dCxtYW51YWxUcmFjazppbml0aWFsU2Vzc2lvbkluZm8ubWFudWFsVHJhY2ssZXhwaXJlc0F0OmluaXRpYWxTZXNzaW9uSW5mby5leHBpcmVzQXQsaWQ6aW5pdGlhbFNlc3Npb25JbmZvLmlkLHNlc3Npb25TdGFydDppbml0aWFsU2Vzc2lvbkluZm8uc2Vzc2lvblN0YXJ0fTsvLyBJZiBib3RoIGF1dG9UcmFjayBhbmQgbWFudWFsVHJhY2sgYXJlIGRpc2FibGVkLCByZXNldCB0aGUgc2Vzc2lvbiBpbmZvIHRvIGRlZmF1bHQgdmFsdWVzXG5pZighc2Vzc2lvbkluZm8uYXV0b1RyYWNrJiZzZXNzaW9uSW5mby5tYW51YWxUcmFjayE9PXRydWUpe3Nlc3Npb25JbmZvPURFRkFVTFRfVVNFUl9TRVNTSU9OX1ZBTFVFUy5zZXNzaW9uSW5mbzt9ZWxzZSBpZihjb25maWd1cmVkU2Vzc2lvblRyYWNraW5nSW5mby5jdXRPZmY/LmVuYWJsZWQ9PT10cnVlKXtzZXNzaW9uSW5mby5jdXRPZmY9e2VuYWJsZWQ6dHJ1ZSxkdXJhdGlvbjpjb25maWd1cmVkU2Vzc2lvblRyYWNraW5nSW5mby5jdXRPZmYuZHVyYXRpb24sZXhwaXJlc0F0OmluaXRpYWxTZXNzaW9uSW5mby5jdXRPZmY/LmV4cGlyZXNBdH07fX1lbHNlIHtzZXNzaW9uSW5mbz1ERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVMuc2Vzc2lvbkluZm87fXN0YXRlLnNlc3Npb24uc2Vzc2lvbkluZm8udmFsdWU9c2Vzc2lvbkluZm87Ly8gSWYgYXV0byBzZXNzaW9uIHRyYWNraW5nIGlzIGVuYWJsZWQgc3RhcnQgdGhlIHNlc3Npb24gdHJhY2tpbmdcbmlmKHN0YXRlLnNlc3Npb24uc2Vzc2lvbkluZm8udmFsdWUuYXV0b1RyYWNrKXt0aGlzLnN0YXJ0T3JSZW5ld0F1dG9UcmFja2luZyhzdGF0ZS5zZXNzaW9uLnNlc3Npb25JbmZvLnZhbHVlKTt9fXNldEluaXRpYWxSZWZlcnJlckluZm8oKXtjb25zdCBwZXJzaXN0ZWRJbml0aWFsUmVmZXJyZXI9dGhpcy5nZXRJbml0aWFsUmVmZXJyZXIoKTtjb25zdCBwZXJzaXN0ZWRJbml0aWFsUmVmZXJyaW5nRG9tYWluPXRoaXMuZ2V0SW5pdGlhbFJlZmVycmluZ0RvbWFpbigpO2lmKHBlcnNpc3RlZEluaXRpYWxSZWZlcnJlciYmcGVyc2lzdGVkSW5pdGlhbFJlZmVycmluZ0RvbWFpbil7dGhpcy5zZXRJbml0aWFsUmVmZXJyZXIocGVyc2lzdGVkSW5pdGlhbFJlZmVycmVyKTt0aGlzLnNldEluaXRpYWxSZWZlcnJpbmdEb21haW4ocGVyc2lzdGVkSW5pdGlhbFJlZmVycmluZ0RvbWFpbik7fWVsc2Uge2NvbnN0IGluaXRpYWxSZWZlcnJlcj1wZXJzaXN0ZWRJbml0aWFsUmVmZXJyZXJ8fGdldFJlZmVycmVyKCk7dGhpcy5zZXRJbml0aWFsUmVmZXJyZXIoaW5pdGlhbFJlZmVycmVyKTt0aGlzLnNldEluaXRpYWxSZWZlcnJpbmdEb21haW4oZ2V0UmVmZXJyaW5nRG9tYWluKGluaXRpYWxSZWZlcnJlcikpO319aXNQZXJzaXN0ZW5jZUVuYWJsZWRGb3JTdG9yYWdlRW50cnkoZW50cnlOYW1lKXtyZXR1cm4gaXNTdG9yYWdlVHlwZVZhbGlkRm9yU3RvcmluZ0RhdGEoc3RhdGUuc3RvcmFnZS5lbnRyaWVzLnZhbHVlW2VudHJ5TmFtZV0/LnR5cGUpO31taWdyYXRlRGF0YUZyb21QcmV2aW91c1N0b3JhZ2UoKXtjb25zdCBlbnRyaWVzPXN0YXRlLnN0b3JhZ2UuZW50cmllcy52YWx1ZTtjb25zdCBzdG9yYWdlVHlwZXNGb3JNaWdyYXRpb249W0NPT0tJRV9TVE9SQUdFLExPQ0FMX1NUT1JBR0UsU0VTU0lPTl9TVE9SQUdFXTtPYmplY3Qua2V5cyhlbnRyaWVzKS5mb3JFYWNoKGVudHJ5PT57Y29uc3Qga2V5PWVudHJ5O2NvbnN0IGN1cnJlbnRTdG9yYWdlPWVudHJpZXNba2V5XT8udHlwZTtjb25zdCBjdXJTdG9yZT10aGlzLnN0b3JlTWFuYWdlcj8uZ2V0U3RvcmUoc3RvcmFnZUNsaWVudERhdGFTdG9yZU5hbWVNYXBbY3VycmVudFN0b3JhZ2VdKTtpZihjdXJTdG9yZSl7c3RvcmFnZVR5cGVzRm9yTWlncmF0aW9uLmZvckVhY2goc3RvcmFnZT0+e2NvbnN0IHN0b3JlPXRoaXMuc3RvcmVNYW5hZ2VyPy5nZXRTdG9yZShzdG9yYWdlQ2xpZW50RGF0YVN0b3JlTmFtZU1hcFtzdG9yYWdlXSk7aWYoc3RvcmUmJnN0b3JhZ2UhPT1jdXJyZW50U3RvcmFnZSl7Y29uc3QgdmFsdWU9c3RvcmUuZ2V0KENPT0tJRV9LRVlTW2tleV0pO2lmKGlzRGVmaW5lZE5vdE51bGxBbmROb3RFbXB0eVN0cmluZyh2YWx1ZSkpe2N1clN0b3JlLnNldChDT09LSUVfS0VZU1trZXldLHZhbHVlKTt9c3RvcmUucmVtb3ZlKENPT0tJRV9LRVlTW2tleV0pO319KTt9fSk7fW1pZ3JhdGVTdG9yYWdlSWZOZWVkZWQoc3RvcmVzLGtleXMpe2lmKCFzdGF0ZS5zdG9yYWdlLm1pZ3JhdGUudmFsdWUpe3JldHVybjt9bGV0IHN0b3Jlc1RvTWlncmF0ZT1zdG9yZXM/P1tdO2lmKHN0b3Jlc1RvTWlncmF0ZS5sZW5ndGg9PT0wKXtjb25zdCBwZXJzaXN0ZW50U3RvcmVOYW1lcz1bQ0xJRU5UX0RBVEFfU1RPUkVfQ09PS0lFLENMSUVOVF9EQVRBX1NUT1JFX0xTLENMSUVOVF9EQVRBX1NUT1JFX1NFU1NJT05dO3BlcnNpc3RlbnRTdG9yZU5hbWVzLmZvckVhY2goc3RvcmVOYW1lPT57Y29uc3Qgc3RvcmU9dGhpcy5zdG9yZU1hbmFnZXI/LmdldFN0b3JlKHN0b3JlTmFtZSk7aWYoc3RvcmUpe3N0b3Jlc1RvTWlncmF0ZS5wdXNoKHN0b3JlKTt9fSk7fWxldCBrZXlzVG9NaWdyYXRlPWtleXM/P09iamVjdC5rZXlzKENPT0tJRV9LRVlTKTtrZXlzVG9NaWdyYXRlLmZvckVhY2goc3RvcmFnZUtleT0+e2NvbnN0IHN0b3JhZ2VFbnRyeT1DT09LSUVfS0VZU1tzdG9yYWdlS2V5XTtzdG9yZXNUb01pZ3JhdGUuZm9yRWFjaChzdG9yZT0+e2NvbnN0IG1pZ3JhdGVkVmFsPXRoaXMucGx1Z2luc01hbmFnZXI/Lmludm9rZVNpbmdsZSgnc3RvcmFnZS5taWdyYXRlJyxzdG9yYWdlRW50cnksc3RvcmUuZW5naW5lLHRoaXMuZXJyb3JIYW5kbGVyLHRoaXMubG9nZ2VyKTsvLyBTa2lwIHNldHRpbmcgdGhlIHZhbHVlIGlmIGl0IGlzIG51bGwgb3IgdW5kZWZpbmVkXG4vLyBhcyB0aG9zZSB2YWx1ZXMgaW5kaWNhdGUgdGhlcmUgaXMgbm8gbmVlZCBmb3IgbWlncmF0aW9uIG9yXG4vLyBtaWdyYXRpb24gZmFpbGVkXG5pZighaXNOdWxsT3JVbmRlZmluZWQobWlncmF0ZWRWYWwpKXtzdG9yZS5zZXQoc3RvcmFnZUVudHJ5LG1pZ3JhdGVkVmFsKTt9fSk7fSk7fWdldENvbmZpZ3VyZWRTZXNzaW9uVHJhY2tpbmdJbmZvKCl7bGV0IGF1dG9UcmFjaz1zdGF0ZS5sb2FkT3B0aW9ucy52YWx1ZS5zZXNzaW9ucy5hdXRvVHJhY2shPT1mYWxzZTsvLyBEbyBub3QgdmFsaWRhdGUgYW55IGZ1cnRoZXIgaWYgYXV0b1RyYWNrIGlzIGRpc2FibGVkXG5pZighYXV0b1RyYWNrKXtyZXR1cm4ge2F1dG9UcmFja307fWxldCB0aW1lb3V0O2NvbnN0IGNvbmZpZ3VyZWRTZXNzaW9uVGltZW91dD1zdGF0ZS5sb2FkT3B0aW9ucy52YWx1ZS5zZXNzaW9ucz8udGltZW91dDtpZighaXNQb3NpdGl2ZUludGVnZXIoY29uZmlndXJlZFNlc3Npb25UaW1lb3V0KSl7dGhpcy5sb2dnZXIud2FybihUSU1FT1VUX05PVF9OVU1CRVJfV0FSTklORyhVU0VSX1NFU1NJT05fTUFOQUdFUixjb25maWd1cmVkU2Vzc2lvblRpbWVvdXQsREVGQVVMVF9TRVNTSU9OX1RJTUVPVVRfTVMpKTt0aW1lb3V0PURFRkFVTFRfU0VTU0lPTl9USU1FT1VUX01TO31lbHNlIHt0aW1lb3V0PWNvbmZpZ3VyZWRTZXNzaW9uVGltZW91dDt9aWYodGltZW91dD09PTApe3RoaXMubG9nZ2VyLndhcm4oVElNRU9VVF9aRVJPX1dBUk5JTkcoVVNFUl9TRVNTSU9OX01BTkFHRVIpKTthdXRvVHJhY2s9ZmFsc2U7fS8vIEluIGNhc2UgdXNlciBwcm92aWRlcyBhIHRpbWVvdXQgdmFsdWUgZ3JlYXRlciB0aGFuIDAgYnV0IGxlc3MgdGhhbiAxMCBzZWNvbmRzIFNESyB3aWxsIHNob3cgYSB3YXJuaW5nXG4vLyBhbmQgd2lsbCBwcm9jZWVkIHdpdGggaXRcbmlmKHRpbWVvdXQ+MCYmdGltZW91dDxNSU5fU0VTU0lPTl9USU1FT1VUX01TKXt0aGlzLmxvZ2dlci53YXJuKFRJTUVPVVRfTk9UX1JFQ09NTUVOREVEX1dBUk5JTkcoVVNFUl9TRVNTSU9OX01BTkFHRVIsdGltZW91dCxNSU5fU0VTU0lPTl9USU1FT1VUX01TKSk7fWNvbnN0IGN1dE9mZj10aGlzLmdldEN1dE9mZkluZm8odGltZW91dCk7cmV0dXJuIHt0aW1lb3V0LGF1dG9UcmFjayxjdXRPZmZ9O31nZXRDdXRPZmZJbmZvKHNlc3Npb25UaW1lb3V0KXtjb25zdCBjdXRPZmY9c3RhdGUubG9hZE9wdGlvbnMudmFsdWUuc2Vzc2lvbnMuY3V0T2ZmO2xldCBjdXRPZmZEdXJhdGlvbjtsZXQgY3V0T2ZmRW5hYmxlZD1mYWxzZTtpZihjdXRPZmYuZW5hYmxlZD09PXRydWUpe2N1dE9mZkR1cmF0aW9uPWN1dE9mZi5kdXJhdGlvbjtjdXRPZmZFbmFibGVkPXRydWU7aWYoIWlzUG9zaXRpdmVJbnRlZ2VyKGN1dE9mZkR1cmF0aW9uKSl7dGhpcy5sb2dnZXIud2FybihDVVRfT0ZGX0RVUkFUSU9OX05PVF9OVU1CRVJfV0FSTklORyhVU0VSX1NFU1NJT05fTUFOQUdFUixjdXRPZmZEdXJhdGlvbixERUZBVUxUX1NFU1NJT05fQ1VUX09GRl9EVVJBVElPTl9NUykpOy8vIFVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgY3V0IG9mZiBkdXJhdGlvblxuY3V0T2ZmRHVyYXRpb249REVGQVVMVF9TRVNTSU9OX0NVVF9PRkZfRFVSQVRJT05fTVM7fWVsc2UgaWYoY3V0T2ZmRHVyYXRpb248c2Vzc2lvblRpbWVvdXQpe3RoaXMubG9nZ2VyLndhcm4oQ1VUX09GRl9EVVJBVElPTl9MRVNTX1RIQU5fVElNRU9VVF9XQVJOSU5HKFVTRVJfU0VTU0lPTl9NQU5BR0VSLGN1dE9mZkR1cmF0aW9uLHNlc3Npb25UaW1lb3V0KSk7Y3V0T2ZmRW5hYmxlZD1mYWxzZTt9fXJldHVybiB7ZW5hYmxlZDpjdXRPZmZFbmFibGVkLGR1cmF0aW9uOmN1dE9mZkR1cmF0aW9ufTt9LyoqXG4gICAqIEhhbmRsZXMgZXJyb3JcbiAgICogQHBhcmFtIGVycm9yIFRoZSBlcnJvciBvYmplY3RcbiAgICovb25FcnJvcihlcnJvcixjdXN0b21NZXNzYWdlLGdyb3VwaW5nSGFzaCl7dGhpcy5lcnJvckhhbmRsZXIub25FcnJvcih7ZXJyb3IsY29udGV4dDpVU0VSX1NFU1NJT05fTUFOQUdFUixjdXN0b21NZXNzYWdlLGdyb3VwaW5nSGFzaH0pO30vKipcbiAgICogQSBmdW5jdGlvbiB0byBlbmNyeXB0IHRoZSBjb29raWUgdmFsdWUgYW5kIHJldHVybiB0aGUgZW5jcnlwdGVkIGRhdGFcbiAgICogQHBhcmFtIGNvb2tpZXNEYXRhXG4gICAqIEBwYXJhbSBzdG9yZVxuICAgKiBAcmV0dXJuc1xuICAgKi9nZXRFbmNyeXB0ZWRDb29raWVEYXRhKGNvb2tpZXNEYXRhLHN0b3JlKXtjb25zdCBlbmNyeXB0ZWRDb29raWVEYXRhPVtdO2Nvb2tpZXNEYXRhLmZvckVhY2goY0RhdGE9Pntjb25zdCBlbmNyeXB0ZWRWYWx1ZT1zdG9yZT8uZW5jcnlwdChzdHJpbmdpZnlXaXRob3V0Q2lyY3VsYXIoY0RhdGEudmFsdWUsZmFsc2UsW10sdGhpcy5sb2dnZXIpKTtpZihpc0RlZmluZWRBbmROb3ROdWxsKGVuY3J5cHRlZFZhbHVlKSl7ZW5jcnlwdGVkQ29va2llRGF0YS5wdXNoKHtuYW1lOmNEYXRhLm5hbWUsdmFsdWU6ZW5jcnlwdGVkVmFsdWV9KTt9fSk7cmV0dXJuIGVuY3J5cHRlZENvb2tpZURhdGE7fS8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgbWFrZXMgcmVxdWVzdCB0byBkYXRhIHNlcnZpY2UgdG8gc2V0IHRoZSBjb29raWVcbiAgICogQHBhcmFtIGVuY3J5cHRlZENvb2tpZURhdGFcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL21ha2VSZXF1ZXN0VG9TZXRDb29raWUoZW5jcnlwdGVkQ29va2llRGF0YSxjYWxsYmFjayl7dGhpcy5odHRwQ2xpZW50Py5nZXRBc3luY0RhdGEoe3VybDpzdGF0ZS5zZXJ2ZXJDb29raWVzLmRhdGFTZXJ2aWNlVXJsLnZhbHVlLG9wdGlvbnM6e21ldGhvZDonUE9TVCcsZGF0YTpzdHJpbmdpZnlXaXRob3V0Q2lyY3VsYXIoe3JlcVR5cGU6J3NldENvb2tpZXMnLHdvcmtzcGFjZUlkOnN0YXRlLnNvdXJjZS52YWx1ZT8ud29ya3NwYWNlSWQsZGF0YTp7b3B0aW9uczp7bWF4QWdlOnN0YXRlLnN0b3JhZ2UuY29va2llLnZhbHVlPy5tYXhhZ2UscGF0aDpzdGF0ZS5zdG9yYWdlLmNvb2tpZS52YWx1ZT8ucGF0aCxkb21haW46c3RhdGUuc3RvcmFnZS5jb29raWUudmFsdWU/LmRvbWFpbixzYW1lU2l0ZTpzdGF0ZS5zdG9yYWdlLmNvb2tpZS52YWx1ZT8uc2FtZXNpdGUsc2VjdXJlOnN0YXRlLnN0b3JhZ2UuY29va2llLnZhbHVlPy5zZWN1cmUsZXhwaXJlczpzdGF0ZS5zdG9yYWdlLmNvb2tpZS52YWx1ZT8uZXhwaXJlc30sY29va2llczplbmNyeXB0ZWRDb29raWVEYXRhfX0pLHNlbmRSYXdEYXRhOnRydWUsd2l0aENyZWRlbnRpYWxzOnRydWV9LGlzUmF3UmVzcG9uc2U6dHJ1ZSxjYWxsYmFja30pO30vKipcbiAgICogQSBmdW5jdGlvbiB0byBtYWtlIGFuIGV4dGVybmFsIHJlcXVlc3QgdG8gc2V0IHRoZSBjb29raWUgZnJvbSBzZXJ2ZXIgc2lkZVxuICAgKiBAcGFyYW0gc2Vzc2lvblRvQ29va2llc01hcCBtYXAgb2Ygc2Vzc2lvbiBrZXkgdG8gY29va2llIG5hbWVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBjb29raWUgaXMgc2V0XG4gICAqIEBwYXJhbSBzdG9yZSBzdG9yZSB0byBiZSB1c2VkIHRvIGdldCB0aGUgY29va2llIHZhbHVlXG4gICAqL3NldFNlcnZlclNpZGVDb29raWVzKHNlc3Npb25Ub0Nvb2tpZXNNYXAsY2Isc3RvcmUpey8vIFJldHJpZXZlIHRoZSBjb29raWUgdmFsdWUgZnJvbSB0aGUgc3RhdGVcbmNvbnN0IHNlc3Npb25LZXlzPU9iamVjdC5rZXlzKHNlc3Npb25Ub0Nvb2tpZXNNYXApO2NvbnN0IGdldEN1cnJlbnRDb29raWVWYWx1ZXNGcm9tU3RhdGU9KCk9PntyZXR1cm4gc2Vzc2lvbktleXMubWFwKHNlc3Npb25LZXk9PntyZXR1cm4ge25hbWU6c2Vzc2lvblRvQ29va2llc01hcFtzZXNzaW9uS2V5XS5uYW1lLHZhbHVlOnN0YXRlLnNlc3Npb25bc2Vzc2lvbktleV0udmFsdWV9O30pO307Ly8gUHJlc2VydmUgdGhlIGN1cnJlbnQgY29va2llIHZhbHVlc1xuY29uc3Qgb3JpZ2luYWxDb29raWVWYWx1ZXM9e307c2Vzc2lvbktleXMuZm9yRWFjaChzZXNzaW9uS2V5PT57b3JpZ2luYWxDb29raWVWYWx1ZXNbc2Vzc2lvblRvQ29va2llc01hcFtzZXNzaW9uS2V5XS5uYW1lXT1zdG9yZT8uZ2V0KHNlc3Npb25Ub0Nvb2tpZXNNYXBbc2Vzc2lvbktleV0ubmFtZSk7fSk7Y29uc3QgY2xlYXJJblByb2dyZXNzRmxhZ3M9KCk9PntzZXNzaW9uS2V5cy5mb3JFYWNoKHNlc3Npb25LZXk9Pnt0aGlzLnNlcnZlclNpZGVDb29raWVzUmVxdWVzdEluUHJvZ3Jlc3Nbc2Vzc2lvbktleV09ZmFsc2U7fSk7fTtjb25zdCBzZXRDb29raWVzQ2xpZW50U2lkZT0oKT0+e2dldEN1cnJlbnRDb29raWVWYWx1ZXNGcm9tU3RhdGUoKS5mb3JFYWNoKGVhY2g9PntpZihjYil7Y2IoZWFjaC5uYW1lLGVhY2gudmFsdWUpO319KTt9O3RyeXtjb25zdCBleHBlY3RlZENvb2tpZVZhbHVlcz17fTtzZXNzaW9uS2V5cy5mb3JFYWNoKHNlc3Npb25LZXk9PntleHBlY3RlZENvb2tpZVZhbHVlc1tzZXNzaW9uVG9Db29raWVzTWFwW3Nlc3Npb25LZXldLm5hbWVdPXN0YXRlLnNlc3Npb25bc2Vzc2lvbktleV0udmFsdWU7fSk7Ly8gZW5jcnlwdCBjb29raWVzIHZhbHVlc1xuY29uc3QgZW5jcnlwdGVkQ29va2llRGF0YT10aGlzLmdldEVuY3J5cHRlZENvb2tpZURhdGEoZ2V0Q3VycmVudENvb2tpZVZhbHVlc0Zyb21TdGF0ZSgpLHN0b3JlKTtpZihlbmNyeXB0ZWRDb29raWVEYXRhLmxlbmd0aD4wKXsvLyBtYWtlIHJlcXVlc3QgdG8gZGF0YSBzZXJ2aWNlIHRvIHNldCB0aGUgY29va2llIGZyb20gc2VydmVyIHNpZGVcbnRoaXMubWFrZVJlcXVlc3RUb1NldENvb2tpZShlbmNyeXB0ZWRDb29raWVEYXRhLChyZXMsZGV0YWlscyk9PnsvLyBNYXJrIHRoZSBjb29raWUgcmVxIHN0YXR1cyBhcyBkb25lXG5jbGVhckluUHJvZ3Jlc3NGbGFncygpO2lmKGRldGFpbHM/Lnhocj8uc3RhdHVzPT09MjAwKXtnZXRDdXJyZW50Q29va2llVmFsdWVzRnJvbVN0YXRlKCkuZm9yRWFjaChjRGF0YT0+e2NvbnN0IG9yaWdpbmFsQ29va2llVmFsPW9yaWdpbmFsQ29va2llVmFsdWVzW2NEYXRhLm5hbWVdO2NvbnN0IGN1cnJlbnRDb29raWVWYWw9c3RvcmU/LmdldChjRGF0YS5uYW1lKTsvLyBDaGVjayBpZiB0aGUgZXhwZWN0ZWQgY29va2llIHZhbHVlcyBhcmUgc2V0LlxuaWYoc3RyaW5naWZ5V2l0aG91dENpcmN1bGFyKGV4cGVjdGVkQ29va2llVmFsdWVzW2NEYXRhLm5hbWVdLGZhbHNlLFtdKSE9PXN0cmluZ2lmeVdpdGhvdXRDaXJjdWxhcihjdXJyZW50Q29va2llVmFsLGZhbHNlLFtdKSl7Ly8gSXQncyBmaW5lIGlmIHRoZSB2YWx1ZXMgZG9uJ3QgbWF0Y2ggYXMgb3RoZXIgYWN0aXZlIFNESyBzZXNzaW9ucyBtaWdodCBoYXZlIHVwZGF0ZWQgdGhlIGNvb2tpZSB2YWx1ZXNcbi8vIG9yIG90aGVyIGNvb2tpZSByZXF1ZXN0cyBtaWdodCBoYXZlIHVwZGF0ZWQgdGhlIGNvb2tpZSB2YWx1ZS5cbi8vIExvZyBhbiBlcnJvciBvbmx5IHdoZW4gY29va2llIGRpZG4ndCBleGlzdCBwcmV2aW91c2x5IGFuZCBjdXJyZW50bHkgYWxzbyBkb2Vzbid0IGV4aXN0LlxuaWYoaXNOdWxsKG9yaWdpbmFsQ29va2llVmFsKSYmaXNOdWxsKGN1cnJlbnRDb29raWVWYWwpKXt0aGlzLmxvZ2dlci5lcnJvcihGQUlMRURfU0VUVElOR19DT09LSUVfRlJPTV9TRVJWRVJfRVJST1IoY0RhdGEubmFtZSkpO31pZihjYil7Y2IoY0RhdGEubmFtZSxjRGF0YS52YWx1ZSk7fX19KTt9ZWxzZSB7dGhpcy5sb2dnZXIuZXJyb3IoREFUQV9TRVJWRVJfUkVRVUVTVF9GQUlMX0VSUk9SKGRldGFpbHM/Lnhocj8uc3RhdHVzKSk7c2V0Q29va2llc0NsaWVudFNpZGUoKTt9fSk7fWVsc2Uge3NldENvb2tpZXNDbGllbnRTaWRlKCk7Ly8gTWFyayB0aGUgY29va2llIHJlcSBzdGF0dXMgYXMgZG9uZVxuY2xlYXJJblByb2dyZXNzRmxhZ3MoKTt9fWNhdGNoKGUpe3RoaXMub25FcnJvcihlLEZBSUxFRF9TRVRUSU5HX0NPT0tJRV9GUk9NX1NFUlZFUl9HTE9CQUxfRVJST1IsRkFJTEVEX1NFVFRJTkdfQ09PS0lFX0ZST01fU0VSVkVSX0dMT0JBTF9FUlJPUik7c2V0Q29va2llc0NsaWVudFNpZGUoKTsvLyBNYXJrIHRoZSBjb29raWUgcmVxIHN0YXR1cyBhcyBkb25lXG5jbGVhckluUHJvZ3Jlc3NGbGFncygpO319LyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gc3luYyB2YWx1ZXMgaW4gc3RvcmFnZVxuICAgKiBAcGFyYW0gc2Vzc2lvbktleVxuICAgKi9zeW5jVmFsdWVUb1N0b3JhZ2Uoc2Vzc2lvbktleSl7Y29uc3QgZW50cmllcz1zdGF0ZS5zdG9yYWdlLmVudHJpZXMudmFsdWU7Y29uc3Qgc3RvcmFnZVR5cGU9ZW50cmllc1tzZXNzaW9uS2V5XT8udHlwZTtpZihpc1N0b3JhZ2VUeXBlVmFsaWRGb3JTdG9yaW5nRGF0YShzdG9yYWdlVHlwZSkpe2NvbnN0IGN1clN0b3JlPXRoaXMuc3RvcmVNYW5hZ2VyLmdldFN0b3JlKHN0b3JhZ2VDbGllbnREYXRhU3RvcmVOYW1lTWFwW3N0b3JhZ2VUeXBlXSk7Y29uc3QgY29va2llTmFtZT1lbnRyaWVzW3Nlc3Npb25LZXldPy5rZXk7Y29uc3QgY29va2llVmFsdWU9c3RhdGUuc2Vzc2lvbltzZXNzaW9uS2V5XS52YWx1ZTtpZihjb29raWVWYWx1ZSYmKGlzU3RyaW5nKGNvb2tpZVZhbHVlKXx8aXNOb25FbXB0eU9iamVjdChjb29raWVWYWx1ZSkpKXsvLyBpZiB1c2VTZXJ2ZXJTaWRlQ29va2llcyBsb2FkIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZVxuLy8gc2V0IHRoZSBjb29raWUgZnJvbSBzZXJ2ZXIgc2lkZVxuaWYoc3RhdGUuc2VydmVyQ29va2llcy5pc0VuYWJsZWRTZXJ2ZXJTaWRlQ29va2llcy52YWx1ZSYmc3RvcmFnZVR5cGU9PT1DT09LSUVfU1RPUkFHRSl7Ly8gTWFyayB0aGUgcmVxdWVzdHMgYXMgaW4gcHJvZ3Jlc3MuXG50aGlzLnNlcnZlclNpZGVDb29raWVzUmVxdWVzdEluUHJvZ3Jlc3Nbc2Vzc2lvbktleV09dHJ1ZTtpZih0aGlzLnNlcnZlclNpZGVDb29raWVEZWJvdW5jZUZ1bmNzW3Nlc3Npb25LZXldKXtnbG9iYWxUaGlzLmNsZWFyVGltZW91dCh0aGlzLnNlcnZlclNpZGVDb29raWVEZWJvdW5jZUZ1bmNzW3Nlc3Npb25LZXldKTt9dGhpcy5zZXJ2ZXJTaWRlQ29va2llRGVib3VuY2VGdW5jc1tzZXNzaW9uS2V5XT1nbG9iYWxUaGlzLnNldFRpbWVvdXQoKCk9PnsvLyBDcmVhdGUgYSBtYXAgb2Ygc2Vzc2lvbiBrZXkgdG8gY29va2llIG5hbWVcbmNvbnN0IHNlc3Npb25Ub0Nvb2tpZXNNYXA9e1tzZXNzaW9uS2V5XTp7bmFtZTpjb29raWVOYW1lfX07dGhpcy5zZXRTZXJ2ZXJTaWRlQ29va2llcyhzZXNzaW9uVG9Db29raWVzTWFwLChjb29raWVOYW1lLGNvb2tpZVZhbHVlKT0+e2N1clN0b3JlPy5zZXQoY29va2llTmFtZSxjb29raWVWYWx1ZSk7fSxjdXJTdG9yZSk7fSxTRVJWRVJfU0lERV9DT09LSUVTX0RFQk9VTkNFX1RJTUUpO31lbHNlIHtjdXJTdG9yZT8uc2V0KGNvb2tpZU5hbWUsY29va2llVmFsdWUpO319ZWxzZSB7Y3VyU3RvcmU/LnJlbW92ZShjb29raWVOYW1lKTt9fX0vKipcbiAgICogRnVuY3Rpb24gdG8gdXBkYXRlIHN0b3JhZ2Ugd2hlbmV2ZXIgc3RhdGUgdmFsdWUgY2hhbmdlc1xuICAgKi9yZWdpc3RlckVmZmVjdHMoKXsvLyBUaGlzIHdpbGwgd29yayBhcyBsb25nIGFzIHRoZSB1c2VyIHNlc3Npb24gZW50cnkga2V5IG5hbWVzIGFyZSBzYW1lIGFzIHRoZSBzdGF0ZSBrZXlzXG5VU0VSX1NFU1NJT05fS0VZUy5mb3JFYWNoKHNlc3Npb25LZXk9PntFKCgpPT57dGhpcy5zeW5jVmFsdWVUb1N0b3JhZ2Uoc2Vzc2lvbktleSk7fSk7fSk7fS8qKlxuICAgKiBTZXRzIGFub255bW91cyBpZCBpbiB0aGUgZm9sbG93aW5nIHByZWNlZGVuY2U6XG4gICAqXG4gICAqIDEuIGFub255bW91c0lkOiBJZCBkaXJlY3RseSBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24uXG4gICAqIDIuIHJ1ZGRlckFtcExpbmtlclBhcmFtOiB2YWx1ZSBnZW5lcmF0ZWQgZnJvbSBsaW5rZXIgcXVlcnkgcGFybSAocnVkZGVyc3RhY2spXG4gICAqICAgIHVzaW5nIHBhcnNlTGlua2VyIHV0aWwuXG4gICAqIDMuIGdlbmVyYXRlVVVJRDogQSBuZXcgdW5pcXVlIGlkIGlzIGdlbmVyYXRlZCBhbmQgYXNzaWduZWQuXG4gICAqL3NldEFub255bW91c0lkKGFub255bW91c0lkLHJ1ZGRlckFtcExpbmtlclBhcmFtKXtsZXQgZmluYWxBbm9ueW1vdXNJZD1hbm9ueW1vdXNJZDtpZighaXNTdHJpbmcoYW5vbnltb3VzSWQpfHwhZmluYWxBbm9ueW1vdXNJZCl7ZmluYWxBbm9ueW1vdXNJZD11bmRlZmluZWQ7fWlmKHRoaXMuaXNQZXJzaXN0ZW5jZUVuYWJsZWRGb3JTdG9yYWdlRW50cnkoJ2Fub255bW91c0lkJykpe2lmKCFmaW5hbEFub255bW91c0lkJiZydWRkZXJBbXBMaW5rZXJQYXJhbSl7Y29uc3QgbGlua2VyUGx1Z2luc1Jlc3VsdD10aGlzLnBsdWdpbnNNYW5hZ2VyPy5pbnZva2VTaW5nbGUoJ3VzZXJTZXNzaW9uLmFub255bW91c0lkR29vZ2xlTGlua2VyJyxydWRkZXJBbXBMaW5rZXJQYXJhbSk7ZmluYWxBbm9ueW1vdXNJZD1saW5rZXJQbHVnaW5zUmVzdWx0O31maW5hbEFub255bW91c0lkPWZpbmFsQW5vbnltb3VzSWR8fGdlbmVyYXRlQW5vbnltb3VzSWQoKTt9ZWxzZSB7ZmluYWxBbm9ueW1vdXNJZD1ERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVMuYW5vbnltb3VzSWQ7fXN0YXRlLnNlc3Npb24uYW5vbnltb3VzSWQudmFsdWU9ZmluYWxBbm9ueW1vdXNJZDt9LyoqXG4gICAqIEZldGNoZXMgYW5vbnltb3VzSWRcbiAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uIHRvIGZldGNoIGl0IGZyb20gZXh0ZXJuYWwgc291cmNlXG4gICAqIEByZXR1cm5zIGFub255bW91c0lkXG4gICAqL2dldEFub255bW91c0lkKG9wdGlvbnMpe2NvbnN0IHN0b3JhZ2U9c3RhdGUuc3RvcmFnZS5lbnRyaWVzLnZhbHVlLmFub255bW91c0lkPy50eXBlO2lmKGlzU3RvcmFnZVR5cGVWYWxpZEZvclN0b3JpbmdEYXRhKHN0b3JhZ2UpKXtsZXQgcGVyc2lzdGVkQW5vbnltb3VzSWQ9c3RhdGUuc2Vzc2lvbi5hbm9ueW1vdXNJZC52YWx1ZTsvLyBJZiB0aGUgYW5vbnltb3VzIElEIGlzIHRoZSBkZWZhdWx0IHZhbHVlLCBmZXRjaCBpdCBmcm9tIHN0b3JhZ2VcbmlmKCFwZXJzaXN0ZWRBbm9ueW1vdXNJZHx8cGVyc2lzdGVkQW5vbnltb3VzSWQ9PT1ERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVMuYW5vbnltb3VzSWQpe3BlcnNpc3RlZEFub255bW91c0lkPXRoaXMuZ2V0RW50cnlWYWx1ZSgnYW5vbnltb3VzSWQnKTt9aWYoIXBlcnNpc3RlZEFub255bW91c0lkJiZvcHRpb25zKXsvLyBmZXRjaCBhbm9ueW1vdXNJZCBmcm9tIGV4dGVybmFsIHNvdXJjZVxuY29uc3QgYXV0b0NhcHR1cmVkQW5vbnltb3VzSWQ9dGhpcy5wbHVnaW5zTWFuYWdlcj8uaW52b2tlU2luZ2xlKCdzdG9yYWdlLmdldEFub255bW91c0lkJyxnZXRTdG9yYWdlRW5naW5lLG9wdGlvbnMpO3BlcnNpc3RlZEFub255bW91c0lkPWF1dG9DYXB0dXJlZEFub255bW91c0lkO31zdGF0ZS5zZXNzaW9uLmFub255bW91c0lkLnZhbHVlPXBlcnNpc3RlZEFub255bW91c0lkfHxnZW5lcmF0ZUFub255bW91c0lkKCk7fXJldHVybiBzdGF0ZS5zZXNzaW9uLmFub255bW91c0lkLnZhbHVlO31nZXRFbnRyeVZhbHVlKHNlc3Npb25LZXkpe2NvbnN0IGVudHJpZXM9c3RhdGUuc3RvcmFnZS5lbnRyaWVzLnZhbHVlO2NvbnN0IHN0b3JhZ2VUeXBlPWVudHJpZXNbc2Vzc2lvbktleV0/LnR5cGU7aWYoaXNTdG9yYWdlVHlwZVZhbGlkRm9yU3RvcmluZ0RhdGEoc3RvcmFnZVR5cGUpKXtjb25zdCBzdG9yZT10aGlzLnN0b3JlTWFuYWdlcj8uZ2V0U3RvcmUoc3RvcmFnZUNsaWVudERhdGFTdG9yZU5hbWVNYXBbc3RvcmFnZVR5cGVdKTsvLyBNaWdyYXRlIHRoZSBzdG9yYWdlIGRhdGEgYmVmb3JlIGZldGNoaW5nIHRoZSB2YWx1ZVxuLy8gVGhpcyBpcyBuZWVkZWQgZm9yIGVudHJpZXMgdGhhdCBhcmUgZmV0Y2hlZCBmcm9tIHRoZSBzdG9yYWdlXG4vLyBkdXJpbmcgdGhlIGN1cnJlbnQgc2Vzc2lvbiAoZm9yIGV4YW1wbGUsIHNlc3Npb24gaW5mbylcbnRoaXMubWlncmF0ZVN0b3JhZ2VJZk5lZWRlZChbc3RvcmVdLFtzZXNzaW9uS2V5XSk7Y29uc3Qgc3RvcmFnZUtleT1lbnRyaWVzW3Nlc3Npb25LZXldPy5rZXk7cmV0dXJuIHN0b3JlPy5nZXQoc3RvcmFnZUtleSk/P251bGw7fXJldHVybiBudWxsO31nZXRFeHRlcm5hbEFub255bW91c0lkQnlDb29raWVOYW1lKGtleSl7Y29uc3Qgc3RvcmFnZUVuZ2luZT1nZXRTdG9yYWdlRW5naW5lKENPT0tJRV9TVE9SQUdFKTtpZihzdG9yYWdlRW5naW5lPy5pc0VuYWJsZWQpe3JldHVybiBzdG9yYWdlRW5naW5lLmdldEl0ZW0oa2V5KT8/bnVsbDt9cmV0dXJuIG51bGw7fS8qKlxuICAgKiBGZXRjaGVzIHRoZSB2YWx1ZSBmb3IgYSBzZXNzaW9uIGtleS4gUHJlZmVyYWJseSBmcm9tIHN0b3JhZ2UsIGlmIHRoZSBzZXJ2ZXItc2lkZVxuICAgKiBjb29raWVzIHJlcXVlc3QgaXMgbm90IGluIHByb2dyZXNzLiBPdGhlcndpc2UsIGZyb20gdGhlIHN0YXRlLlxuICAgKiBAcGFyYW0gc2Vzc2lvbktleSAtIFRoZSBzZXNzaW9uIGtleSB0byBmZXRjaCB0aGUgdmFsdWUgZm9yXG4gICAqIEByZXR1cm5zIC0gVGhlIHZhbHVlIGZvciB0aGUgc2Vzc2lvbiBrZXlcbiAgICovZ2V0VXNlclNlc3Npb25WYWx1ZShzZXNzaW9uS2V5KXsvLyBJZiB0aGUgc2VydmVyLXNpZGUgY29va2llcyByZXF1ZXN0IGlzIGluIHByb2dyZXNzLCBmZXRjaCB0aGUgdmFsdWUgZnJvbSB0aGUgc3RhdGUuXG5pZih0aGlzLnNlcnZlclNpZGVDb29raWVzUmVxdWVzdEluUHJvZ3Jlc3Nbc2Vzc2lvbktleV0pe3JldHVybiBzdGF0ZS5zZXNzaW9uW3Nlc3Npb25LZXldLnZhbHVlO30vLyBPdGhlcndpc2UsIGZldGNoIHRoZSB2YWx1ZSBmcm9tIHN0b3JhZ2UuXG5yZXR1cm4gdGhpcy5nZXRFbnRyeVZhbHVlKHNlc3Npb25LZXkpO30vKipcbiAgICogRmV0Y2hlcyBVc2VyIElkXG4gICAqIEByZXR1cm5zXG4gICAqL2dldFVzZXJJZCgpe3JldHVybiB0aGlzLmdldFVzZXJTZXNzaW9uVmFsdWUoJ3VzZXJJZCcpO30vKipcbiAgICogRmV0Y2hlcyBVc2VyIFRyYWl0c1xuICAgKiBAcmV0dXJuc1xuICAgKi9nZXRVc2VyVHJhaXRzKCl7cmV0dXJuIHRoaXMuZ2V0VXNlclNlc3Npb25WYWx1ZSgndXNlclRyYWl0cycpO30vKipcbiAgICogRmV0Y2hlcyBHcm91cCBJZFxuICAgKiBAcmV0dXJuc1xuICAgKi9nZXRHcm91cElkKCl7cmV0dXJuIHRoaXMuZ2V0VXNlclNlc3Npb25WYWx1ZSgnZ3JvdXBJZCcpO30vKipcbiAgICogRmV0Y2hlcyBHcm91cCBUcmFpdHNcbiAgICogQHJldHVybnNcbiAgICovZ2V0R3JvdXBUcmFpdHMoKXtyZXR1cm4gdGhpcy5nZXRVc2VyU2Vzc2lvblZhbHVlKCdncm91cFRyYWl0cycpO30vKipcbiAgICogRmV0Y2hlcyBJbml0aWFsIFJlZmVycmVyXG4gICAqIEByZXR1cm5zXG4gICAqL2dldEluaXRpYWxSZWZlcnJlcigpe3JldHVybiB0aGlzLmdldFVzZXJTZXNzaW9uVmFsdWUoJ2luaXRpYWxSZWZlcnJlcicpO30vKipcbiAgICogRmV0Y2hlcyBJbml0aWFsIFJlZmVycmluZyBkb21haW5cbiAgICogQHJldHVybnNcbiAgICovZ2V0SW5pdGlhbFJlZmVycmluZ0RvbWFpbigpe3JldHVybiB0aGlzLmdldFVzZXJTZXNzaW9uVmFsdWUoJ2luaXRpYWxSZWZlcnJpbmdEb21haW4nKTt9LyoqXG4gICAqIEZldGNoZXMgc2Vzc2lvbiB0cmFja2luZyBpbmZvcm1hdGlvbiBmcm9tIHN0b3JhZ2VcbiAgICogQHJldHVybnNcbiAgICovZ2V0U2Vzc2lvbkluZm8oKXtyZXR1cm4gdGhpcy5nZXRVc2VyU2Vzc2lvblZhbHVlKCdzZXNzaW9uSW5mbycpO30vKipcbiAgICogRmV0Y2hlcyBhdXRoIHRva2VuIGZyb20gc3RvcmFnZVxuICAgKiBAcmV0dXJuc1xuICAgKi9nZXRBdXRoVG9rZW4oKXtyZXR1cm4gdGhpcy5nZXRVc2VyU2Vzc2lvblZhbHVlKCdhdXRoVG9rZW4nKTt9LyoqXG4gICAqIElmIHNlc3Npb24gaXMgYWN0aXZlIGl0IHJldHVybnMgdGhlIHNlc3Npb25JZFxuICAgKiBAcmV0dXJuc1xuICAgKi9nZXRTZXNzaW9uSWQoKXtjb25zdCBzZXNzaW9uSW5mbz10aGlzLmdldFNlc3Npb25JbmZvKCk/P0RFRkFVTFRfVVNFUl9TRVNTSU9OX1ZBTFVFUy5zZXNzaW9uSW5mbztpZihzZXNzaW9uSW5mby5hdXRvVHJhY2smJiFoYXNTZXNzaW9uRXhwaXJlZChzZXNzaW9uSW5mbyl8fHNlc3Npb25JbmZvLm1hbnVhbFRyYWNrKXtyZXR1cm4gc2Vzc2lvbkluZm8uaWQ/P251bGw7fXJldHVybiBudWxsO30vKipcbiAgICogQSBmdW5jdGlvbiB0byBrZWVwIHRoZSBzZXNzaW9uIGluZm9ybWF0aW9uIHVwIHRvIGRhdGUgaW4gdGhlIHN0YXRlXG4gICAqIGJlZm9yZSB1c2luZyBpdCBmb3IgYnVpbGRpbmcgZXZlbnQgcGF5bG9hZHMuXG4gICAqL3JlZnJlc2hTZXNzaW9uKCl7bGV0IHNlc3Npb25JbmZvPXRoaXMuZ2V0U2Vzc2lvbkluZm8oKT8/REVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLnNlc3Npb25JbmZvO2lmKHNlc3Npb25JbmZvLmF1dG9UcmFja3x8c2Vzc2lvbkluZm8ubWFudWFsVHJhY2spe2lmKHNlc3Npb25JbmZvLmF1dG9UcmFjayl7dGhpcy5zdGFydE9yUmVuZXdBdXRvVHJhY2tpbmcoc2Vzc2lvbkluZm8pO3Nlc3Npb25JbmZvPXN0YXRlLnNlc3Npb24uc2Vzc2lvbkluZm8udmFsdWU7fS8vIE5vdGUgdGhhdCBpZiBzZXNzaW9uU3RhcnQgaXMgZmFsc2UsIHRoZW4gaXQncyBhbiBhY3RpdmUgc2Vzc2lvbi5cbi8vIFNvLCB3ZSBuZWVkbid0IHVwZGF0ZSB0aGUgc2Vzc2lvbiBpbmZvLlxuLy9cbi8vIEZvciBvdGhlciBzY2VuYXJpb3MsXG4vLyAxLiBJZiBzZXNzaW9uU3RhcnQgaXMgdW5kZWZpbmVkLCB0aGVuIGl0J3MgYSBuZXcgc2Vzc2lvbi5cbi8vICAgTWFyayBpdCBhcyBzZXNzaW9uU3RhcnQuXG4vLyAyLiBJZiBzZXNzaW9uU3RhcnQgaXMgdHJ1ZSwgdGhlbiBuZWVkIHRvIGZsaXAgaXQgZm9yIHRoZSBmdXR1cmUgZXZlbnRzLlxuaWYoc2Vzc2lvbkluZm8uc2Vzc2lvblN0YXJ0PT09dW5kZWZpbmVkKXtzZXNzaW9uSW5mbz17Li4uc2Vzc2lvbkluZm8sc2Vzc2lvblN0YXJ0OnRydWV9O31lbHNlIGlmKHNlc3Npb25JbmZvLnNlc3Npb25TdGFydCl7c2Vzc2lvbkluZm89ey4uLnNlc3Npb25JbmZvLHNlc3Npb25TdGFydDpmYWxzZX07fX0vLyBBbHdheXMgd3JpdGUgdG8gc3RhdGUgKGluLXR1cm4gdG8gc3RvcmFnZSkgdG8ga2VlcCB0aGUgc2Vzc2lvbiBpbmZvIHVwIHRvIGRhdGUuXG5zdGF0ZS5zZXNzaW9uLnNlc3Npb25JbmZvLnZhbHVlPXNlc3Npb25JbmZvO2lmKHN0YXRlLmxpZmVjeWNsZS5zdGF0dXMudmFsdWUhPT0ncmVhZHlFeGVjdXRlZCcpey8vIEZvcmNlIHVwZGF0ZSB0aGUgc3RvcmFnZSBhcyB0aGUgJ2VmZmVjdCcgYmxvY2tzIGFyZSBub3QgZ2V0dGluZyB0cmlnZ2VyZWRcbi8vIHdoZW4gcHJvY2Vzc2luZyBwcmVsb2FkIGJ1ZmZlcmVkIHJlcXVlc3RzXG50aGlzLnN5bmNWYWx1ZVRvU3RvcmFnZSgnc2Vzc2lvbkluZm8nKTt9fXJlc2V0QW5kU3RhcnROZXdTZXNzaW9uKCl7Y29uc3Qgc2Vzc2lvbj1zdGF0ZS5zZXNzaW9uO2NvbnN0e21hbnVhbFRyYWNrLGF1dG9UcmFjayx0aW1lb3V0LGN1dE9mZn09c2Vzc2lvbi5zZXNzaW9uSW5mby52YWx1ZTtpZihhdXRvVHJhY2spe2NvbnN0IHNlc3Npb25JbmZvPXsuLi5ERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVMuc2Vzc2lvbkluZm8sdGltZW91dH07aWYoY3V0T2ZmKXtzZXNzaW9uSW5mby5jdXRPZmY9e2VuYWJsZWQ6Y3V0T2ZmLmVuYWJsZWQsZHVyYXRpb246Y3V0T2ZmLmR1cmF0aW9ufTt9c2Vzc2lvbi5zZXNzaW9uSW5mby52YWx1ZT1zZXNzaW9uSW5mbzt0aGlzLnN0YXJ0T3JSZW5ld0F1dG9UcmFja2luZyhzZXNzaW9uLnNlc3Npb25JbmZvLnZhbHVlKTt9ZWxzZSBpZihtYW51YWxUcmFjayl7dGhpcy5zdGFydE1hbnVhbFRyYWNraW5nSW50ZXJuYWwoKTt9fS8qKlxuICAgKiBSZXNldCBzdGF0ZSB2YWx1ZXNcbiAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyBmb3IgcmVzZXRcbiAgICogQHJldHVybnNcbiAgICovcmVzZXQob3B0aW9ucyl7Y29uc3R7c2Vzc2lvbn09c3RhdGU7Y29uc3Qgb3B0cz1nZXRGaW5hbFJlc2V0T3B0aW9ucyhvcHRpb25zKTtyKCgpPT57T2JqZWN0LmtleXMoREVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTKS5mb3JFYWNoKGtleT0+e2NvbnN0IHVzZXJTZXNzaW9uS2V5PWtleTtpZihvcHRzLmVudHJpZXNbdXNlclNlc3Npb25LZXldIT09dHJ1ZSl7cmV0dXJuO31zd2l0Y2goa2V5KXtjYXNlICdhbm9ueW1vdXNJZCc6dGhpcy5zZXRBbm9ueW1vdXNJZCgpO2JyZWFrO2Nhc2UgJ3Nlc3Npb25JbmZvJzp0aGlzLnJlc2V0QW5kU3RhcnROZXdTZXNzaW9uKCk7YnJlYWs7ZGVmYXVsdDpzZXNzaW9uW3VzZXJTZXNzaW9uS2V5XS52YWx1ZT1ERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVNbdXNlclNlc3Npb25LZXldO2JyZWFrO319KTt9KTt9LyoqXG4gICAqIFNldCB1c2VyIElkXG4gICAqIEBwYXJhbSB1c2VySWRcbiAgICovc2V0VXNlcklkKHVzZXJJZCl7c3RhdGUuc2Vzc2lvbi51c2VySWQudmFsdWU9dGhpcy5pc1BlcnNpc3RlbmNlRW5hYmxlZEZvclN0b3JhZ2VFbnRyeSgndXNlcklkJykmJnVzZXJJZD91c2VySWQ6REVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLnVzZXJJZDt9LyoqXG4gICAqIFNldCB1c2VyIHRyYWl0c1xuICAgKiBAcGFyYW0gdHJhaXRzXG4gICAqL3NldFVzZXJUcmFpdHModHJhaXRzKXtzdGF0ZS5zZXNzaW9uLnVzZXJUcmFpdHMudmFsdWU9dGhpcy5pc1BlcnNpc3RlbmNlRW5hYmxlZEZvclN0b3JhZ2VFbnRyeSgndXNlclRyYWl0cycpJiZpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKHRyYWl0cyk/bWVyZ2VEZWVwUmlnaHQoc3RhdGUuc2Vzc2lvbi51c2VyVHJhaXRzLnZhbHVlPz9ERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVMudXNlclRyYWl0cyx0cmFpdHMpOkRFRkFVTFRfVVNFUl9TRVNTSU9OX1ZBTFVFUy51c2VyVHJhaXRzO30vKipcbiAgICogU2V0IGdyb3VwIElkXG4gICAqIEBwYXJhbSBncm91cElkXG4gICAqL3NldEdyb3VwSWQoZ3JvdXBJZCl7c3RhdGUuc2Vzc2lvbi5ncm91cElkLnZhbHVlPXRoaXMuaXNQZXJzaXN0ZW5jZUVuYWJsZWRGb3JTdG9yYWdlRW50cnkoJ2dyb3VwSWQnKSYmZ3JvdXBJZD9ncm91cElkOkRFRkFVTFRfVVNFUl9TRVNTSU9OX1ZBTFVFUy5ncm91cElkO30vKipcbiAgICogU2V0IGdyb3VwIHRyYWl0c1xuICAgKiBAcGFyYW0gdHJhaXRzXG4gICAqL3NldEdyb3VwVHJhaXRzKHRyYWl0cyl7c3RhdGUuc2Vzc2lvbi5ncm91cFRyYWl0cy52YWx1ZT10aGlzLmlzUGVyc2lzdGVuY2VFbmFibGVkRm9yU3RvcmFnZUVudHJ5KCdncm91cFRyYWl0cycpJiZpc09iamVjdExpdGVyYWxBbmROb3ROdWxsKHRyYWl0cyk/bWVyZ2VEZWVwUmlnaHQoc3RhdGUuc2Vzc2lvbi5ncm91cFRyYWl0cy52YWx1ZT8/REVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLmdyb3VwVHJhaXRzLHRyYWl0cyk6REVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLmdyb3VwVHJhaXRzO30vKipcbiAgICogU2V0IGluaXRpYWwgcmVmZXJyZXJcbiAgICogQHBhcmFtIHJlZmVycmVyXG4gICAqL3NldEluaXRpYWxSZWZlcnJlcihyZWZlcnJlcil7c3RhdGUuc2Vzc2lvbi5pbml0aWFsUmVmZXJyZXIudmFsdWU9dGhpcy5pc1BlcnNpc3RlbmNlRW5hYmxlZEZvclN0b3JhZ2VFbnRyeSgnaW5pdGlhbFJlZmVycmVyJykmJnJlZmVycmVyP3JlZmVycmVyOkRFRkFVTFRfVVNFUl9TRVNTSU9OX1ZBTFVFUy5pbml0aWFsUmVmZXJyZXI7fS8qKlxuICAgKiBTZXQgaW5pdGlhbCByZWZlcnJpbmcgZG9tYWluXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWZlcnJpbmdEb21haW5cbiAgICovc2V0SW5pdGlhbFJlZmVycmluZ0RvbWFpbihyZWZlcnJpbmdEb21haW4pe3N0YXRlLnNlc3Npb24uaW5pdGlhbFJlZmVycmluZ0RvbWFpbi52YWx1ZT10aGlzLmlzUGVyc2lzdGVuY2VFbmFibGVkRm9yU3RvcmFnZUVudHJ5KCdpbml0aWFsUmVmZXJyaW5nRG9tYWluJykmJnJlZmVycmluZ0RvbWFpbj9yZWZlcnJpbmdEb21haW46REVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLmluaXRpYWxSZWZlcnJpbmdEb21haW47fS8qKlxuICAgKiBBIGZ1bmN0aW9uIHRvIGNoZWNrIGZvciBleGlzdGluZyBzZXNzaW9uIGRldGFpbHMgYW5kIGRlcGVuZGluZyBvbiB0aGF0IGNyZWF0ZSBhIG5ldyBzZXNzaW9uXG4gICAqL3N0YXJ0T3JSZW5ld0F1dG9UcmFja2luZyhzZXNzaW9uSW5mbyl7bGV0IGZpbmFsU2Vzc2lvbkluZm89c2Vzc2lvbkluZm87aWYoaGFzU2Vzc2lvbkV4cGlyZWQoc2Vzc2lvbkluZm8pKXtmaW5hbFNlc3Npb25JbmZvPWdlbmVyYXRlQXV0b1RyYWNraW5nU2Vzc2lvbihzZXNzaW9uSW5mbyk7fWVsc2Uge2NvbnN0IHRpbWVzdGFtcD1EYXRlLm5vdygpO2NvbnN0IHRpbWVvdXQ9c2Vzc2lvbkluZm8udGltZW91dDsvLyBTZXQgdGhlIGV4cGlyeSB0aW1lIG9mIHRoZSBzZXNzaW9uXG5maW5hbFNlc3Npb25JbmZvLmV4cGlyZXNBdD10aW1lc3RhbXArdGltZW91dDt9Ly8gUmVzZXQgY3V0IG9mZiBleHBpcnkgdGltZXN0YW1wIGlmIGl0IGlzIGV4Y2VlZGVkXG5pZihpc0N1dE9mZlRpbWVFeGNlZWRlZChmaW5hbFNlc3Npb25JbmZvKSl7ZmluYWxTZXNzaW9uSW5mby5jdXRPZmYuZXhwaXJlc0F0PXVuZGVmaW5lZDt9Ly8gSWYgY3V0IG9mZiBpcyBhY3RpdmUsIHNldCBvciByZXRhaW4gdGhlIGV4cGlyeSB0aW1lXG5pZihmaW5hbFNlc3Npb25JbmZvLmN1dE9mZil7Y29uc3QgY3V0T2ZmRXhwaXJlc0F0PWdldEN1dE9mZkV4cGlyYXRpb25UaW1lc3RhbXAoZmluYWxTZXNzaW9uSW5mby5jdXRPZmYpO2ZpbmFsU2Vzc2lvbkluZm8uY3V0T2ZmLmV4cGlyZXNBdD1jdXRPZmZFeHBpcmVzQXQ7fS8vIFVwZGF0ZSB0aGUgc2Vzc2lvbiBpbmZvIGluIHRoZSBzdGF0ZVxuc3RhdGUuc2Vzc2lvbi5zZXNzaW9uSW5mby52YWx1ZT1maW5hbFNlc3Npb25JbmZvO30vKipcbiAgICogQSBmdW5jdGlvbiBtZXRob2QgdG8gc3RhcnQgYSBtYW51YWwgc2Vzc2lvblxuICAgKiBAcGFyYW0ge251bWJlcn0gaWQgICAgIHNlc3Npb24gaWRlbnRpZmllclxuICAgKiBAcmV0dXJuc1xuICAgKi9zdGFydChpZCl7c3RhdGUuc2Vzc2lvbi5zZXNzaW9uSW5mby52YWx1ZT1nZW5lcmF0ZU1hbnVhbFRyYWNraW5nU2Vzc2lvbihpZCx0aGlzLmxvZ2dlcik7fS8qKlxuICAgKiBBbiBpbnRlcm5hbCBmdW5jdGlvbiB0byBzdGFydCBtYW51YWwgc2Vzc2lvblxuICAgKi9zdGFydE1hbnVhbFRyYWNraW5nSW50ZXJuYWwoKXt0aGlzLnN0YXJ0KERhdGUubm93KCkpO30vKipcbiAgICogQSBwdWJsaWMgbWV0aG9kIHRvIGVuZCBhbiBvbmdvaW5nIHNlc3Npb24uXG4gICAqL2VuZCgpe3N0YXRlLnNlc3Npb24uc2Vzc2lvbkluZm8udmFsdWU9REVGQVVMVF9VU0VSX1NFU1NJT05fVkFMVUVTLnNlc3Npb25JbmZvO30vKipcbiAgICogU2V0IGF1dGggdG9rZW5cbiAgICogQHBhcmFtIHVzZXJJZFxuICAgKi9zZXRBdXRoVG9rZW4odG9rZW4pe3N0YXRlLnNlc3Npb24uYXV0aFRva2VuLnZhbHVlPXRoaXMuaXNQZXJzaXN0ZW5jZUVuYWJsZWRGb3JTdG9yYWdlRW50cnkoJ2F1dGhUb2tlbicpJiZ0b2tlbj90b2tlbjpERUZBVUxUX1VTRVJfU0VTU0lPTl9WQUxVRVMuYXV0aFRva2VuO319XG5cbi8qKlxuICogUGx1Z2lucyB0byBiZSBsb2FkZWQgaW4gdGhlIHBsdWdpbnMgbG9hZE9wdGlvbiBpcyBub3QgZGVmaW5lZFxuICovY29uc3QgZGVmYXVsdE9wdGlvbmFsUGx1Z2luc0xpc3Q9WydCZWFjb25RdWV1ZScsJ0N1c3RvbUNvbnNlbnRNYW5hZ2VyJywnRGV2aWNlTW9kZURlc3RpbmF0aW9ucycsJ0RldmljZU1vZGVUcmFuc2Zvcm1hdGlvbicsJ0V4dGVybmFsQW5vbnltb3VzSWQnLCdHb29nbGVMaW5rZXInLCdJdWJlbmRhQ29uc2VudE1hbmFnZXInLCdLZXRjaENvbnNlbnRNYW5hZ2VyJywnTmF0aXZlRGVzdGluYXRpb25RdWV1ZScsJ09uZVRydXN0Q29uc2VudE1hbmFnZXInLCdTdG9yYWdlRW5jcnlwdGlvbicsJ1N0b3JhZ2VFbmNyeXB0aW9uTGVnYWN5JywnU3RvcmFnZU1pZ3JhdG9yJywnWGhyUXVldWUnXTtcblxuY29uc3Qgbm9ybWFsaXplTG9hZE9wdGlvbnM9KGxvYWRPcHRpb25zRnJvbVN0YXRlLGxvYWRPcHRpb25zKT0+ey8vIFRPRE86IE1heWJlIGFkZCB3YXJuaW5ncyBmb3IgaW52YWxpZCB2YWx1ZXNcbmNvbnN0IG5vcm1hbGl6ZWRMb2FkT3B0cz1jbG9uZShsb2FkT3B0aW9ucyk7aWYoIWlzU3RyaW5nKG5vcm1hbGl6ZWRMb2FkT3B0cy5zZXRDb29raWVEb21haW4pKXtub3JtYWxpemVkTG9hZE9wdHMuc2V0Q29va2llRG9tYWluPXVuZGVmaW5lZDt9Y29uc3QgY29va2llU2FtZVNpdGVWYWx1ZXM9WydTdHJpY3QnLCdMYXgnLCdOb25lJ107aWYoIWNvb2tpZVNhbWVTaXRlVmFsdWVzLmluY2x1ZGVzKG5vcm1hbGl6ZWRMb2FkT3B0cy5zYW1lU2l0ZUNvb2tpZSkpe25vcm1hbGl6ZWRMb2FkT3B0cy5zYW1lU2l0ZUNvb2tpZT11bmRlZmluZWQ7fW5vcm1hbGl6ZWRMb2FkT3B0cy5zZWN1cmVDb29raWU9Z2V0Tm9ybWFsaXplZEJvb2xlYW5WYWx1ZShub3JtYWxpemVkTG9hZE9wdHMuc2VjdXJlQ29va2llLGxvYWRPcHRpb25zRnJvbVN0YXRlLnNlY3VyZUNvb2tpZSk7bm9ybWFsaXplZExvYWRPcHRzLnNhbWVEb21haW5Db29raWVzT25seT1nZXROb3JtYWxpemVkQm9vbGVhblZhbHVlKG5vcm1hbGl6ZWRMb2FkT3B0cy5zYW1lRG9tYWluQ29va2llc09ubHksbG9hZE9wdGlvbnNGcm9tU3RhdGUuc2FtZURvbWFpbkNvb2tpZXNPbmx5KTtjb25zdCB1YUNoVHJhY2tMZXZlbHM9Wydub25lJywnZGVmYXVsdCcsJ2Z1bGwnXTtpZighdWFDaFRyYWNrTGV2ZWxzLmluY2x1ZGVzKG5vcm1hbGl6ZWRMb2FkT3B0cy51YUNoVHJhY2tMZXZlbCkpe25vcm1hbGl6ZWRMb2FkT3B0cy51YUNoVHJhY2tMZXZlbD11bmRlZmluZWQ7fW5vcm1hbGl6ZWRMb2FkT3B0cy5pbnRlZ3JhdGlvbnM9Z2V0Tm9ybWFsaXplZE9iamVjdFZhbHVlKG5vcm1hbGl6ZWRMb2FkT3B0cy5pbnRlZ3JhdGlvbnMpO2lmKCFBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRMb2FkT3B0cy5wbHVnaW5zKSl7bm9ybWFsaXplZExvYWRPcHRzLnBsdWdpbnM9ZGVmYXVsdE9wdGlvbmFsUGx1Z2luc0xpc3Q7fW5vcm1hbGl6ZWRMb2FkT3B0cy51c2VHbG9iYWxJbnRlZ3JhdGlvbnNDb25maWdJbkV2ZW50cz1nZXROb3JtYWxpemVkQm9vbGVhblZhbHVlKG5vcm1hbGl6ZWRMb2FkT3B0cy51c2VHbG9iYWxJbnRlZ3JhdGlvbnNDb25maWdJbkV2ZW50cyxsb2FkT3B0aW9uc0Zyb21TdGF0ZS51c2VHbG9iYWxJbnRlZ3JhdGlvbnNDb25maWdJbkV2ZW50cyk7bm9ybWFsaXplZExvYWRPcHRzLmJ1ZmZlckRhdGFQbGFuZUV2ZW50c1VudGlsUmVhZHk9Z2V0Tm9ybWFsaXplZEJvb2xlYW5WYWx1ZShub3JtYWxpemVkTG9hZE9wdHMuYnVmZmVyRGF0YVBsYW5lRXZlbnRzVW50aWxSZWFkeSxsb2FkT3B0aW9uc0Zyb21TdGF0ZS5idWZmZXJEYXRhUGxhbmVFdmVudHNVbnRpbFJlYWR5KTtub3JtYWxpemVkTG9hZE9wdHMuc2VuZEFkYmxvY2tQYWdlPWdldE5vcm1hbGl6ZWRCb29sZWFuVmFsdWUobm9ybWFsaXplZExvYWRPcHRzLnNlbmRBZGJsb2NrUGFnZSxsb2FkT3B0aW9uc0Zyb21TdGF0ZS5zZW5kQWRibG9ja1BhZ2UpO25vcm1hbGl6ZWRMb2FkT3B0cy51c2VTZXJ2ZXJTaWRlQ29va2llcz1nZXROb3JtYWxpemVkQm9vbGVhblZhbHVlKG5vcm1hbGl6ZWRMb2FkT3B0cy51c2VTZXJ2ZXJTaWRlQ29va2llcyxsb2FkT3B0aW9uc0Zyb21TdGF0ZS51c2VTZXJ2ZXJTaWRlQ29va2llcyk7aWYoIWlzU3RyaW5nKG5vcm1hbGl6ZWRMb2FkT3B0cy5kYXRhU2VydmljZUVuZHBvaW50KSl7bm9ybWFsaXplZExvYWRPcHRzLmRhdGFTZXJ2aWNlRW5kcG9pbnQ9dW5kZWZpbmVkO31ub3JtYWxpemVkTG9hZE9wdHMuc2VuZEFkYmxvY2tQYWdlT3B0aW9ucz1nZXROb3JtYWxpemVkT2JqZWN0VmFsdWUobm9ybWFsaXplZExvYWRPcHRzLnNlbmRBZGJsb2NrUGFnZU9wdGlvbnMpO25vcm1hbGl6ZWRMb2FkT3B0cy5sb2FkSW50ZWdyYXRpb249Z2V0Tm9ybWFsaXplZEJvb2xlYW5WYWx1ZShub3JtYWxpemVkTG9hZE9wdHMubG9hZEludGVncmF0aW9uLGxvYWRPcHRpb25zRnJvbVN0YXRlLmxvYWRJbnRlZ3JhdGlvbik7aWYoIWlzTm9uRW1wdHlPYmplY3Qobm9ybWFsaXplZExvYWRPcHRzLnN0b3JhZ2UpKXtub3JtYWxpemVkTG9hZE9wdHMuc3RvcmFnZT11bmRlZmluZWQ7fWVsc2Uge25vcm1hbGl6ZWRMb2FkT3B0cy5zdG9yYWdlLm1pZ3JhdGU9Z2V0Tm9ybWFsaXplZEJvb2xlYW5WYWx1ZShub3JtYWxpemVkTG9hZE9wdHMuc3RvcmFnZS5taWdyYXRlLGxvYWRPcHRpb25zRnJvbVN0YXRlLnN0b3JhZ2U/Lm1pZ3JhdGUpO25vcm1hbGl6ZWRMb2FkT3B0cy5zdG9yYWdlLmNvb2tpZT1nZXROb3JtYWxpemVkT2JqZWN0VmFsdWUobm9ybWFsaXplZExvYWRPcHRzLnN0b3JhZ2UuY29va2llKTtub3JtYWxpemVkTG9hZE9wdHMuc3RvcmFnZS5lbmNyeXB0aW9uPWdldE5vcm1hbGl6ZWRPYmplY3RWYWx1ZShub3JtYWxpemVkTG9hZE9wdHMuc3RvcmFnZS5lbmNyeXB0aW9uKTtub3JtYWxpemVkTG9hZE9wdHMuc3RvcmFnZT1yZW1vdmVVbmRlZmluZWRBbmROdWxsVmFsdWVzKG5vcm1hbGl6ZWRMb2FkT3B0cy5zdG9yYWdlKTt9bm9ybWFsaXplZExvYWRPcHRzLmRlc3RpbmF0aW9uc1F1ZXVlT3B0aW9ucz1nZXROb3JtYWxpemVkT2JqZWN0VmFsdWUobm9ybWFsaXplZExvYWRPcHRzLmRlc3RpbmF0aW9uc1F1ZXVlT3B0aW9ucyk7bm9ybWFsaXplZExvYWRPcHRzLnF1ZXVlT3B0aW9ucz1nZXROb3JtYWxpemVkT2JqZWN0VmFsdWUobm9ybWFsaXplZExvYWRPcHRzLnF1ZXVlT3B0aW9ucyk7bm9ybWFsaXplZExvYWRPcHRzLmxvY2tJbnRlZ3JhdGlvbnNWZXJzaW9uPWdldE5vcm1hbGl6ZWRCb29sZWFuVmFsdWUobm9ybWFsaXplZExvYWRPcHRzLmxvY2tJbnRlZ3JhdGlvbnNWZXJzaW9uLGxvYWRPcHRpb25zRnJvbVN0YXRlLmxvY2tJbnRlZ3JhdGlvbnNWZXJzaW9uKTtub3JtYWxpemVkTG9hZE9wdHMubG9ja1BsdWdpbnNWZXJzaW9uPWdldE5vcm1hbGl6ZWRCb29sZWFuVmFsdWUobm9ybWFsaXplZExvYWRPcHRzLmxvY2tQbHVnaW5zVmVyc2lvbixsb2FkT3B0aW9uc0Zyb21TdGF0ZS5sb2NrUGx1Z2luc1ZlcnNpb24pO2lmKCFpc051bWJlcihub3JtYWxpemVkTG9hZE9wdHMuZGF0YVBsYW5lRXZlbnRzQnVmZmVyVGltZW91dCkpe25vcm1hbGl6ZWRMb2FkT3B0cy5kYXRhUGxhbmVFdmVudHNCdWZmZXJUaW1lb3V0PXVuZGVmaW5lZDt9bm9ybWFsaXplZExvYWRPcHRzLmJlYWNvblF1ZXVlT3B0aW9ucz1nZXROb3JtYWxpemVkT2JqZWN0VmFsdWUobm9ybWFsaXplZExvYWRPcHRzLmJlYWNvblF1ZXVlT3B0aW9ucyk7bm9ybWFsaXplZExvYWRPcHRzLnByZUNvbnNlbnQ9Z2V0Tm9ybWFsaXplZE9iamVjdFZhbHVlKG5vcm1hbGl6ZWRMb2FkT3B0cy5wcmVDb25zZW50KTtub3JtYWxpemVkTG9hZE9wdHMuc291cmNlQ29uZmlndXJhdGlvbk92ZXJyaWRlPWdldE5vcm1hbGl6ZWRPYmplY3RWYWx1ZShub3JtYWxpemVkTG9hZE9wdHMuc291cmNlQ29uZmlndXJhdGlvbk92ZXJyaWRlKTtjb25zdCBtZXJnZWRMb2FkT3B0aW9ucz1tZXJnZURlZXBSaWdodChsb2FkT3B0aW9uc0Zyb21TdGF0ZSxyZW1vdmVVbmRlZmluZWRBbmROdWxsVmFsdWVzKG5vcm1hbGl6ZWRMb2FkT3B0cykpO3JldHVybiBtZXJnZWRMb2FkT3B0aW9uczt9O1xuXG5jb25zdCBEQVRBX1BMQU5FX1FVRVVFX0VYVF9QT0lOVF9QUkVGSVg9J2RhdGFwbGFuZUV2ZW50c1F1ZXVlJztjb25zdCBERVNUSU5BVElPTlNfUVVFVUVfRVhUX1BPSU5UX1BSRUZJWD0nZGVzdGluYXRpb25zRXZlbnRzUXVldWUnO2NvbnN0IERNVF9FWFRfUE9JTlRfUFJFRklYPSd0cmFuc2Zvcm1FdmVudCc7XG5cbi8qKlxuICogRmlsdGVycyBhbmQgcmV0dXJucyB0aGUgdXNlciBzdXBwbGllZCBpbnRlZ3JhdGlvbnMgY29uZmlnIHRoYXQgc2hvdWxkIHRha2UgcHJlZmVyZW5jZSBvdmVyIHRoZSBkZXN0aW5hdGlvbiBzcGVjaWZpYyBpbnRlZ3JhdGlvbnMgY29uZmlnXG4gKiBAcGFyYW0gZXZlbnRJbnRnQ29uZmlnIFVzZXIgc3VwcGxpZWQgaW50ZWdyYXRpb25zIGNvbmZpZyBhdCBldmVudCBsZXZlbFxuICogQHBhcmFtIGRlc3RpbmF0aW9uc0ludGdDb25maWcgQ3VtdWxhdGl2ZSBpbnRlZ3JhdGlvbnMgY29uZmlnIGZyb20gYWxsIGRlc3RpbmF0aW9uc1xuICogQHJldHVybnMgRmlsdGVyZWQgdXNlciBzdXBwbGllZCBpbnRlZ3JhdGlvbnMgY29uZmlnXG4gKi9jb25zdCBnZXRPdmVycmlkZGVuSW50ZWdyYXRpb25PcHRpb25zPShldmVudEludGdDb25maWcsZGVzdGluYXRpb25zSW50Z0NvbmZpZyk9Pk9iamVjdC5rZXlzKGV2ZW50SW50Z0NvbmZpZykuZmlsdGVyKGludGdOYW1lPT5ldmVudEludGdDb25maWdbaW50Z05hbWVdIT09dHJ1ZXx8IWRlc3RpbmF0aW9uc0ludGdDb25maWdbaW50Z05hbWVdKS5yZWR1Y2UoKG9iaixrZXkpPT57Y29uc3QgcmV0VmFsPWNsb25lKG9iaik7cmV0VmFsW2tleV09ZXZlbnRJbnRnQ29uZmlnW2tleV07cmV0dXJuIHJldFZhbDt9LHt9KTsvKipcbiAqIFJldHVybnMgdGhlIGV2ZW50IG9iamVjdCB3aXRoIGZpbmFsIGludGVncmF0aW9ucyBjb25maWdcbiAqIEBwYXJhbSBldmVudCBSdWRkZXJFdmVudCBvYmplY3RcbiAqIEBwYXJhbSBzdGF0ZSBBcHBsaWNhdGlvbiBzdGF0ZVxuICogQHJldHVybnMgTXV0YXRlZCBldmVudCB3aXRoIGZpbmFsIGludGVncmF0aW9ucyBjb25maWdcbiAqL2NvbnN0IGdldEZpbmFsRXZlbnQ9KGV2ZW50LHN0YXRlKT0+e2NvbnN0IGZpbmFsRXZlbnQ9Y2xvbmUoZXZlbnQpOy8vIE1lcmdlIHRoZSBkZXN0aW5hdGlvbiBzcGVjaWZpYyBpbnRlZ3JhdGlvbnMgY29uZmlnIHdpdGggdGhlIGV2ZW50J3MgaW50ZWdyYXRpb25zIGNvbmZpZ1xuLy8gSW4gZ2VuZXJhbCwgdGhlIHByZWZlcmVuY2UgaXMgZ2l2ZW4gdG8gdGhlIGV2ZW50J3MgaW50ZWdyYXRpb25zIGNvbmZpZ1xuY29uc3QgZGVzdGluYXRpb25zSW50Z0NvbmZpZz1zdGF0ZS5uYXRpdmVEZXN0aW5hdGlvbnMuaW50ZWdyYXRpb25zQ29uZmlnLnZhbHVlO2NvbnN0IG92ZXJyaWRkZW5JbnRnT3B0cz1nZXRPdmVycmlkZGVuSW50ZWdyYXRpb25PcHRpb25zKGV2ZW50LmludGVncmF0aW9ucyxkZXN0aW5hdGlvbnNJbnRnQ29uZmlnKTtmaW5hbEV2ZW50LmludGVncmF0aW9ucz1tZXJnZURlZXBSaWdodChkZXN0aW5hdGlvbnNJbnRnQ29uZmlnLG92ZXJyaWRkZW5JbnRnT3B0cyk7cmV0dXJuIGZpbmFsRXZlbnQ7fTtjb25zdCBzaG91bGRCdWZmZXJFdmVudHNGb3JQcmVDb25zZW50PXN0YXRlPT5zdGF0ZS5jb25zZW50cy5wcmVDb25zZW50LnZhbHVlLmVuYWJsZWQmJnN0YXRlLmNvbnNlbnRzLnByZUNvbnNlbnQudmFsdWUuZXZlbnRzPy5kZWxpdmVyeT09PSdidWZmZXInO1xuXG5jb25zdCBzYWZlbHlJbnZva2VDYWxsYmFjaz0oY2FsbGJhY2ssYXJncyxhcGlOYW1lLGxvZ2dlcik9PntpZighaXNEZWZpbmVkKGNhbGxiYWNrKSl7cmV0dXJuO31pZihpc0Z1bmN0aW9uKGNhbGxiYWNrKSl7dHJ5e2NhbGxiYWNrKC4uLmFyZ3MpO31jYXRjaChlcnJvcil7bG9nZ2VyLmVycm9yKENBTExCQUNLX0lOVk9LRV9FUlJPUihhcGlOYW1lKSxlcnJvcik7fX1lbHNlIHtsb2dnZXIuZXJyb3IoSU5WQUxJRF9DQUxMQkFDS19GTl9FUlJPUihhcGlOYW1lKSk7fX07XG5cbi8qKlxuICogRXZlbnQgcmVwb3NpdG9yeSBjbGFzcyByZXNwb25zaWJsZSBmb3IgcXVldWluZyBldmVudHMgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZyBhbmQgZGVsaXZlcnlcbiAqL2NsYXNzIEV2ZW50UmVwb3NpdG9yeXsvKipcbiAgICpcbiAgICogQHBhcmFtIHBsdWdpbnNNYW5hZ2VyIFBsdWdpbnMgbWFuYWdlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0gc3RvcmVNYW5hZ2VyIFN0b3JlIE1hbmFnZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIGVycm9ySGFuZGxlciBFcnJvciBoYW5kbGVyIG9iamVjdFxuICAgKiBAcGFyYW0gbG9nZ2VyIExvZ2dlciBvYmplY3RcbiAgICovY29uc3RydWN0b3IocGx1Z2luc01hbmFnZXIsc3RvcmVNYW5hZ2VyLGh0dHBDbGllbnQsZXJyb3JIYW5kbGVyLGxvZ2dlcil7dGhpcy5wbHVnaW5zTWFuYWdlcj1wbHVnaW5zTWFuYWdlcjt0aGlzLmVycm9ySGFuZGxlcj1lcnJvckhhbmRsZXI7dGhpcy5odHRwQ2xpZW50PWh0dHBDbGllbnQ7dGhpcy5sb2dnZXI9bG9nZ2VyO3RoaXMuc3RvcmVNYW5hZ2VyPXN0b3JlTWFuYWdlcjt9LyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBldmVudCByZXBvc2l0b3J5XG4gICAqL2luaXQoKXt0aGlzLmRhdGFwbGFuZUV2ZW50c1F1ZXVlPXRoaXMucGx1Z2luc01hbmFnZXIuaW52b2tlU2luZ2xlKGAke0RBVEFfUExBTkVfUVVFVUVfRVhUX1BPSU5UX1BSRUZJWH0uaW5pdGAsc3RhdGUsdGhpcy5odHRwQ2xpZW50LHRoaXMuc3RvcmVNYW5hZ2VyLHRoaXMuZXJyb3JIYW5kbGVyLHRoaXMubG9nZ2VyKTt0aGlzLmRtdEV2ZW50c1F1ZXVlPXRoaXMucGx1Z2luc01hbmFnZXIuaW52b2tlU2luZ2xlKGAke0RNVF9FWFRfUE9JTlRfUFJFRklYfS5pbml0YCxzdGF0ZSx0aGlzLnBsdWdpbnNNYW5hZ2VyLHRoaXMuaHR0cENsaWVudCx0aGlzLnN0b3JlTWFuYWdlcix0aGlzLmVycm9ySGFuZGxlcix0aGlzLmxvZ2dlcik7dGhpcy5kZXN0aW5hdGlvbnNFdmVudHNRdWV1ZT10aGlzLnBsdWdpbnNNYW5hZ2VyLmludm9rZVNpbmdsZShgJHtERVNUSU5BVElPTlNfUVVFVUVfRVhUX1BPSU5UX1BSRUZJWH0uaW5pdGAsc3RhdGUsdGhpcy5wbHVnaW5zTWFuYWdlcix0aGlzLnN0b3JlTWFuYWdlcix0aGlzLmRtdEV2ZW50c1F1ZXVlLHRoaXMuZXJyb3JIYW5kbGVyLHRoaXMubG9nZ2VyKTsvLyBTdGFydCB0aGUgcXVldWUgb25jZSB0aGUgY2xpZW50IGRlc3RpbmF0aW9ucyBhcmUgcmVhZHlcbkUoKCk9PntpZihzdGF0ZS5uYXRpdmVEZXN0aW5hdGlvbnMuY2xpZW50RGVzdGluYXRpb25zUmVhZHkudmFsdWU9PT10cnVlKXt0aGlzLmRlc3RpbmF0aW9uc0V2ZW50c1F1ZXVlPy5zdGFydCgpO3RoaXMuZG10RXZlbnRzUXVldWU/LnN0YXJ0KCk7fX0pO2NvbnN0IGJ1ZmZlckV2ZW50c0JlZm9yZUNvbnNlbnQ9c2hvdWxkQnVmZmVyRXZlbnRzRm9yUHJlQ29uc2VudChzdGF0ZSk7Ly8gU3RhcnQgdGhlIHF1ZXVlIHByb2Nlc3Npbmcgb25seSB3aGVuIHRoZSBkZXN0aW5hdGlvbnMgYXJlIHJlYWR5IG9yIGh5YnJpZCBtb2RlIGRlc3RpbmF0aW9ucyBleGlzdFxuLy8gSG93ZXZlciwgZXZlbnRzIHdpbGwgYmUgZW5xdWV1ZWQgZm9yIG5vdy5cbi8vIEF0IHRoZSB0aW1lIG9mIHByb2Nlc3NpbmcgdGhlIGV2ZW50cywgdGhlIGludGVncmF0aW9ucyBjb25maWcgZGF0YSBmcm9tIGRlc3RpbmF0aW9uc1xuLy8gaXMgbWVyZ2VkIGludG8gdGhlIGV2ZW50IG9iamVjdFxubGV0IHRpbWVvdXRJZDtFKCgpPT57Y29uc3Qgc2hvdWxkQnVmZmVyRHBFdmVudHM9c3RhdGUubG9hZE9wdGlvbnMudmFsdWUuYnVmZmVyRGF0YVBsYW5lRXZlbnRzVW50aWxSZWFkeT09PXRydWUmJnN0YXRlLm5hdGl2ZURlc3RpbmF0aW9ucy5jbGllbnREZXN0aW5hdGlvbnNSZWFkeS52YWx1ZT09PWZhbHNlO2NvbnN0IGh5YnJpZERlc3RFeGlzdD1zdGF0ZS5uYXRpdmVEZXN0aW5hdGlvbnMuYWN0aXZlRGVzdGluYXRpb25zLnZhbHVlLnNvbWUoZGVzdD0+aXNIeWJyaWRNb2RlRGVzdGluYXRpb24oZGVzdCkpO2lmKChoeWJyaWREZXN0RXhpc3Q9PT1mYWxzZXx8c2hvdWxkQnVmZmVyRHBFdmVudHM9PT1mYWxzZSkmJiFidWZmZXJFdmVudHNCZWZvcmVDb25zZW50JiZ0aGlzLmRhdGFwbGFuZUV2ZW50c1F1ZXVlPy5zY2hlZHVsZVRpbWVvdXRBY3RpdmUhPT10cnVlKXtnbG9iYWxUaGlzLmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO3RoaXMuZGF0YXBsYW5lRXZlbnRzUXVldWU/LnN0YXJ0KCk7fX0pOy8vIEZvcmNlIHN0YXJ0IHRoZSBkYXRhIHBsYW5lIGV2ZW50cyBxdWV1ZSBwcm9jZXNzaW5nIGFmdGVyIGEgdGltZW91dFxuaWYoc3RhdGUubG9hZE9wdGlvbnMudmFsdWUuYnVmZmVyRGF0YVBsYW5lRXZlbnRzVW50aWxSZWFkeT09PXRydWUpe3RpbWVvdXRJZD1nbG9iYWxUaGlzLnNldFRpbWVvdXQoKCk9PntpZih0aGlzLmRhdGFwbGFuZUV2ZW50c1F1ZXVlPy5zY2hlZHVsZVRpbWVvdXRBY3RpdmUhPT10cnVlKXt0aGlzLmRhdGFwbGFuZUV2ZW50c1F1ZXVlPy5zdGFydCgpO319LHN0YXRlLmxvYWRPcHRpb25zLnZhbHVlLmRhdGFQbGFuZUV2ZW50c0J1ZmZlclRpbWVvdXQpO319cmVzdW1lKCl7aWYodGhpcy5kYXRhcGxhbmVFdmVudHNRdWV1ZT8uc2NoZWR1bGVUaW1lb3V0QWN0aXZlIT09dHJ1ZSl7aWYoc3RhdGUuY29uc2VudHMucG9zdENvbnNlbnQudmFsdWUuZGlzY2FyZFByZUNvbnNlbnRFdmVudHMpe3RoaXMuZGF0YXBsYW5lRXZlbnRzUXVldWU/LmNsZWFyKCk7dGhpcy5kZXN0aW5hdGlvbnNFdmVudHNRdWV1ZT8uY2xlYXIoKTt9dGhpcy5kYXRhcGxhbmVFdmVudHNRdWV1ZT8uc3RhcnQoKTt9fS8qKlxuICAgKiBFbnF1ZXVlcyB0aGUgZXZlbnQgZm9yIHByb2Nlc3NpbmdcbiAgICogQHBhcmFtIGV2ZW50IFJ1ZGRlckV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgQVBJIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL2VucXVldWUoZXZlbnQsY2FsbGJhY2spe2NvbnN0IGRwUUV2ZW50PWdldEZpbmFsRXZlbnQoZXZlbnQsc3RhdGUpO3RoaXMucGx1Z2luc01hbmFnZXIuaW52b2tlU2luZ2xlKGAke0RBVEFfUExBTkVfUVVFVUVfRVhUX1BPSU5UX1BSRUZJWH0uZW5xdWV1ZWAsc3RhdGUsdGhpcy5kYXRhcGxhbmVFdmVudHNRdWV1ZSxkcFFFdmVudCx0aGlzLmVycm9ySGFuZGxlcix0aGlzLmxvZ2dlcik7Y29uc3QgZFFFdmVudD1jbG9uZShldmVudCk7dGhpcy5wbHVnaW5zTWFuYWdlci5pbnZva2VTaW5nbGUoYCR7REVTVElOQVRJT05TX1FVRVVFX0VYVF9QT0lOVF9QUkVGSVh9LmVucXVldWVgLHN0YXRlLHRoaXMuZGVzdGluYXRpb25zRXZlbnRzUXVldWUsZFFFdmVudCx0aGlzLmVycm9ySGFuZGxlcix0aGlzLmxvZ2dlcik7Ly8gSW52b2tlIHRoZSBjYWxsYmFjayBpZiBpdCBleGlzdHNcbmNvbnN0IGFwaU5hbWU9YCR7ZXZlbnQudHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke2V2ZW50LnR5cGUuc2xpY2UoMSl9JHtBUElfU1VGRklYfWA7c2FmZWx5SW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssW2RwUUV2ZW50XSxhcGlOYW1lLHRoaXMubG9nZ2VyKTt9fVxuXG5jb25zdCBkaXNwYXRjaFNES0V2ZW50PWV2ZW50PT57Y29uc3QgY3VzdG9tRXZlbnQ9bmV3IEN1c3RvbUV2ZW50KGV2ZW50LHtkZXRhaWw6e2FuYWx5dGljc0luc3RhbmNlOmdsb2JhbFRoaXMucnVkZGVyYW5hbHl0aWNzfSxidWJibGVzOnRydWUsY2FuY2VsYWJsZTp0cnVlLGNvbXBvc2VkOnRydWV9KTtnbG9iYWxUaGlzLmRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY3VzdG9tRXZlbnQpO307Y29uc3QgaXNXcml0ZUtleVZhbGlkPXdyaXRlS2V5PT5pc1N0cmluZyh3cml0ZUtleSkmJndyaXRlS2V5LnRyaW0oKS5sZW5ndGg+MDtjb25zdCBpc0RhdGFQbGFuZVVybFZhbGlkPWRhdGFQbGFuZVVybD0+aXNWYWxpZFVSTChkYXRhUGxhbmVVcmwpO1xuXG4vKlxuICogQW5hbHl0aWNzIGNsYXNzIHdpdGggbGlmZWN5Y2xlIGJhc2VkIG9uIHN0YXRlIGFkIHVzZXIgdHJpZ2dlcmVkIGV2ZW50c1xuICovY2xhc3MgQW5hbHl0aWNzey8qKlxuICAgKiBJbml0aWFsaXplIHNlcnZpY2VzIGFuZCBjb21wb25lbnRzIG9yIHVzZSBkZWZhdWx0IG9uZXMgaWYgc2luZ2xldG9uc1xuICAgKi9jb25zdHJ1Y3Rvcigpe3RoaXMucHJlbG9hZEJ1ZmZlcj1uZXcgQnVmZmVyUXVldWUoKTt0aGlzLmluaXRpYWxpemVkPWZhbHNlO3RoaXMuZXJyb3JIYW5kbGVyPWRlZmF1bHRFcnJvckhhbmRsZXI7dGhpcy5sb2dnZXI9ZGVmYXVsdExvZ2dlcjt0aGlzLmV4dGVybmFsU3JjTG9hZGVyPW5ldyBFeHRlcm5hbFNyY0xvYWRlcih0aGlzLmxvZ2dlcik7dGhpcy5odHRwQ2xpZW50PWRlZmF1bHRIdHRwQ2xpZW50O3RoaXMuaHR0cENsaWVudC5pbml0KHRoaXMuZXJyb3JIYW5kbGVyKTt0aGlzLmNhcGFiaWxpdGllc01hbmFnZXI9bmV3IENhcGFiaWxpdGllc01hbmFnZXIodGhpcy5odHRwQ2xpZW50LHRoaXMuZXJyb3JIYW5kbGVyLHRoaXMubG9nZ2VyKTt9LyoqXG4gICAqIFN0YXJ0IGFwcGxpY2F0aW9uIGxpZmVjeWNsZSBpZiBub3QgYWxyZWFkeSBzdGFydGVkXG4gICAqL2xvYWQod3JpdGVLZXksZGF0YVBsYW5lVXJsLGxvYWRPcHRpb25zPXt9KXtpZihzdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlKXtyZXR1cm47fWlmKCFpc1dyaXRlS2V5VmFsaWQod3JpdGVLZXkpKXt0aGlzLmxvZ2dlci5lcnJvcihXUklURV9LRVlfVkFMSURBVElPTl9FUlJPUihBTkFMWVRJQ1NfQ09SRSx3cml0ZUtleSkpO3JldHVybjt9aWYoIWlzRGF0YVBsYW5lVXJsVmFsaWQoZGF0YVBsYW5lVXJsKSl7dGhpcy5sb2dnZXIuZXJyb3IoREFUQV9QTEFORV9VUkxfVkFMSURBVElPTl9FUlJPUihBTkFMWVRJQ1NfQ09SRSxkYXRhUGxhbmVVcmwpKTtyZXR1cm47fS8vIFNldCBpbml0aWFsIHN0YXRlIHZhbHVlc1xucigoKT0+e3N0YXRlLmxpZmVjeWNsZS53cml0ZUtleS52YWx1ZT1jbG9uZSh3cml0ZUtleSk7c3RhdGUubGlmZWN5Y2xlLmRhdGFQbGFuZVVybC52YWx1ZT1jbG9uZShkYXRhUGxhbmVVcmwpO3N0YXRlLmxvYWRPcHRpb25zLnZhbHVlPW5vcm1hbGl6ZUxvYWRPcHRpb25zKHN0YXRlLmxvYWRPcHRpb25zLnZhbHVlLGxvYWRPcHRpb25zKTtzdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlPSdtb3VudGVkJzt9KTsvLyBzZXQgbG9nIGxldmVsIGFzIGVhcmx5IGFzIHBvc3NpYmxlXG50aGlzLmxvZ2dlci5zZXRNaW5Mb2dMZXZlbChzdGF0ZS5sb2FkT3B0aW9ucy52YWx1ZS5sb2dMZXZlbD8/UE9TVF9MT0FEX0xPR19MRVZFTCk7Ly8gRXhwb3NlIHN0YXRlIHRvIGdsb2JhbCBvYmplY3RzXG5zZXRFeHBvc2VkR2xvYmFsKCdzdGF0ZScsc3RhdGUsd3JpdGVLZXkpOy8vIENvbmZpZ3VyZSBpbml0aWFsIGNvbmZpZyBvZiBhbnkgc2VydmljZXMgb3IgY29tcG9uZW50cyBoZXJlXG4vLyBTdGF0ZSBhcHBsaWNhdGlvbiBsaWZlY3ljbGVcbnRoaXMuc3RhcnRMaWZlY3ljbGUoKTt9Ly8gU3RhcnQgbGlmZWN5Y2xlIG1ldGhvZHNcbi8qKlxuICAgKiBPcmNoZXN0cmF0ZSB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBhcHBsaWNhdGlvbiBwaGFzZXMvc3RhdHVzXG4gICAqL3N0YXJ0TGlmZWN5Y2xlKCl7RSgoKT0+e3RyeXtzd2l0Y2goc3RhdGUubGlmZWN5Y2xlLnN0YXR1cy52YWx1ZSl7Y2FzZSAnbW91bnRlZCc6dGhpcy5vbk1vdW50ZWQoKTticmVhaztjYXNlICdicm93c2VyQ2FwYWJpbGl0aWVzUmVhZHknOnRoaXMub25Ccm93c2VyQ2FwYWJpbGl0aWVzUmVhZHkoKTticmVhaztjYXNlICdjb25maWd1cmVkJzp0aGlzLm9uQ29uZmlndXJlZCgpO2JyZWFrO2Nhc2UgJ3BsdWdpbnNMb2FkaW5nJzpicmVhaztjYXNlICdwbHVnaW5zUmVhZHknOnRoaXMub25QbHVnaW5zUmVhZHkoKTticmVhaztjYXNlICdpbml0aWFsaXplZCc6dGhpcy5vbkluaXRpYWxpemVkKCk7YnJlYWs7Y2FzZSAnbG9hZGVkJzp0aGlzLm9uTG9hZGVkKCk7YnJlYWs7Y2FzZSAnZGVzdGluYXRpb25zTG9hZGluZyc6YnJlYWs7Y2FzZSAnZGVzdGluYXRpb25zUmVhZHknOnRoaXMub25EZXN0aW5hdGlvbnNSZWFkeSgpO2JyZWFrO2Nhc2UgJ3JlYWR5Jzp0aGlzLm9uUmVhZHkoKTticmVhaztjYXNlICdyZWFkeUV4ZWN1dGVkJzpkZWZhdWx0OmJyZWFrO319Y2F0Y2goZXJyKXtjb25zdCBpc3N1ZT0nRmFpbGVkIHRvIGxvYWQgdGhlIFNESyc7dGhpcy5lcnJvckhhbmRsZXIub25FcnJvcih7ZXJyb3I6ZXJyLGNvbnRleHQ6QU5BTFlUSUNTX0NPUkUsY3VzdG9tTWVzc2FnZTppc3N1ZSxncm91cGluZ0hhc2g6aXNzdWV9KTt9fSk7fW9uQnJvd3NlckNhcGFiaWxpdGllc1JlYWR5KCl7Ly8gaW5pdGlhbGl6ZSB0aGUgcHJlbG9hZGVkIGV2ZW50cyBlbnF1ZXVpbmdcbnJldHJpZXZlUHJlbG9hZEJ1ZmZlckV2ZW50cyh0aGlzKTt0aGlzLnByZXBhcmVJbnRlcm5hbFNlcnZpY2VzKCk7dGhpcy5sb2FkQ29uZmlnKCk7fW9uTG9hZGVkKCl7dGhpcy5wcm9jZXNzQnVmZmVyZWRFdmVudHMoKTsvLyBTaG9ydC1jaXJjdWl0IHRoZSBsaWZlIGN5Y2xlIGFuZCBtb3ZlIHRvIHRoZSByZWFkeSBzdGF0ZSBpZiBwcmUtY29uc2VudCBiZWhhdmlvciBpcyBlbmFibGVkXG5pZihzdGF0ZS5jb25zZW50cy5wcmVDb25zZW50LnZhbHVlLmVuYWJsZWQ9PT10cnVlKXtzdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlPSdyZWFkeSc7fWVsc2Uge3RoaXMubG9hZERlc3RpbmF0aW9ucygpO319LyoqXG4gICAqIExvYWQgYnJvd3NlciBwb2x5ZmlsbCBpZiByZXF1aXJlZFxuICAgKi9vbk1vdW50ZWQoKXt0aGlzLmNhcGFiaWxpdGllc01hbmFnZXIuaW5pdCgpO30vKipcbiAgICogRW5xdWV1ZSBpbiBTREsgcHJlbG9hZCBidWZmZXIgZXZlbnRzLCB1c2VkIGZyb20gcHJlbG9hZEJ1ZmZlciBjb21wb25lbnRcbiAgICovZW5xdWV1ZVByZWxvYWRCdWZmZXJFdmVudHMoYnVmZmVyZWRFdmVudHMpe2lmKEFycmF5LmlzQXJyYXkoYnVmZmVyZWRFdmVudHMpKXtidWZmZXJlZEV2ZW50cy5mb3JFYWNoKGJ1ZmZlcmVkRXZlbnQ9PnRoaXMucHJlbG9hZEJ1ZmZlci5lbnF1ZXVlKGNsb25lKGJ1ZmZlcmVkRXZlbnQpKSk7fX0vKipcbiAgICogUHJvY2VzcyB0aGUgYnVmZmVyIHByZWxvYWRlZCBldmVudHMgYnkgcGFzc2luZyB0aGVpciBhcmd1bWVudHMgdG8gdGhlIHJlc3BlY3RpdmUgZmFjYWRlIG1ldGhvZHNcbiAgICovcHJvY2Vzc0RhdGFJblByZWxvYWRCdWZmZXIoKXt3aGlsZSh0aGlzLnByZWxvYWRCdWZmZXIuc2l6ZSgpPjApe2NvbnN0IGV2ZW50VG9Qcm9jZXNzPXRoaXMucHJlbG9hZEJ1ZmZlci5kZXF1ZXVlKCk7aWYoZXZlbnRUb1Byb2Nlc3Mpe2NvbnN1bWVQcmVsb2FkQnVmZmVyZWRFdmVudChbLi4uZXZlbnRUb1Byb2Nlc3NdLHRoaXMpO319fXByZXBhcmVJbnRlcm5hbFNlcnZpY2VzKCl7dGhpcy5wbHVnaW5zTWFuYWdlcj1uZXcgUGx1Z2luc01hbmFnZXIoZGVmYXVsdFBsdWdpbkVuZ2luZSx0aGlzLmVycm9ySGFuZGxlcix0aGlzLmxvZ2dlcik7dGhpcy5zdG9yZU1hbmFnZXI9bmV3IFN0b3JlTWFuYWdlcih0aGlzLnBsdWdpbnNNYW5hZ2VyLHRoaXMuZXJyb3JIYW5kbGVyLHRoaXMubG9nZ2VyKTt0aGlzLmNvbmZpZ01hbmFnZXI9bmV3IENvbmZpZ01hbmFnZXIodGhpcy5odHRwQ2xpZW50LHRoaXMuZXJyb3JIYW5kbGVyLHRoaXMubG9nZ2VyKTt0aGlzLnVzZXJTZXNzaW9uTWFuYWdlcj1uZXcgVXNlclNlc3Npb25NYW5hZ2VyKHRoaXMucGx1Z2luc01hbmFnZXIsdGhpcy5zdG9yZU1hbmFnZXIsdGhpcy5odHRwQ2xpZW50LHRoaXMuZXJyb3JIYW5kbGVyLHRoaXMubG9nZ2VyKTt0aGlzLmV2ZW50UmVwb3NpdG9yeT1uZXcgRXZlbnRSZXBvc2l0b3J5KHRoaXMucGx1Z2luc01hbmFnZXIsdGhpcy5zdG9yZU1hbmFnZXIsdGhpcy5odHRwQ2xpZW50LHRoaXMuZXJyb3JIYW5kbGVyLHRoaXMubG9nZ2VyKTt0aGlzLmV2ZW50TWFuYWdlcj1uZXcgRXZlbnRNYW5hZ2VyKHRoaXMuZXZlbnRSZXBvc2l0b3J5LHRoaXMudXNlclNlc3Npb25NYW5hZ2VyLHRoaXMuZXJyb3JIYW5kbGVyLHRoaXMubG9nZ2VyKTt9LyoqXG4gICAqIExvYWQgY29uZmlndXJhdGlvblxuICAgKi9sb2FkQ29uZmlnKCl7aWYoc3RhdGUubGlmZWN5Y2xlLndyaXRlS2V5LnZhbHVlKXt0aGlzLmh0dHBDbGllbnQuc2V0QXV0aEhlYWRlcihzdGF0ZS5saWZlY3ljbGUud3JpdGVLZXkudmFsdWUpO310aGlzLmNvbmZpZ01hbmFnZXI/LmluaXQoKTt9LyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHN0b3JhZ2UgYW5kIGV2ZW50IHF1ZXVlXG4gICAqL29uUGx1Z2luc1JlYWR5KCl7Ly8gSW5pdGlhbGl6ZSBzdG9yYWdlXG50aGlzLnN0b3JlTWFuYWdlcj8uaW5pdCgpO3RoaXMudXNlclNlc3Npb25NYW5hZ2VyPy5pbml0KCk7Ly8gSW5pdGlhbGl6ZSB0aGUgYXBwcm9wcmlhdGUgY29uc2VudCBtYW5hZ2VyIHBsdWdpblxuaWYoc3RhdGUuY29uc2VudHMuZW5hYmxlZC52YWx1ZSYmIXN0YXRlLmNvbnNlbnRzLmluaXRpYWxpemVkLnZhbHVlKXt0aGlzLnBsdWdpbnNNYW5hZ2VyPy5pbnZva2VTaW5nbGUoYGNvbnNlbnRNYW5hZ2VyLmluaXRgLHN0YXRlLHRoaXMubG9nZ2VyKTtpZihzdGF0ZS5jb25zZW50cy5wcmVDb25zZW50LnZhbHVlLmVuYWJsZWQ9PT1mYWxzZSl7dGhpcy5wbHVnaW5zTWFuYWdlcj8uaW52b2tlU2luZ2xlKGBjb25zZW50TWFuYWdlci51cGRhdGVDb25zZW50c0luZm9gLHN0YXRlLHRoaXMuc3RvcmVNYW5hZ2VyLHRoaXMubG9nZ2VyKTt9fS8vIEluaXRpYWxpemUgZXZlbnQgbWFuYWdlclxudGhpcy5ldmVudE1hbmFnZXI/LmluaXQoKTsvLyBNYXJrIHRoZSBTREsgYXMgaW5pdGlhbGl6ZWRcbnN0YXRlLmxpZmVjeWNsZS5zdGF0dXMudmFsdWU9J2luaXRpYWxpemVkJzt9LyoqXG4gICAqIExvYWQgcGx1Z2luc1xuICAgKi9vbkNvbmZpZ3VyZWQoKXt0aGlzLnBsdWdpbnNNYW5hZ2VyPy5pbml0KCk7Ly8gVE9ETzogYXJlIHdlIGdvaW5nIHRvIGVuYWJsZSBjdXN0b20gcGx1Z2lucyB0byBiZSBwYXNzZWQgYXMgbG9hZCBvcHRpb25zP1xuLy8gcmVnaXN0ZXJDdXN0b21QbHVnaW5zKHN0YXRlLmxvYWRPcHRpb25zLnZhbHVlLmN1c3RvbVBsdWdpbnMpO1xufS8qKlxuICAgKiBUcmlnZ2VyIG9uTG9hZGVkIGNhbGxiYWNrIGlmIGFueSBpcyBwcm92aWRlZCBpbiBjb25maWcgJiBlbWl0IGluaXRpYWxpc2VkIGV2ZW50XG4gICAqL29uSW5pdGlhbGl6ZWQoKXsvLyBQcm9jZXNzIGFueSBwcmVsb2FkZWQgZXZlbnRzXG50aGlzLnByb2Nlc3NEYXRhSW5QcmVsb2FkQnVmZmVyKCk7Ly8gU2V0IGxpZmVjeWNsZSBzdGF0ZVxucigoKT0+e3N0YXRlLmxpZmVjeWNsZS5sb2FkZWQudmFsdWU9dHJ1ZTtzdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlPSdsb2FkZWQnO30pO3RoaXMuaW5pdGlhbGl6ZWQ9dHJ1ZTsvLyBFeGVjdXRlIG9uTG9hZGVkIGNhbGxiYWNrIGlmIHByb3ZpZGVkIGluIGxvYWQgb3B0aW9uc1xuY29uc3Qgb25Mb2FkZWRDYWxsYmFja0ZuPXN0YXRlLmxvYWRPcHRpb25zLnZhbHVlLm9uTG9hZGVkOy8vIFRPRE86IHdlIG5lZWQgdG8gYXZvaWQgcGFzc2luZyB0aGUgd2luZG93IG9iamVjdCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbi8vIGFzIHRoaXMgd2lsbCBwcmV2ZW50IHVzIGZyb20gc3VwcG9ydGluZyBtdWx0aXBsZSBTREsgaW5zdGFuY2VzIGluIHRoZSBzYW1lIHBhZ2VcbnNhZmVseUludm9rZUNhbGxiYWNrKG9uTG9hZGVkQ2FsbGJhY2tGbixbZ2xvYmFsVGhpcy5ydWRkZXJhbmFseXRpY3NdLExPQURfQVBJLHRoaXMubG9nZ2VyKTsvLyBFbWl0IGFuIGV2ZW50IHRvIHVzZSBhcyBzdWJzdGl0dXRlIHRvIHRoZSBvbkxvYWRlZCBjYWxsYmFja1xuZGlzcGF0Y2hTREtFdmVudCgnUlNBX0luaXRpYWxpc2VkJyk7fS8qKlxuICAgKiBFbWl0IHJlYWR5IGV2ZW50XG4gICAqLy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5vblJlYWR5KCl7c3RhdGUubGlmZWN5Y2xlLnN0YXR1cy52YWx1ZT0ncmVhZHlFeGVjdXRlZCc7c3RhdGUuZXZlbnRCdWZmZXIucmVhZHlDYWxsYmFja3NBcnJheS52YWx1ZS5mb3JFYWNoKGNhbGxiYWNrPT57c2FmZWx5SW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssW10sUkVBRFlfQVBJLHRoaXMubG9nZ2VyKTt9KTsvLyBFbWl0IGFuIGV2ZW50IHRvIHVzZSBhcyBzdWJzdGl0dXRlIHRvIHRoZSByZWFkeSBjYWxsYmFja1xuZGlzcGF0Y2hTREtFdmVudCgnUlNBX1JlYWR5Jyk7fS8qKlxuICAgKiBDb25zdW1lIHByZWxvYWRlZCBldmVudHMgYnVmZmVyXG4gICAqL3Byb2Nlc3NCdWZmZXJlZEV2ZW50cygpey8vIFRoaXMgbG9naWMgaGFzIGJlZW4gaW50ZW50aW9uYWxseSBpbXBsZW1lbnRlZCB3aXRob3V0IGEgc2ltcGxlXG4vLyBmb3ItbG9vcCBhcyB0aGUgaW5kaXZpZHVhbCBldmVudHMgdGhhdCBhcmUgcHJvY2Vzc2VkIG1heVxuLy8gYWRkIG1vcmUgZXZlbnRzIHRvIHRoZSBidWZmZXIgKHRoaXMgaXMgbmVlZGVkIGZvciB0aGUgY29uc2VudCBBUEkpXG5sZXQgYnVmZmVyZWRFdmVudHM9c3RhdGUuZXZlbnRCdWZmZXIudG9CZVByb2Nlc3NlZEFycmF5LnZhbHVlO3doaWxlKGJ1ZmZlcmVkRXZlbnRzLmxlbmd0aD4wKXtjb25zdCBidWZmZXJlZEV2ZW50PWJ1ZmZlcmVkRXZlbnRzLnNoaWZ0KCk7c3RhdGUuZXZlbnRCdWZmZXIudG9CZVByb2Nlc3NlZEFycmF5LnZhbHVlPWJ1ZmZlcmVkRXZlbnRzO2lmKGJ1ZmZlcmVkRXZlbnQpe2NvbnN0IG1ldGhvZE5hbWU9YnVmZmVyZWRFdmVudFswXTtpZihpc0Z1bmN0aW9uKHRoaXNbbWV0aG9kTmFtZV0pKXsvLyBTZW5kIGFkZGl0aW9uYWwgYXJnICd0cnVlJyB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgaXMgYSBidWZmZXJlZCBpbnZvY2F0aW9uXG50aGlzW21ldGhvZE5hbWVdKC4uLmJ1ZmZlcmVkRXZlbnQuc2xpY2UoMSksdHJ1ZSk7fX1idWZmZXJlZEV2ZW50cz1zdGF0ZS5ldmVudEJ1ZmZlci50b0JlUHJvY2Vzc2VkQXJyYXkudmFsdWU7fX0vKipcbiAgICogTG9hZCBkZXZpY2UgbW9kZSBkZXN0aW5hdGlvbnNcbiAgICovbG9hZERlc3RpbmF0aW9ucygpey8vIElmIHRoZSBpbnRlZ3JhdGlvbnMgbG9hZCBpcyBhbHJlYWR5IHRyaWdnZXJlZCBvciBjb21wbGV0ZWQsIHNraXAgdGhlIHJlc3Qgb2YgdGhlIGxvZ2ljXG5pZihzdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlPT09J2Rlc3RpbmF0aW9uc0xvYWRpbmcnfHxzdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlPT09J2Rlc3RpbmF0aW9uc1JlYWR5Jyl7cmV0dXJuO30vLyBTZXQgaW4gc3RhdGUgdGhlIGRlc2lyZWQgYWN0aXZlRGVzdGluYXRpb25zIHRvIGluamVjdCBpbiBET01cbnRoaXMucGx1Z2luc01hbmFnZXI/Lmludm9rZVNpbmdsZSgnbmF0aXZlRGVzdGluYXRpb25zLnNldEFjdGl2ZURlc3RpbmF0aW9ucycsc3RhdGUsdGhpcy5wbHVnaW5zTWFuYWdlcix0aGlzLmVycm9ySGFuZGxlcix0aGlzLmxvZ2dlcik7Y29uc3QgdG90YWxEZXN0aW5hdGlvbnNUb0xvYWQ9c3RhdGUubmF0aXZlRGVzdGluYXRpb25zLmFjdGl2ZURlc3RpbmF0aW9ucy52YWx1ZS5sZW5ndGg7aWYodG90YWxEZXN0aW5hdGlvbnNUb0xvYWQ9PT0wKXtzdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlPSdkZXN0aW5hdGlvbnNSZWFkeSc7cmV0dXJuO30vLyBTdGFydCBsb2FkaW5nIG5hdGl2ZSBpbnRlZ3JhdGlvbiBzY3JpcHRzIGFuZCBjcmVhdGUgaW5zdGFuY2VzXG5zdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlPSdkZXN0aW5hdGlvbnNMb2FkaW5nJzt0aGlzLnBsdWdpbnNNYW5hZ2VyPy5pbnZva2VTaW5nbGUoJ25hdGl2ZURlc3RpbmF0aW9ucy5sb2FkJyxzdGF0ZSx0aGlzLmV4dGVybmFsU3JjTG9hZGVyLHRoaXMuZXJyb3JIYW5kbGVyLHRoaXMubG9nZ2VyKTsvLyBQcm9ncmVzcyB0byBuZXh0IGxpZmVjeWNsZSBwaGFzZSBpZiBhbGwgbmF0aXZlIGRlc3RpbmF0aW9ucyBhcmUgaW5pdGlhbGl6ZWQgb3IgZmFpbGVkXG5FKCgpPT57Y29uc3QgYXJlQWxsRGVzdGluYXRpb25zUmVhZHk9dG90YWxEZXN0aW5hdGlvbnNUb0xvYWQ9PT0wfHxzdGF0ZS5uYXRpdmVEZXN0aW5hdGlvbnMuaW5pdGlhbGl6ZWREZXN0aW5hdGlvbnMudmFsdWUubGVuZ3RoK3N0YXRlLm5hdGl2ZURlc3RpbmF0aW9ucy5mYWlsZWREZXN0aW5hdGlvbnMudmFsdWUubGVuZ3RoPT09dG90YWxEZXN0aW5hdGlvbnNUb0xvYWQ7aWYoYXJlQWxsRGVzdGluYXRpb25zUmVhZHkpe3IoKCk9PntzdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlPSdkZXN0aW5hdGlvbnNSZWFkeSc7c3RhdGUubmF0aXZlRGVzdGluYXRpb25zLmNsaWVudERlc3RpbmF0aW9uc1JlYWR5LnZhbHVlPXRydWU7fSk7fX0pO30vKipcbiAgICogTW92ZSB0byB0aGUgcmVhZHkgc3RhdGVcbiAgICovLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbm9uRGVzdGluYXRpb25zUmVhZHkoKXsvLyBNYXkgYmUgZG8gYW55IGRlc3RpbmF0aW9uIHNwZWNpZmljIGFjdGlvbnMgaGVyZVxuLy8gTWFyayB0aGUgcmVhZHkgc3RhdHVzIGlmIG5vdCBhbHJlYWR5IGRvbmVcbmlmKHN0YXRlLmxpZmVjeWNsZS5zdGF0dXMudmFsdWUhPT0ncmVhZHknKXtzdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlPSdyZWFkeSc7fX0vLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZHNcbi8vIFN0YXJ0IGNvbnN1bWVyIGV4cG9zZWQgbWV0aG9kc1xucmVhZHkoY2FsbGJhY2ssaXNCdWZmZXJlZEludm9jYXRpb249ZmFsc2Upe2NvbnN0IHR5cGU9J3JlYWR5JztpZighc3RhdGUubGlmZWN5Y2xlLmxvYWRlZC52YWx1ZSl7c3RhdGUuZXZlbnRCdWZmZXIudG9CZVByb2Nlc3NlZEFycmF5LnZhbHVlPVsuLi5zdGF0ZS5ldmVudEJ1ZmZlci50b0JlUHJvY2Vzc2VkQXJyYXkudmFsdWUsW3R5cGUsY2FsbGJhY2tdXTtyZXR1cm47fXRoaXMuZXJyb3JIYW5kbGVyLmxlYXZlQnJlYWRjcnVtYihgTmV3ICR7dHlwZX0gaW52b2NhdGlvbmApO2lmKCFpc0Z1bmN0aW9uKGNhbGxiYWNrKSl7dGhpcy5sb2dnZXIuZXJyb3IoSU5WQUxJRF9DQUxMQkFDS19GTl9FUlJPUihSRUFEWV9BUEkpKTtyZXR1cm47fS8qKlxuICAgICAqIElmIGRlc3RpbmF0aW9ucyBhcmUgbG9hZGVkIG9yIG5vIGludGVncmF0aW9uIGlzIGF2YWlsYWJsZSBmb3IgbG9hZGluZ1xuICAgICAqIGV4ZWN1dGUgdGhlIGNhbGxiYWNrIGltbWVkaWF0ZWx5IGVsc2UgcHVzaCB0aGUgY2FsbGJhY2tzIHRvIGEgcXVldWUgdGhhdFxuICAgICAqIHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgbG9hZGluZyBjb21wbGV0ZXNcbiAgICAgKi9pZihzdGF0ZS5saWZlY3ljbGUuc3RhdHVzLnZhbHVlPT09J3JlYWR5RXhlY3V0ZWQnKXtzYWZlbHlJbnZva2VDYWxsYmFjayhjYWxsYmFjayxbXSxSRUFEWV9BUEksdGhpcy5sb2dnZXIpO31lbHNlIHtzdGF0ZS5ldmVudEJ1ZmZlci5yZWFkeUNhbGxiYWNrc0FycmF5LnZhbHVlPVsuLi5zdGF0ZS5ldmVudEJ1ZmZlci5yZWFkeUNhbGxiYWNrc0FycmF5LnZhbHVlLGNhbGxiYWNrXTt9fXBhZ2UocGF5bG9hZCxpc0J1ZmZlcmVkSW52b2NhdGlvbj1mYWxzZSl7Y29uc3QgdHlwZT0ncGFnZSc7aWYoIXN0YXRlLmxpZmVjeWNsZS5sb2FkZWQudmFsdWUpe3N0YXRlLmV2ZW50QnVmZmVyLnRvQmVQcm9jZXNzZWRBcnJheS52YWx1ZT1bLi4uc3RhdGUuZXZlbnRCdWZmZXIudG9CZVByb2Nlc3NlZEFycmF5LnZhbHVlLFt0eXBlLHBheWxvYWRdXTtyZXR1cm47fXRoaXMuZXJyb3JIYW5kbGVyLmxlYXZlQnJlYWRjcnVtYihgTmV3ICR7dHlwZX0gZXZlbnRgKTtzdGF0ZS5tZXRyaWNzLnRyaWdnZXJlZC52YWx1ZSs9MTt0aGlzLmV2ZW50TWFuYWdlcj8uYWRkRXZlbnQoe3R5cGU6J3BhZ2UnLGNhdGVnb3J5OnBheWxvYWQuY2F0ZWdvcnksbmFtZTpwYXlsb2FkLm5hbWUscHJvcGVydGllczpwYXlsb2FkLnByb3BlcnRpZXMsb3B0aW9uczpwYXlsb2FkLm9wdGlvbnMsY2FsbGJhY2s6cGF5bG9hZC5jYWxsYmFja30pOy8vIFRPRE86IE1heWJlIHdlIHNob3VsZCBhbHRlciB0aGUgYmVoYXZpb3IgdG8gc2VuZCB0aGUgYWQtYmxvY2sgcGFnZSBldmVudCBldmVuIGlmIHRoZSBTREsgaXMgc3RpbGwgbG9hZGVkLiBJdCdsbCBiZSBwdXNoZWQgaW50byB0aGUgdG8gYmUgcHJvY2Vzc2VkIHF1ZXVlLlxuLy8gU2VuZCBhdXRvbWF0aWMgYWQgYmxvY2tlZCBwYWdlIGV2ZW50IGlmIGFkLWJsb2NrZXJzIGFyZSBkZXRlY3RlZCBvbiB0aGUgcGFnZVxuLy8gQ2hlY2sgcGFnZSBjYXRlZ29yeSB0byBhdm9pZCBpbmZpbml0ZSBsb29wXG5pZihzdGF0ZS5jYXBhYmlsaXRpZXMuaXNBZEJsb2NrZWQudmFsdWU9PT10cnVlJiZwYXlsb2FkLmNhdGVnb3J5IT09QURCTE9DS19QQUdFX0NBVEVHT1JZKXt0aGlzLnBhZ2UocGFnZUFyZ3VtZW50c1RvQ2FsbE9wdGlvbnMoQURCTE9DS19QQUdFX0NBVEVHT1JZLEFEQkxPQ0tfUEFHRV9OQU1FLHsvLyAndGl0bGUnIGlzIGludGVudGlvbmFsbHkgb21pdHRlZCBhcyBpdCBkb2VzIG5vdCBtYWtlIHNlbnNlXG4vLyBpbiB2MyBpbXBsZW1lbnRhdGlvblxucGF0aDpBREJMT0NLX1BBR0VfUEFUSH0sc3RhdGUubG9hZE9wdGlvbnMudmFsdWUuc2VuZEFkYmxvY2tQYWdlT3B0aW9ucykpO319dHJhY2socGF5bG9hZCxpc0J1ZmZlcmVkSW52b2NhdGlvbj1mYWxzZSl7Y29uc3QgdHlwZT0ndHJhY2snO2lmKCFzdGF0ZS5saWZlY3ljbGUubG9hZGVkLnZhbHVlKXtzdGF0ZS5ldmVudEJ1ZmZlci50b0JlUHJvY2Vzc2VkQXJyYXkudmFsdWU9Wy4uLnN0YXRlLmV2ZW50QnVmZmVyLnRvQmVQcm9jZXNzZWRBcnJheS52YWx1ZSxbdHlwZSxwYXlsb2FkXV07cmV0dXJuO310aGlzLmVycm9ySGFuZGxlci5sZWF2ZUJyZWFkY3J1bWIoYE5ldyAke3R5cGV9IGV2ZW50IC0gJHtwYXlsb2FkLm5hbWV9YCk7c3RhdGUubWV0cmljcy50cmlnZ2VyZWQudmFsdWUrPTE7dGhpcy5ldmVudE1hbmFnZXI/LmFkZEV2ZW50KHt0eXBlLG5hbWU6cGF5bG9hZC5uYW1lfHx1bmRlZmluZWQscHJvcGVydGllczpwYXlsb2FkLnByb3BlcnRpZXMsb3B0aW9uczpwYXlsb2FkLm9wdGlvbnMsY2FsbGJhY2s6cGF5bG9hZC5jYWxsYmFja30pO31pZGVudGlmeShwYXlsb2FkLGlzQnVmZmVyZWRJbnZvY2F0aW9uPWZhbHNlKXtjb25zdCB0eXBlPSdpZGVudGlmeSc7aWYoIXN0YXRlLmxpZmVjeWNsZS5sb2FkZWQudmFsdWUpe3N0YXRlLmV2ZW50QnVmZmVyLnRvQmVQcm9jZXNzZWRBcnJheS52YWx1ZT1bLi4uc3RhdGUuZXZlbnRCdWZmZXIudG9CZVByb2Nlc3NlZEFycmF5LnZhbHVlLFt0eXBlLHBheWxvYWRdXTtyZXR1cm47fXRoaXMuZXJyb3JIYW5kbGVyLmxlYXZlQnJlYWRjcnVtYihgTmV3ICR7dHlwZX0gZXZlbnRgKTtzdGF0ZS5tZXRyaWNzLnRyaWdnZXJlZC52YWx1ZSs9MTtjb25zdCBzaG91bGRSZXNldFNlc3Npb249Qm9vbGVhbihwYXlsb2FkLnVzZXJJZCYmc3RhdGUuc2Vzc2lvbi51c2VySWQudmFsdWUmJnBheWxvYWQudXNlcklkIT09c3RhdGUuc2Vzc2lvbi51c2VySWQudmFsdWUpO2lmKHNob3VsZFJlc2V0U2Vzc2lvbil7dGhpcy5yZXNldCgpO30vLyBgbnVsbGAgdmFsdWUgaW5kaWNhdGVzIHRoYXQgcHJldmlvdXMgdXNlciBJRCBuZWVkcyB0byBiZSByZXRhaW5lZFxuaWYoIWlzTnVsbChwYXlsb2FkLnVzZXJJZCkpe3RoaXMudXNlclNlc3Npb25NYW5hZ2VyPy5zZXRVc2VySWQocGF5bG9hZC51c2VySWQpO310aGlzLnVzZXJTZXNzaW9uTWFuYWdlcj8uc2V0VXNlclRyYWl0cyhwYXlsb2FkLnRyYWl0cyk7dGhpcy5ldmVudE1hbmFnZXI/LmFkZEV2ZW50KHt0eXBlLHVzZXJJZDpwYXlsb2FkLnVzZXJJZCx0cmFpdHM6cGF5bG9hZC50cmFpdHMsb3B0aW9uczpwYXlsb2FkLm9wdGlvbnMsY2FsbGJhY2s6cGF5bG9hZC5jYWxsYmFja30pO31hbGlhcyhwYXlsb2FkLGlzQnVmZmVyZWRJbnZvY2F0aW9uPWZhbHNlKXtjb25zdCB0eXBlPSdhbGlhcyc7aWYoIXN0YXRlLmxpZmVjeWNsZS5sb2FkZWQudmFsdWUpe3N0YXRlLmV2ZW50QnVmZmVyLnRvQmVQcm9jZXNzZWRBcnJheS52YWx1ZT1bLi4uc3RhdGUuZXZlbnRCdWZmZXIudG9CZVByb2Nlc3NlZEFycmF5LnZhbHVlLFt0eXBlLHBheWxvYWRdXTtyZXR1cm47fXRoaXMuZXJyb3JIYW5kbGVyLmxlYXZlQnJlYWRjcnVtYihgTmV3ICR7dHlwZX0gZXZlbnRgKTtzdGF0ZS5tZXRyaWNzLnRyaWdnZXJlZC52YWx1ZSs9MTtjb25zdCBwcmV2aW91c0lkPXBheWxvYWQuZnJvbT8/KHRoaXMuZ2V0VXNlcklkKCl8fHRoaXMudXNlclNlc3Npb25NYW5hZ2VyPy5nZXRBbm9ueW1vdXNJZCgpKTt0aGlzLmV2ZW50TWFuYWdlcj8uYWRkRXZlbnQoe3R5cGUsdG86cGF5bG9hZC50byxmcm9tOnByZXZpb3VzSWQsb3B0aW9uczpwYXlsb2FkLm9wdGlvbnMsY2FsbGJhY2s6cGF5bG9hZC5jYWxsYmFja30pO31ncm91cChwYXlsb2FkLGlzQnVmZmVyZWRJbnZvY2F0aW9uPWZhbHNlKXtjb25zdCB0eXBlPSdncm91cCc7aWYoIXN0YXRlLmxpZmVjeWNsZS5sb2FkZWQudmFsdWUpe3N0YXRlLmV2ZW50QnVmZmVyLnRvQmVQcm9jZXNzZWRBcnJheS52YWx1ZT1bLi4uc3RhdGUuZXZlbnRCdWZmZXIudG9CZVByb2Nlc3NlZEFycmF5LnZhbHVlLFt0eXBlLHBheWxvYWRdXTtyZXR1cm47fXRoaXMuZXJyb3JIYW5kbGVyLmxlYXZlQnJlYWRjcnVtYihgTmV3ICR7dHlwZX0gZXZlbnRgKTtzdGF0ZS5tZXRyaWNzLnRyaWdnZXJlZC52YWx1ZSs9MTsvLyBgbnVsbGAgdmFsdWUgaW5kaWNhdGVzIHRoYXQgcHJldmlvdXMgZ3JvdXAgSUQgbmVlZHMgdG8gYmUgcmV0YWluZWRcbmlmKCFpc051bGwocGF5bG9hZC5ncm91cElkKSl7dGhpcy51c2VyU2Vzc2lvbk1hbmFnZXI/LnNldEdyb3VwSWQocGF5bG9hZC5ncm91cElkKTt9dGhpcy51c2VyU2Vzc2lvbk1hbmFnZXI/LnNldEdyb3VwVHJhaXRzKHBheWxvYWQudHJhaXRzKTt0aGlzLmV2ZW50TWFuYWdlcj8uYWRkRXZlbnQoe3R5cGUsZ3JvdXBJZDpwYXlsb2FkLmdyb3VwSWQsdHJhaXRzOnBheWxvYWQudHJhaXRzLG9wdGlvbnM6cGF5bG9hZC5vcHRpb25zLGNhbGxiYWNrOnBheWxvYWQuY2FsbGJhY2t9KTt9cmVzZXQob3B0aW9ucyxpc0J1ZmZlcmVkSW52b2NhdGlvbj1mYWxzZSl7Y29uc3QgdHlwZT0ncmVzZXQnO2lmKCFzdGF0ZS5saWZlY3ljbGUubG9hZGVkLnZhbHVlKXtzdGF0ZS5ldmVudEJ1ZmZlci50b0JlUHJvY2Vzc2VkQXJyYXkudmFsdWU9Wy4uLnN0YXRlLmV2ZW50QnVmZmVyLnRvQmVQcm9jZXNzZWRBcnJheS52YWx1ZSxbdHlwZSxvcHRpb25zXV07cmV0dXJuO310aGlzLmVycm9ySGFuZGxlci5sZWF2ZUJyZWFkY3J1bWIoYE5ldyAke3R5cGV9IGludm9jYXRpb25gKTt0aGlzLnVzZXJTZXNzaW9uTWFuYWdlcj8ucmVzZXQob3B0aW9ucyk7fWdldEFub255bW91c0lkKG9wdGlvbnMpe3JldHVybiB0aGlzLnVzZXJTZXNzaW9uTWFuYWdlcj8uZ2V0QW5vbnltb3VzSWQob3B0aW9ucyk7fXNldEFub255bW91c0lkKGFub255bW91c0lkLHJ1ZGRlckFtcExpbmtlclBhcmFtLGlzQnVmZmVyZWRJbnZvY2F0aW9uPWZhbHNlKXtjb25zdCB0eXBlPSdzZXRBbm9ueW1vdXNJZCc7Ly8gQnVmZmVyaW5nIGlzIG5lZWRlZCBhcyBzZXR0aW5nIHRoZSBhbm9ueW1vdXMgSUQgbWF5IHJlcXVpcmUgaW52b2tpbmcgdGhlIEdvb2dsZUxpbmtlciBwbHVnaW5cbmlmKCFzdGF0ZS5saWZlY3ljbGUubG9hZGVkLnZhbHVlKXtzdGF0ZS5ldmVudEJ1ZmZlci50b0JlUHJvY2Vzc2VkQXJyYXkudmFsdWU9Wy4uLnN0YXRlLmV2ZW50QnVmZmVyLnRvQmVQcm9jZXNzZWRBcnJheS52YWx1ZSxbdHlwZSxhbm9ueW1vdXNJZCxydWRkZXJBbXBMaW5rZXJQYXJhbV1dO3JldHVybjt9dGhpcy5lcnJvckhhbmRsZXIubGVhdmVCcmVhZGNydW1iKGBOZXcgJHt0eXBlfSBpbnZvY2F0aW9uYCk7dGhpcy51c2VyU2Vzc2lvbk1hbmFnZXI/LnNldEFub255bW91c0lkKGFub255bW91c0lkLHJ1ZGRlckFtcExpbmtlclBhcmFtKTt9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbmdldFVzZXJJZCgpe3JldHVybiBzdGF0ZS5zZXNzaW9uLnVzZXJJZC52YWx1ZTt9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbmdldFVzZXJUcmFpdHMoKXtyZXR1cm4gc3RhdGUuc2Vzc2lvbi51c2VyVHJhaXRzLnZhbHVlO30vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuZ2V0R3JvdXBJZCgpe3JldHVybiBzdGF0ZS5zZXNzaW9uLmdyb3VwSWQudmFsdWU7fS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5nZXRHcm91cFRyYWl0cygpe3JldHVybiBzdGF0ZS5zZXNzaW9uLmdyb3VwVHJhaXRzLnZhbHVlO31zdGFydFNlc3Npb24oc2Vzc2lvbklkLGlzQnVmZmVyZWRJbnZvY2F0aW9uPWZhbHNlKXtjb25zdCB0eXBlPSdzdGFydFNlc3Npb24nO2lmKCFzdGF0ZS5saWZlY3ljbGUubG9hZGVkLnZhbHVlKXtzdGF0ZS5ldmVudEJ1ZmZlci50b0JlUHJvY2Vzc2VkQXJyYXkudmFsdWU9Wy4uLnN0YXRlLmV2ZW50QnVmZmVyLnRvQmVQcm9jZXNzZWRBcnJheS52YWx1ZSxbdHlwZSxzZXNzaW9uSWRdXTtyZXR1cm47fXRoaXMuZXJyb3JIYW5kbGVyLmxlYXZlQnJlYWRjcnVtYihgTmV3ICR7dHlwZX0gaW52b2NhdGlvbmApO3RoaXMudXNlclNlc3Npb25NYW5hZ2VyPy5zdGFydChzZXNzaW9uSWQpO31lbmRTZXNzaW9uKGlzQnVmZmVyZWRJbnZvY2F0aW9uPWZhbHNlKXtjb25zdCB0eXBlPSdlbmRTZXNzaW9uJztpZighc3RhdGUubGlmZWN5Y2xlLmxvYWRlZC52YWx1ZSl7c3RhdGUuZXZlbnRCdWZmZXIudG9CZVByb2Nlc3NlZEFycmF5LnZhbHVlPVsuLi5zdGF0ZS5ldmVudEJ1ZmZlci50b0JlUHJvY2Vzc2VkQXJyYXkudmFsdWUsW3R5cGVdXTtyZXR1cm47fXRoaXMuZXJyb3JIYW5kbGVyLmxlYXZlQnJlYWRjcnVtYihgTmV3ICR7dHlwZX0gaW52b2NhdGlvbmApO3RoaXMudXNlclNlc3Npb25NYW5hZ2VyPy5lbmQoKTt9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbmdldFNlc3Npb25JZCgpe2NvbnN0IHNlc3Npb25JZD10aGlzLnVzZXJTZXNzaW9uTWFuYWdlcj8uZ2V0U2Vzc2lvbklkKCk7cmV0dXJuIHNlc3Npb25JZD8/bnVsbDt9Y29uc2VudChvcHRpb25zLGlzQnVmZmVyZWRJbnZvY2F0aW9uPWZhbHNlKXtjb25zdCB0eXBlPSdjb25zZW50JztpZighc3RhdGUubGlmZWN5Y2xlLmxvYWRlZC52YWx1ZSl7c3RhdGUuZXZlbnRCdWZmZXIudG9CZVByb2Nlc3NlZEFycmF5LnZhbHVlPVsuLi5zdGF0ZS5ldmVudEJ1ZmZlci50b0JlUHJvY2Vzc2VkQXJyYXkudmFsdWUsW3R5cGUsb3B0aW9uc11dO3JldHVybjt9dGhpcy5lcnJvckhhbmRsZXIubGVhdmVCcmVhZGNydW1iKGBOZXcgY29uc2VudCBpbnZvY2F0aW9uYCk7cigoKT0+e3N0YXRlLmNvbnNlbnRzLnByZUNvbnNlbnQudmFsdWU9ey4uLnN0YXRlLmNvbnNlbnRzLnByZUNvbnNlbnQudmFsdWUsZW5hYmxlZDpmYWxzZX07c3RhdGUuY29uc2VudHMucG9zdENvbnNlbnQudmFsdWU9Z2V0VmFsaWRQb3N0Q29uc2VudE9wdGlvbnMob3B0aW9ucyk7Y29uc3R7aW5pdGlhbGl6ZWQsY29uc2VudHNEYXRhfT1nZXRDb25zZW50TWFuYWdlbWVudERhdGEoc3RhdGUuY29uc2VudHMucG9zdENvbnNlbnQudmFsdWUuY29uc2VudE1hbmFnZW1lbnQsdGhpcy5sb2dnZXIpO3N0YXRlLmNvbnNlbnRzLmluaXRpYWxpemVkLnZhbHVlPWluaXRpYWxpemVkO3N0YXRlLmNvbnNlbnRzLmRhdGEudmFsdWU9Y29uc2VudHNEYXRhO30pOy8vIFVwZGF0ZSBjb25zZW50cyBkYXRhIGluIHN0YXRlXG5pZihzdGF0ZS5jb25zZW50cy5lbmFibGVkLnZhbHVlJiYhc3RhdGUuY29uc2VudHMuaW5pdGlhbGl6ZWQudmFsdWUpe3RoaXMucGx1Z2luc01hbmFnZXI/Lmludm9rZVNpbmdsZShgY29uc2VudE1hbmFnZXIudXBkYXRlQ29uc2VudHNJbmZvYCxzdGF0ZSx0aGlzLnN0b3JlTWFuYWdlcix0aGlzLmxvZ2dlcik7fS8vIFJlLWluaXQgc3RvcmUgbWFuYWdlclxudGhpcy5zdG9yZU1hbmFnZXI/LmluaXRpYWxpemVTdG9yYWdlU3RhdGUoKTsvLyBSZS1pbml0IHVzZXIgc2Vzc2lvbiBtYW5hZ2VyXG50aGlzLnVzZXJTZXNzaW9uTWFuYWdlcj8uc3luY1N0b3JhZ2VEYXRhVG9TdGF0ZSgpOy8vIFJlc3VtZSBldmVudCBtYW5hZ2VyIHRvIHByb2Nlc3MgdGhlIGV2ZW50cyB0byBkZXN0aW5hdGlvbnNcbnRoaXMuZXZlbnRNYW5hZ2VyPy5yZXN1bWUoKTt0aGlzLmxvYWREZXN0aW5hdGlvbnMoKTt0aGlzLnNlbmRUcmFja2luZ0V2ZW50cyhpc0J1ZmZlcmVkSW52b2NhdGlvbik7fXNlbmRUcmFja2luZ0V2ZW50cyhpc0J1ZmZlcmVkSW52b2NhdGlvbil7Ly8gSWYgaXNCdWZmZXJlZEludm9jYXRpb24gaXMgdHJ1ZSwgdGhlbiB0aGUgdHJhY2tpbmcgZXZlbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGVcbi8vIGV2ZW50cyBidWZmZXIgYXJyYXkgc28gdGhhdCBhbnkgb3RoZXIgcHJlbG9hZCBldmVudHMgKG1haW5seSBmcm9tIHF1ZXJ5IHN0cmluZyBBUEkpIHdpbGwgYmUgcHJvY2Vzc2VkIGZpcnN0LlxuaWYoc3RhdGUuY29uc2VudHMucG9zdENvbnNlbnQudmFsdWUudHJhY2tDb25zZW50KXtjb25zdCB0cmFja09wdGlvbnM9dHJhY2tBcmd1bWVudHNUb0NhbGxPcHRpb25zKENPTlNFTlRfVFJBQ0tfRVZFTlRfTkFNRSk7aWYoaXNCdWZmZXJlZEludm9jYXRpb24pe3N0YXRlLmV2ZW50QnVmZmVyLnRvQmVQcm9jZXNzZWRBcnJheS52YWx1ZT1bLi4uc3RhdGUuZXZlbnRCdWZmZXIudG9CZVByb2Nlc3NlZEFycmF5LnZhbHVlLFsndHJhY2snLHRyYWNrT3B0aW9uc11dO31lbHNlIHt0aGlzLnRyYWNrKHRyYWNrT3B0aW9ucyk7fX1pZihzdGF0ZS5jb25zZW50cy5wb3N0Q29uc2VudC52YWx1ZS5zZW5kUGFnZUV2ZW50KXtjb25zdCBwYWdlT3B0aW9ucz1wYWdlQXJndW1lbnRzVG9DYWxsT3B0aW9ucygpO2lmKGlzQnVmZmVyZWRJbnZvY2F0aW9uKXtzdGF0ZS5ldmVudEJ1ZmZlci50b0JlUHJvY2Vzc2VkQXJyYXkudmFsdWU9Wy4uLnN0YXRlLmV2ZW50QnVmZmVyLnRvQmVQcm9jZXNzZWRBcnJheS52YWx1ZSxbJ3BhZ2UnLHBhZ2VPcHRpb25zXV07fWVsc2Uge3RoaXMucGFnZShwYWdlT3B0aW9ucyk7fX19c2V0QXV0aFRva2VuKHRva2VuKXt0aGlzLnVzZXJTZXNzaW9uTWFuYWdlcj8uc2V0QXV0aFRva2VuKHRva2VuKTt9LyoqXG4gICAqIEFkZCBhIGN1c3RvbSBpbnRlZ3JhdGlvbiBmb3IgYSBjdXN0b20gZGVzdGluYXRpb24uXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbklkIC0gVGhlIElEIG9mIHRoZSBjdXN0b20gZGVzdGluYXRpb24gZnJvbSB0aGUgUnVkZGVyU3RhY2sgZGFzaGJvYXJkLlxuICAgKiBAcGFyYW0gaW50ZWdyYXRpb24gLSBUaGUgY3VzdG9tIGludGVncmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIGlzQnVmZmVyZWRJbnZvY2F0aW9uIC0gV2hldGhlciB0aGUgaW52b2NhdGlvbiBpcyBidWZmZXJlZC5cbiAgICovYWRkQ3VzdG9tSW50ZWdyYXRpb24oZGVzdGluYXRpb25JZCxpbnRlZ3JhdGlvbixpc0J1ZmZlcmVkSW52b2NhdGlvbj1mYWxzZSl7Y29uc3QgdHlwZT0nYWRkQ3VzdG9tSW50ZWdyYXRpb24nO2lmKGlzQnVmZmVyZWRJbnZvY2F0aW9uKXt0aGlzLmVycm9ySGFuZGxlci5sZWF2ZUJyZWFkY3J1bWIoYE5ldyAke3R5cGV9IGludm9jYXRpb25gKTt0aGlzLnBsdWdpbnNNYW5hZ2VyPy5pbnZva2VTaW5nbGUoJ25hdGl2ZURlc3RpbmF0aW9ucy5hZGRDdXN0b21JbnRlZ3JhdGlvbicsZGVzdGluYXRpb25JZCxpbnRlZ3JhdGlvbixzdGF0ZSx0aGlzLmxvZ2dlcik7fWVsc2Uge2lmKHN0YXRlLmxpZmVjeWNsZS5sb2FkZWQudmFsdWUpe3RoaXMubG9nZ2VyLmVycm9yKENVU1RPTV9JTlRFR1JBVElPTl9DQU5OT1RfQkVfQURERURfRVJST1IoQU5BTFlUSUNTX0NPUkUsZGVzdGluYXRpb25JZCkpO3JldHVybjt9c3RhdGUuZXZlbnRCdWZmZXIudG9CZVByb2Nlc3NlZEFycmF5LnZhbHVlPVsuLi5zdGF0ZS5ldmVudEJ1ZmZlci50b0JlUHJvY2Vzc2VkQXJyYXkudmFsdWUsW3R5cGUsZGVzdGluYXRpb25JZCxpbnRlZ3JhdGlvbl1dO319Ly8gRW5kIGNvbnN1bWVyIGV4cG9zZWQgbWV0aG9kc1xufVxuXG4vKlxuICogUnVkZGVyQW5hbHl0aWNzIGZhY2FkZSBzaW5nbGV0b24gdGhhdCBpcyBleHBvc2VkIGFzIGdsb2JhbCBvYmplY3QgYW5kIHdpbGw6XG4gKiBleHBvc2Ugb3ZlcmxvYWRlZCBtZXRob2RzXG4gKiBoYW5kbGUgbXVsdGlwbGUgQW5hbHl0aWNzIGluc3RhbmNlc1xuICogY29uc3VtZSBTREsgcHJlbG9hZCBldmVudCBidWZmZXJcbiAqL2NsYXNzIFJ1ZGRlckFuYWx5dGljc3svLyBTVEFSVC1OTy1TT05BUi1TQ0FOXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29uYXJqcy9wdWJsaWMtc3RhdGljLXJlYWRvbmx5XG5zdGF0aWMgZ2xvYmFsU2luZ2xldG9uPW51bGw7Ly8gRU5ELU5PLVNPTkFSLVNDQU5cbmFuYWx5dGljc0luc3RhbmNlcz17fTtkZWZhdWx0QW5hbHl0aWNzS2V5PScnO2xvZ2dlcj1kZWZhdWx0TG9nZ2VyOy8vIFNpbmdsZXRvbiB3aXRoIGNvbnN0cnVjdG9yIGJpbmQgbWV0aG9kc1xuY29uc3RydWN0b3IoKXt0cnl7aWYoUnVkZGVyQW5hbHl0aWNzLmdsb2JhbFNpbmdsZXRvbil7Ly8gU1RBUlQtTk8tU09OQVItU0NBTlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxucmV0dXJuIFJ1ZGRlckFuYWx5dGljcy5nbG9iYWxTaW5nbGV0b247Ly8gRU5ELU5PLVNPTkFSLVNDQU5cbn1SdWRkZXJBbmFseXRpY3MuaW5pdGlhbGl6ZUdsb2JhbFJlc291cmNlcygpO3RoaXMuc2V0RGVmYXVsdEluc3RhbmNlS2V5PXRoaXMuc2V0RGVmYXVsdEluc3RhbmNlS2V5LmJpbmQodGhpcyk7dGhpcy5nZXRBbmFseXRpY3NJbnN0YW5jZT10aGlzLmdldEFuYWx5dGljc0luc3RhbmNlLmJpbmQodGhpcyk7dGhpcy5sb2FkPXRoaXMubG9hZC5iaW5kKHRoaXMpO3RoaXMucmVhZHk9dGhpcy5yZWFkeS5iaW5kKHRoaXMpO3RoaXMudHJpZ2dlckJ1ZmZlcmVkTG9hZEV2ZW50PXRoaXMudHJpZ2dlckJ1ZmZlcmVkTG9hZEV2ZW50LmJpbmQodGhpcyk7dGhpcy5wYWdlPXRoaXMucGFnZS5iaW5kKHRoaXMpO3RoaXMudHJhY2s9dGhpcy50cmFjay5iaW5kKHRoaXMpO3RoaXMuaWRlbnRpZnk9dGhpcy5pZGVudGlmeS5iaW5kKHRoaXMpO3RoaXMuYWxpYXM9dGhpcy5hbGlhcy5iaW5kKHRoaXMpO3RoaXMuZ3JvdXA9dGhpcy5ncm91cC5iaW5kKHRoaXMpO3RoaXMucmVzZXQ9dGhpcy5yZXNldC5iaW5kKHRoaXMpO3RoaXMuZ2V0QW5vbnltb3VzSWQ9dGhpcy5nZXRBbm9ueW1vdXNJZC5iaW5kKHRoaXMpO3RoaXMuc2V0QW5vbnltb3VzSWQ9dGhpcy5zZXRBbm9ueW1vdXNJZC5iaW5kKHRoaXMpO3RoaXMuZ2V0VXNlcklkPXRoaXMuZ2V0VXNlcklkLmJpbmQodGhpcyk7dGhpcy5nZXRVc2VyVHJhaXRzPXRoaXMuZ2V0VXNlclRyYWl0cy5iaW5kKHRoaXMpO3RoaXMuZ2V0R3JvdXBJZD10aGlzLmdldEdyb3VwSWQuYmluZCh0aGlzKTt0aGlzLmdldEdyb3VwVHJhaXRzPXRoaXMuZ2V0R3JvdXBUcmFpdHMuYmluZCh0aGlzKTt0aGlzLnN0YXJ0U2Vzc2lvbj10aGlzLnN0YXJ0U2Vzc2lvbi5iaW5kKHRoaXMpO3RoaXMuZW5kU2Vzc2lvbj10aGlzLmVuZFNlc3Npb24uYmluZCh0aGlzKTt0aGlzLmdldFNlc3Npb25JZD10aGlzLmdldFNlc3Npb25JZC5iaW5kKHRoaXMpO3RoaXMuc2V0QXV0aFRva2VuPXRoaXMuc2V0QXV0aFRva2VuLmJpbmQodGhpcyk7dGhpcy5jb25zZW50PXRoaXMuY29uc2VudC5iaW5kKHRoaXMpO3RoaXMuYWRkQ3VzdG9tSW50ZWdyYXRpb249dGhpcy5hZGRDdXN0b21JbnRlZ3JhdGlvbi5iaW5kKHRoaXMpO3RoaXMuY3JlYXRlU2FmZUFuYWx5dGljc0luc3RhbmNlKCk7UnVkZGVyQW5hbHl0aWNzLmdsb2JhbFNpbmdsZXRvbj10aGlzO3N0YXRlLmF1dG9UcmFjay5wYWdlTGlmZWN5Y2xlLnBhZ2VWaWV3SWQudmFsdWU9Z2VuZXJhdGVVVUlEKCk7c3RhdGUuYXV0b1RyYWNrLnBhZ2VMaWZlY3ljbGUucGFnZUxvYWRlZFRpbWVzdGFtcC52YWx1ZT1EYXRlLm5vdygpOy8vIHN0YXJ0IGxvYWRpbmcgaWYgYSBsb2FkIGV2ZW50IHdhcyBidWZmZXJlZCBvciB3YWl0IGZvciBleHBsaWNpdCBsb2FkIGNhbGxcbnRoaXMudHJpZ2dlckJ1ZmZlcmVkTG9hZEV2ZW50KCk7Ly8gQXNzaWduIHRvIGdsb2JhbCBcInJ1ZGRlcmFuYWx5dGljc1wiIG9iamVjdCBhZnRlciBwcm9jZXNzaW5nIHRoZSBwcmVsb2FkIGJ1ZmZlciAoaWYgYW55IGV4aXN0cylcbi8vIGZvciBDRE4gYnVuZGxpbmcgSUlGRSBleHBvcnRzIGNvdmVycyB0aGlzIGJ1dCBmb3IgbnBtIEVTTSBhbmQgQ0pTIGJ1bmRsaW5nIGhhcyB0byBiZSBkb25lIGV4cGxpY2l0bHlcbmdsb2JhbFRoaXMucnVkZGVyYW5hbHl0aWNzPXRoaXM7fWNhdGNoKGVycm9yKXtkaXNwYXRjaEVycm9yRXZlbnQoZXJyb3IpO319LyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBpbnN0YW5jZSB0aGF0IGNhbiBiZSB1c2VkXG4gICAqIHRvIGNhbGwgYSBzdWJzZXQgb2YgbWV0aG9kcyBvZiB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICogSXQgaXMgdHlwaWNhbGx5IHVzZWQgdG8gZXhwb3NlIHRoZSBhbmFseXRpY3MgaW5zdGFuY2UgdG8gdGhlIGludGVncmF0aW9ucyAoc3RhbmRhcmQgYW5kIGN1c3RvbSlcbiAgICovY3JlYXRlU2FmZUFuYWx5dGljc0luc3RhbmNlKCl7c3RhdGUubGlmZWN5Y2xlLnNhZmVBbmFseXRpY3NJbnN0YW5jZS52YWx1ZT17cGFnZTp0aGlzLnBhZ2UuYmluZCh0aGlzKSx0cmFjazp0aGlzLnRyYWNrLmJpbmQodGhpcyksaWRlbnRpZnk6dGhpcy5pZGVudGlmeS5iaW5kKHRoaXMpLGFsaWFzOnRoaXMuYWxpYXMuYmluZCh0aGlzKSxncm91cDp0aGlzLmdyb3VwLmJpbmQodGhpcyksZ2V0QW5vbnltb3VzSWQ6dGhpcy5nZXRBbm9ueW1vdXNJZC5iaW5kKHRoaXMpLGdldFVzZXJJZDp0aGlzLmdldFVzZXJJZC5iaW5kKHRoaXMpLGdldFVzZXJUcmFpdHM6dGhpcy5nZXRVc2VyVHJhaXRzLmJpbmQodGhpcyksZ2V0R3JvdXBJZDp0aGlzLmdldEdyb3VwSWQuYmluZCh0aGlzKSxnZXRHcm91cFRyYWl0czp0aGlzLmdldEdyb3VwVHJhaXRzLmJpbmQodGhpcyksZ2V0U2Vzc2lvbklkOnRoaXMuZ2V0U2Vzc2lvbklkLmJpbmQodGhpcyl9O31zdGF0aWMgaW5pdGlhbGl6ZUdsb2JhbFJlc291cmNlcygpey8vIFdlIG5lZWQgdG8gaW5pdGlhbGl6ZSB0aGUgZXJyb3IgaGFuZGxlciBmaXJzdCB0byBjYXRjaCBhbnkgdW5oYW5kbGVkIGVycm9ycyBvY2N1cnJpbmcgaW4gdGhpcyBtb2R1bGUgYXMgd2VsbFxuZGVmYXVsdEVycm9ySGFuZGxlci5pbml0KCk7Ly8gSW5pdGlhbGl6ZSB0aGUgc3RvcmFnZSBlbmdpbmVzIHdpdGggZGVmYXVsdCBvcHRpb25zXG5kZWZhdWx0Q29va2llU3RvcmFnZS5jb25maWd1cmUoKTtkZWZhdWx0TG9jYWxTdG9yYWdlLmNvbmZpZ3VyZSgpO2RlZmF1bHRTZXNzaW9uU3RvcmFnZS5jb25maWd1cmUoKTtkZWZhdWx0SW5NZW1vcnlTdG9yYWdlLmNvbmZpZ3VyZSgpO30vKipcbiAgICogU2V0IGluc3RhbmNlIHRvIHVzZSBpZiBubyBzcGVjaWZpYyB3cml0ZUtleSBpcyBwcm92aWRlZCBpbiBtZXRob2RzXG4gICAqIGF1dG9tYXRpY2FsbHkgZm9yIHRoZSBmaXJzdCBjcmVhdGVkIGluc3RhbmNlXG4gICAqIFRPRE86IHRvIHN1cHBvcnQgbXVsdGlwbGUgYW5hbHl0aWNzIGluc3RhbmNlcyBpbiB0aGUgbmVhciBmdXR1cmVcbiAgICovc2V0RGVmYXVsdEluc3RhbmNlS2V5KHdyaXRlS2V5KXsvLyBJTVA6IEFkZCB0cnktY2F0Y2ggYmxvY2sgdG8gaGFuZGxlIGFueSB1bmhhbmRsZWQgZXJyb3JzXG4vLyBzaW1pbGFyIHRvIG90aGVyIHB1YmxpYyBtZXRob2RzXG4vLyBpZiB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZ29lcyBiZXlvbmRcbi8vIHRoaXMgc2ltcGxlIGltcGxlbWVudGF0aW9uXG5pZihpc1N0cmluZyh3cml0ZUtleSkmJndyaXRlS2V5KXt0aGlzLmRlZmF1bHRBbmFseXRpY3NLZXk9d3JpdGVLZXk7fX0vKipcbiAgICogUmV0cmlldmUgYW4gZXhpc3RpbmcgYW5hbHl0aWNzIGluc3RhbmNlXG4gICAqL2dldEFuYWx5dGljc0luc3RhbmNlKHdyaXRlS2V5KXt0cnl7bGV0IGluc3RhbmNlSWQ9d3JpdGVLZXk7aWYoIWlzU3RyaW5nKGluc3RhbmNlSWQpfHwhaW5zdGFuY2VJZCl7aW5zdGFuY2VJZD10aGlzLmRlZmF1bHRBbmFseXRpY3NLZXk7fWNvbnN0IGFuYWx5dGljc0luc3RhbmNlRXhpc3RzPUJvb2xlYW4odGhpcy5hbmFseXRpY3NJbnN0YW5jZXNbaW5zdGFuY2VJZF0pO2lmKCFhbmFseXRpY3NJbnN0YW5jZUV4aXN0cyl7dGhpcy5hbmFseXRpY3NJbnN0YW5jZXNbaW5zdGFuY2VJZF09bmV3IEFuYWx5dGljcygpO31yZXR1cm4gdGhpcy5hbmFseXRpY3NJbnN0YW5jZXNbaW5zdGFuY2VJZF07fWNhdGNoKGVycm9yKXtkaXNwYXRjaEVycm9yRXZlbnQoZXJyb3IpO3JldHVybiB1bmRlZmluZWQ7fX0vKipcbiAgICogTG9hZHMgdGhlIFNES1xuICAgKiBAcGFyYW0gd3JpdGVLZXkgU291cmNlIHdyaXRlIGtleVxuICAgKiBAcGFyYW0gZGF0YVBsYW5lVXJsIERhdGEgcGxhbmUgVVJMXG4gICAqIEBwYXJhbSBsb2FkT3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIFNES1xuICAgKiBAcmV0dXJucyBub25lXG4gICAqL2xvYWQod3JpdGVLZXksZGF0YVBsYW5lVXJsLGxvYWRPcHRpb25zKXt0cnl7aWYodGhpcy5hbmFseXRpY3NJbnN0YW5jZXNbd3JpdGVLZXldKXtyZXR1cm47fXRoaXMuc2V0RGVmYXVsdEluc3RhbmNlS2V5KHdyaXRlS2V5KTsvLyBUcmFjayBwYWdlIGxvYWRlZCBsaWZlY3ljbGUgZXZlbnQgaWYgZW5hYmxlZFxudGhpcy50cmFja1BhZ2VMaWZlY3ljbGVFdmVudHMobG9hZE9wdGlvbnMpOy8vIEdldCB0aGUgcHJlbG9hZGVkIGV2ZW50cyBhcnJheSBmcm9tIGdsb2JhbCBidWZmZXIgaW5zdGVhZCBvZiB3aW5kb3cucnVkZGVyYW5hbHl0aWNzXG4vLyBhcyB0aGUgY29uc3RydWN0b3IgbXVzdCBoYXZlIGFscmVhZHkgcHVzaGVkIHRoZSBldmVudHMgdG8gdGhlIGdsb2JhbCBidWZmZXJcbmNvbnN0IHByZWxvYWRlZEV2ZW50c0FycmF5PWdldEV4cG9zZWRHbG9iYWwoR0xPQkFMX1BSRUxPQURfQlVGRkVSKTsvLyBUaGUgYXJyYXkgd2lsbCBiZSBtdXRhdGVkIGluIHRoZSBiZWxvdyBtZXRob2RcbnByb21vdGVQcmVsb2FkZWRDb25zZW50RXZlbnRzVG9Ub3AocHJlbG9hZGVkRXZlbnRzQXJyYXkpO3NldEV4cG9zZWRHbG9iYWwoR0xPQkFMX1BSRUxPQURfQlVGRkVSLGNsb25lKHByZWxvYWRlZEV2ZW50c0FycmF5KSk7dGhpcy5nZXRBbmFseXRpY3NJbnN0YW5jZSh3cml0ZUtleSk/LmxvYWQod3JpdGVLZXksZGF0YVBsYW5lVXJsLGdldFNhbml0aXplZFZhbHVlKGxvYWRPcHRpb25zKSk7fWNhdGNoKGVycm9yKXtkaXNwYXRjaEVycm9yRXZlbnQoZXJyb3IpO319LyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gdHJhY2sgcGFnZSBsaWZlY3ljbGUgZXZlbnRzIGxpa2UgcGFnZSBsb2FkZWQgYW5kIHBhZ2UgdW5sb2FkZWRcbiAgICogQHBhcmFtIGxvYWRPcHRpb25zXG4gICAqIEByZXR1cm5zXG4gICAqL3RyYWNrUGFnZUxpZmVjeWNsZUV2ZW50cyhsb2FkT3B0aW9ucyl7Y29uc3R7YXV0b1RyYWNrLHVzZUJlYWNvbn09bG9hZE9wdGlvbnM/P3t9O2NvbnN0e2VuYWJsZWQ6YXV0b1RyYWNrRW5hYmxlZD1mYWxzZSxvcHRpb25zOmF1dG9UcmFja09wdGlvbnM9e30scGFnZUxpZmVjeWNsZX09YXV0b1RyYWNrPz97fTtjb25zdHtldmVudHM9W1BhZ2VMaWZlY3ljbGVFdmVudHMuVU5MT0FERURdLGVuYWJsZWQ6cGFnZUxpZmVjeWNsZUVuYWJsZWQ9YXV0b1RyYWNrRW5hYmxlZCxvcHRpb25zPWF1dG9UcmFja09wdGlvbnN9PXBhZ2VMaWZlY3ljbGU/P3t9O3N0YXRlLmF1dG9UcmFjay5wYWdlTGlmZWN5Y2xlLmVuYWJsZWQudmFsdWU9cGFnZUxpZmVjeWNsZUVuYWJsZWQ7Ly8gU2V0IHRoZSBhdXRvVHJhY2sgZW5hYmxlZCBzdGF0ZVxuLy8gaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBhdXRvVHJhY2sgb3B0aW9ucyBpcyBlbmFibGVkXG4vLyBJTVBPUlRBTlQ6IG1ha2Ugc3VyZSB0aGlzIGlzIGRvbmUgYXQgdGhlIGVuZCBhcyBpdCBkZXBlbmRzIG9uIHRoZSBhYm92ZSBzdGF0ZXNcbnN0YXRlLmF1dG9UcmFjay5lbmFibGVkLnZhbHVlPWF1dG9UcmFja0VuYWJsZWR8fHBhZ2VMaWZlY3ljbGVFbmFibGVkO2lmKCFwYWdlTGlmZWN5Y2xlRW5hYmxlZCl7cmV0dXJuO310aGlzLnNldHVwUGFnZVVubG9hZFRyYWNraW5nKGV2ZW50cyx1c2VCZWFjb24sb3B0aW9ucyk7fS8qKlxuICAgKiBTZXR1cCBwYWdlIHVubG9hZCB0cmFja2luZyBpZiBlbmFibGVkXG4gICAqIEBwYXJhbSBldmVudHNcbiAgICogQHBhcmFtIHVzZUJlYWNvblxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9zZXR1cFBhZ2VVbmxvYWRUcmFja2luZyhldmVudHMsdXNlQmVhY29uLG9wdGlvbnMpe2lmKGV2ZW50cy5sZW5ndGg9PT0wfHxldmVudHMuaW5jbHVkZXMoUGFnZUxpZmVjeWNsZUV2ZW50cy5VTkxPQURFRCkpe2lmKHVzZUJlYWNvbj09PXRydWUpe29uUGFnZUxlYXZlKGlzQWNjZXNzaWJsZT0+e2lmKGlzQWNjZXNzaWJsZT09PWZhbHNlJiZzdGF0ZS5saWZlY3ljbGUubG9hZGVkLnZhbHVlKXtjb25zdCBwYWdlVW5sb2FkZWRUaW1lc3RhbXA9RGF0ZS5ub3coKTtjb25zdCB0aW1lT25QYWdlPXBhZ2VVbmxvYWRlZFRpbWVzdGFtcC1zdGF0ZS5hdXRvVHJhY2sucGFnZUxpZmVjeWNsZS5wYWdlTG9hZGVkVGltZXN0YW1wLnZhbHVlO3RoaXMudHJhY2soUGFnZUxpZmVjeWNsZUV2ZW50cy5VTkxPQURFRCx7dGltZU9uUGFnZX0sey4uLm9wdGlvbnMsb3JpZ2luYWxUaW1lc3RhbXA6Z2V0Rm9ybWF0dGVkVGltZXN0YW1wKG5ldyBEYXRlKHBhZ2VVbmxvYWRlZFRpbWVzdGFtcCkpfSk7fX0sdHJ1ZSk7fWVsc2Ugey8vIGxvZyB3YXJuaW5nIGlmIGJlYWNvbiBpcyBkaXNhYmxlZFxudGhpcy5sb2dnZXIud2FybihQQUdFX1VOTE9BRF9PTl9CRUFDT05fRElTQUJMRURfV0FSTklORyhSU0EpKTt9fX0vKipcbiAgICogVHJpZ2dlciBsb2FkIGV2ZW50IGluIGJ1ZmZlciBxdWV1ZSBpZiBleGlzdHMgYW5kIHN0b3JlcyB0aGVcbiAgICogcmVtYWluaW5nIHByZWxvYWRlZCBldmVudHMgYXJyYXkgaW4gZ2xvYmFsIG9iamVjdFxuICAgKi90cmlnZ2VyQnVmZmVyZWRMb2FkRXZlbnQoKXtjb25zdCBwcmVsb2FkZWRFdmVudHNBcnJheT1BcnJheS5pc0FycmF5KGdsb2JhbFRoaXMucnVkZGVyYW5hbHl0aWNzKT9nbG9iYWxUaGlzLnJ1ZGRlcmFuYWx5dGljczpbXTsvLyBHZXQgYW55IGxvYWQgbWV0aG9kIGNhbGwgdGhhdCBpcyBidWZmZXJlZCBpZiBhbnlcbi8vIEJUVywgbG9hZCBtZXRob2QgaXMgYWxzbyByZW1vdmVkIGZyb20gdGhlIGFycmF5XG4vLyBTbywgdGhlIEFuYWx5dGljcyBvYmplY3QgY2FuIGRpcmVjdGx5IGNvbnN1bWUgdGhlIHJlbWFpbmluZyBldmVudHNcbmNvbnN0IGxvYWRFdmVudD1nZXRQcmVsb2FkZWRMb2FkRXZlbnQocHJlbG9hZGVkRXZlbnRzQXJyYXkpOy8vIFNldCB0aGUgZmluYWwgcHJlbG9hZGVkIGV2ZW50cyBhcnJheSBpbiBnbG9iYWwgb2JqZWN0XG5zZXRFeHBvc2VkR2xvYmFsKEdMT0JBTF9QUkVMT0FEX0JVRkZFUixjbG9uZShbLi4ucHJlbG9hZGVkRXZlbnRzQXJyYXldKSk7Ly8gUHJvY2VzcyBsb2FkIG1ldGhvZCBpZiBwcmVzZW50IGluIHRoZSBidWZmZXJlZCByZXF1ZXN0c1xuaWYobG9hZEV2ZW50Lmxlbmd0aD4wKXsvLyBSZW1vdmUgdGhlIGV2ZW50IG5hbWUgZnJvbSB0aGUgQnVmZmVyZWQgRXZlbnQgYXJyYXkgYW5kIGtlZXAgb25seSBhcmd1bWVudHNcbmxvYWRFdmVudC5zaGlmdCgpOy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1pZ25vcmVcbnRoaXMubG9hZC5hcHBseShudWxsLGxvYWRFdmVudCk7fX0vKipcbiAgICogR2V0IHJlYWR5IGNhbGxiYWNrIGFyZ3VtZW50cyBhbmQgZm9yd2FyZCB0byByZWFkeSBjYWxsXG4gICAqL3JlYWR5KGNhbGxiYWNrKXt0cnl7dGhpcy5nZXRBbmFseXRpY3NJbnN0YW5jZSgpPy5yZWFkeShnZXRTYW5pdGl6ZWRWYWx1ZShjYWxsYmFjaykpO31jYXRjaChlcnJvcil7ZGlzcGF0Y2hFcnJvckV2ZW50KGVycm9yKTt9fS8qKlxuICAgKiBQcm9jZXNzIHBhZ2UgYXJndW1lbnRzIGFuZCBmb3J3YXJkIHRvIHBhZ2UgY2FsbFxuICAgKi8vLyBUaGVzZSBvdmVybG9hZHMgc2hvdWxkIGJlIHNhbWUgYXMgQW5hbHl0aWNzUGFnZU1ldGhvZCBpbiBAcnVkZGVyc3RhY2svYW5hbHl0aWNzLWpzLWNvbW1vbi90eXBlcy9JUnVkZGVyQW5hbHl0aWNzXG5wYWdlKGNhdGVnb3J5LG5hbWUscHJvcGVydGllcyxvcHRpb25zLGNhbGxiYWNrKXt0cnl7dGhpcy5nZXRBbmFseXRpY3NJbnN0YW5jZSgpPy5wYWdlKHBhZ2VBcmd1bWVudHNUb0NhbGxPcHRpb25zKGdldFNhbml0aXplZFZhbHVlKGNhdGVnb3J5KSxnZXRTYW5pdGl6ZWRWYWx1ZShuYW1lKSxnZXRTYW5pdGl6ZWRWYWx1ZShwcm9wZXJ0aWVzKSxnZXRTYW5pdGl6ZWRWYWx1ZShvcHRpb25zKSxnZXRTYW5pdGl6ZWRWYWx1ZShjYWxsYmFjaykpKTt9Y2F0Y2goZXJyb3Ipe2Rpc3BhdGNoRXJyb3JFdmVudChlcnJvcik7fX0vKipcbiAgICogUHJvY2VzcyB0cmFjayBhcmd1bWVudHMgYW5kIGZvcndhcmQgdG8gcGFnZSBjYWxsXG4gICAqLy8vIFRoZXNlIG92ZXJsb2FkcyBzaG91bGQgYmUgc2FtZSBhcyBBbmFseXRpY3NUcmFja01ldGhvZCBpbiBAcnVkZGVyc3RhY2svYW5hbHl0aWNzLWpzLWNvbW1vbi90eXBlcy9JUnVkZGVyQW5hbHl0aWNzXG50cmFjayhldmVudCxwcm9wZXJ0aWVzLG9wdGlvbnMsY2FsbGJhY2spe3RyeXt0aGlzLmdldEFuYWx5dGljc0luc3RhbmNlKCk/LnRyYWNrKHRyYWNrQXJndW1lbnRzVG9DYWxsT3B0aW9ucyhnZXRTYW5pdGl6ZWRWYWx1ZShldmVudCksZ2V0U2FuaXRpemVkVmFsdWUocHJvcGVydGllcyksZ2V0U2FuaXRpemVkVmFsdWUob3B0aW9ucyksZ2V0U2FuaXRpemVkVmFsdWUoY2FsbGJhY2spKSk7fWNhdGNoKGVycm9yKXtkaXNwYXRjaEVycm9yRXZlbnQoZXJyb3IpO319LyoqXG4gICAqIFByb2Nlc3MgaWRlbnRpZnkgYXJndW1lbnRzIGFuZCBmb3J3YXJkIHRvIHBhZ2UgY2FsbFxuICAgKi8vLyBUaGVzZSBvdmVybG9hZHMgc2hvdWxkIGJlIHNhbWUgYXMgQW5hbHl0aWNzSWRlbnRpZnlNZXRob2QgaW4gQHJ1ZGRlcnN0YWNrL2FuYWx5dGljcy1qcy1jb21tb24vdHlwZXMvSVJ1ZGRlckFuYWx5dGljc1xuaWRlbnRpZnkodXNlcklkLHRyYWl0cyxvcHRpb25zLGNhbGxiYWNrKXt0cnl7dGhpcy5nZXRBbmFseXRpY3NJbnN0YW5jZSgpPy5pZGVudGlmeShpZGVudGlmeUFyZ3VtZW50c1RvQ2FsbE9wdGlvbnMoZ2V0U2FuaXRpemVkVmFsdWUodXNlcklkKSxnZXRTYW5pdGl6ZWRWYWx1ZSh0cmFpdHMpLGdldFNhbml0aXplZFZhbHVlKG9wdGlvbnMpLGdldFNhbml0aXplZFZhbHVlKGNhbGxiYWNrKSkpO31jYXRjaChlcnJvcil7ZGlzcGF0Y2hFcnJvckV2ZW50KGVycm9yKTt9fS8qKlxuICAgKiBQcm9jZXNzIGFsaWFzIGFyZ3VtZW50cyBhbmQgZm9yd2FyZCB0byBwYWdlIGNhbGxcbiAgICovLy8gVGhlc2Ugb3ZlcmxvYWRzIHNob3VsZCBiZSBzYW1lIGFzIEFuYWx5dGljc0FsaWFzTWV0aG9kIGluIEBydWRkZXJzdGFjay9hbmFseXRpY3MtanMtY29tbW9uL3R5cGVzL0lSdWRkZXJBbmFseXRpY3NcbmFsaWFzKHRvLGZyb20sb3B0aW9ucyxjYWxsYmFjayl7dHJ5e3RoaXMuZ2V0QW5hbHl0aWNzSW5zdGFuY2UoKT8uYWxpYXMoYWxpYXNBcmd1bWVudHNUb0NhbGxPcHRpb25zKGdldFNhbml0aXplZFZhbHVlKHRvKSxnZXRTYW5pdGl6ZWRWYWx1ZShmcm9tKSxnZXRTYW5pdGl6ZWRWYWx1ZShvcHRpb25zKSxnZXRTYW5pdGl6ZWRWYWx1ZShjYWxsYmFjaykpKTt9Y2F0Y2goZXJyb3Ipe2Rpc3BhdGNoRXJyb3JFdmVudChlcnJvcik7fX0vKipcbiAgICogUHJvY2VzcyBncm91cCBhcmd1bWVudHMgYW5kIGZvcndhcmQgdG8gcGFnZSBjYWxsXG4gICAqLy8vIFRoZXNlIG92ZXJsb2FkcyBzaG91bGQgYmUgc2FtZSBhcyBBbmFseXRpY3NHcm91cE1ldGhvZCBpbiBAcnVkZGVyc3RhY2svYW5hbHl0aWNzLWpzLWNvbW1vbi90eXBlcy9JUnVkZGVyQW5hbHl0aWNzXG5ncm91cChncm91cElkLHRyYWl0cyxvcHRpb25zLGNhbGxiYWNrKXt0cnl7dGhpcy5nZXRBbmFseXRpY3NJbnN0YW5jZSgpPy5ncm91cChncm91cEFyZ3VtZW50c1RvQ2FsbE9wdGlvbnMoZ2V0U2FuaXRpemVkVmFsdWUoZ3JvdXBJZCksZ2V0U2FuaXRpemVkVmFsdWUodHJhaXRzKSxnZXRTYW5pdGl6ZWRWYWx1ZShvcHRpb25zKSxnZXRTYW5pdGl6ZWRWYWx1ZShjYWxsYmFjaykpKTt9Y2F0Y2goZXJyb3Ipe2Rpc3BhdGNoRXJyb3JFdmVudChlcnJvcik7fX0vKipcbiAgICogUmVzZXQgdGhlIGFuYWx5dGljcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBSZXNldCBvcHRpb25zLiBFeGNlcHQgZm9yIGFub255bW91c0lkLCBpbml0aWFsUmVmZXJyZXIsIGFuZCBpbml0aWFsUmVmZXJyaW5nRG9tYWluXG4gICAqIGFsbCBvdGhlciB2YWx1ZXMgd2lsbCBiZSByZXNldCBieSBkZWZhdWx0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiByZXNldCh7XG4gICAqICBlbnRyaWVzOiB7XG4gICAqICAgIGFub255bW91c0lkOiB0cnVlLFxuICAgKiAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIHJlc2V0KHtcbiAgICogIGVudHJpZXM6IHtcbiAgICogICAgdXNlcklkOiBmYWxzZSxcbiAgICogICAgc2Vzc2lvbkluZm86IGZhbHNlLFxuICAgKiAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEByZXR1cm5zIG5vbmVcbiAgICovLyoqXG4gICAqIFJlc2V0IHRoZSBhbmFseXRpY3MgaW5zdGFuY2VcbiAgICogQHBhcmFtIHJlc2V0QW5vbnltb3VzSWQgUmVzZXQgYW5vbnltb3VzIElEXG4gICAqIEByZXR1cm5zIG5vbmVcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc2V0KG9wdGlvbnMpIGluc3RlYWRcbiAgICovcmVzZXQob3B0aW9ucyl7dHJ5e3RoaXMuZ2V0QW5hbHl0aWNzSW5zdGFuY2UoKT8ucmVzZXQoZ2V0U2FuaXRpemVkVmFsdWUob3B0aW9ucykpO31jYXRjaChlcnJvcil7ZGlzcGF0Y2hFcnJvckV2ZW50KGVycm9yKTt9fWdldEFub255bW91c0lkKG9wdGlvbnMpe3RyeXtyZXR1cm4gdGhpcy5nZXRBbmFseXRpY3NJbnN0YW5jZSgpPy5nZXRBbm9ueW1vdXNJZChnZXRTYW5pdGl6ZWRWYWx1ZShvcHRpb25zKSk7fWNhdGNoKGVycm9yKXtkaXNwYXRjaEVycm9yRXZlbnQoZXJyb3IpO3JldHVybiB1bmRlZmluZWQ7fX1zZXRBbm9ueW1vdXNJZChhbm9ueW1vdXNJZCxydWRkZXJBbXBMaW5rZXJQYXJhbSl7dHJ5e3RoaXMuZ2V0QW5hbHl0aWNzSW5zdGFuY2UoKT8uc2V0QW5vbnltb3VzSWQoZ2V0U2FuaXRpemVkVmFsdWUoYW5vbnltb3VzSWQpLGdldFNhbml0aXplZFZhbHVlKHJ1ZGRlckFtcExpbmtlclBhcmFtKSk7fWNhdGNoKGVycm9yKXtkaXNwYXRjaEVycm9yRXZlbnQoZXJyb3IpO319Z2V0VXNlcklkKCl7dHJ5e3JldHVybiB0aGlzLmdldEFuYWx5dGljc0luc3RhbmNlKCk/LmdldFVzZXJJZCgpO31jYXRjaChlcnJvcil7ZGlzcGF0Y2hFcnJvckV2ZW50KGVycm9yKTtyZXR1cm4gdW5kZWZpbmVkO319Z2V0VXNlclRyYWl0cygpe3RyeXtyZXR1cm4gdGhpcy5nZXRBbmFseXRpY3NJbnN0YW5jZSgpPy5nZXRVc2VyVHJhaXRzKCk7fWNhdGNoKGVycm9yKXtkaXNwYXRjaEVycm9yRXZlbnQoZXJyb3IpO3JldHVybiB1bmRlZmluZWQ7fX1nZXRHcm91cElkKCl7dHJ5e3JldHVybiB0aGlzLmdldEFuYWx5dGljc0luc3RhbmNlKCk/LmdldEdyb3VwSWQoKTt9Y2F0Y2goZXJyb3Ipe2Rpc3BhdGNoRXJyb3JFdmVudChlcnJvcik7cmV0dXJuIHVuZGVmaW5lZDt9fWdldEdyb3VwVHJhaXRzKCl7dHJ5e3JldHVybiB0aGlzLmdldEFuYWx5dGljc0luc3RhbmNlKCk/LmdldEdyb3VwVHJhaXRzKCk7fWNhdGNoKGVycm9yKXtkaXNwYXRjaEVycm9yRXZlbnQoZXJyb3IpO3JldHVybiB1bmRlZmluZWQ7fX1zdGFydFNlc3Npb24oc2Vzc2lvbklkKXt0cnl7dGhpcy5nZXRBbmFseXRpY3NJbnN0YW5jZSgpPy5zdGFydFNlc3Npb24oZ2V0U2FuaXRpemVkVmFsdWUoc2Vzc2lvbklkKSk7fWNhdGNoKGVycm9yKXtkaXNwYXRjaEVycm9yRXZlbnQoZXJyb3IpO319ZW5kU2Vzc2lvbigpe3RyeXt0aGlzLmdldEFuYWx5dGljc0luc3RhbmNlKCk/LmVuZFNlc3Npb24oKTt9Y2F0Y2goZXJyb3Ipe2Rpc3BhdGNoRXJyb3JFdmVudChlcnJvcik7fX1nZXRTZXNzaW9uSWQoKXt0cnl7cmV0dXJuIHRoaXMuZ2V0QW5hbHl0aWNzSW5zdGFuY2UoKT8uZ2V0U2Vzc2lvbklkKCk7fWNhdGNoKGVycm9yKXtkaXNwYXRjaEVycm9yRXZlbnQoZXJyb3IpO3JldHVybiB1bmRlZmluZWQ7fX1zZXRBdXRoVG9rZW4odG9rZW4pe3RyeXt0aGlzLmdldEFuYWx5dGljc0luc3RhbmNlKCk/LnNldEF1dGhUb2tlbihnZXRTYW5pdGl6ZWRWYWx1ZSh0b2tlbikpO31jYXRjaChlcnJvcil7ZGlzcGF0Y2hFcnJvckV2ZW50KGVycm9yKTt9fWNvbnNlbnQob3B0aW9ucyl7dHJ5e3RoaXMuZ2V0QW5hbHl0aWNzSW5zdGFuY2UoKT8uY29uc2VudChnZXRTYW5pdGl6ZWRWYWx1ZShvcHRpb25zKSk7fWNhdGNoKGVycm9yKXtkaXNwYXRjaEVycm9yRXZlbnQoZXJyb3IpO319YWRkQ3VzdG9tSW50ZWdyYXRpb24oZGVzdGluYXRpb25JZCxpbnRlZ3JhdGlvbil7dHJ5e3RoaXMuZ2V0QW5hbHl0aWNzSW5zdGFuY2UoKT8uYWRkQ3VzdG9tSW50ZWdyYXRpb24oZ2V0U2FuaXRpemVkVmFsdWUoZGVzdGluYXRpb25JZCksZ2V0U2FuaXRpemVkVmFsdWUoaW50ZWdyYXRpb24pKTt9Y2F0Y2goZXJyb3Ipe2Rpc3BhdGNoRXJyb3JFdmVudChlcnJvcik7fX19XG5cbmV4cG9ydCB7IFJ1ZGRlckFuYWx5dGljcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@rudderstack/analytics-js/dist/npm/modern/esm/index.mjs\n"));

/***/ })

}]);